import { defineComponent as Wp, ref as ns, watch as Z6, onMounted as jp, nextTick as Q6, openBlock as _u, createElementBlock as Hu, normalizeClass as Uu, normalizeStyle as X6, withKeys as eJ, createElementVNode as ds, withModifiers as tJ, createCommentVNode as rJ } from "vue";
function nJ(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Or = {}, vu, bv;
function aJ() {
  if (bv)
    return vu;
  bv = 1;
  function t(e) {
    this.content = e;
  }
  return t.prototype = {
    constructor: t,
    find: function(e) {
      for (var r = 0; r < this.content.length; r += 2)
        if (this.content[r] === e)
          return r;
      return -1;
    },
    // :: (string) → ?any
    // Retrieve the value stored under `key`, or return undefined when
    // no such key exists.
    get: function(e) {
      var r = this.find(e);
      return r == -1 ? void 0 : this.content[r + 1];
    },
    // :: (string, any, ?string) → OrderedMap
    // Create a new map by replacing the value of `key` with a new
    // value, or adding a binding to the end of the map. If `newKey` is
    // given, the key of the binding will be replaced with that key.
    update: function(e, r, n) {
      var a = n && n != e ? this.remove(n) : this, i = a.find(e), o = a.content.slice();
      return i == -1 ? o.push(n || e, r) : (o[i + 1] = r, n && (o[i] = n)), new t(o);
    },
    // :: (string) → OrderedMap
    // Return a map with the given key removed, if it existed.
    remove: function(e) {
      var r = this.find(e);
      if (r == -1)
        return this;
      var n = this.content.slice();
      return n.splice(r, 2), new t(n);
    },
    // :: (string, any) → OrderedMap
    // Add a new key to the start of the map.
    addToStart: function(e, r) {
      return new t([e, r].concat(this.remove(e).content));
    },
    // :: (string, any) → OrderedMap
    // Add a new key to the end of the map.
    addToEnd: function(e, r) {
      var n = this.remove(e).content.slice();
      return n.push(e, r), new t(n);
    },
    // :: (string, string, any) → OrderedMap
    // Add a key after the given key. If `place` is not found, the new
    // key is added to the end.
    addBefore: function(e, r, n) {
      var a = this.remove(r), i = a.content.slice(), o = a.find(e);
      return i.splice(o == -1 ? i.length : o, 0, r, n), new t(i);
    },
    // :: ((key: string, value: any))
    // Call the given function for each key/value pair in the map, in
    // order.
    forEach: function(e) {
      for (var r = 0; r < this.content.length; r += 2)
        e(this.content[r], this.content[r + 1]);
    },
    // :: (union<Object, OrderedMap>) → OrderedMap
    // Create a new map by prepending the keys in this map that don't
    // appear in `map` before the keys in `map`.
    prepend: function(e) {
      return e = t.from(e), e.size ? new t(e.content.concat(this.subtract(e).content)) : this;
    },
    // :: (union<Object, OrderedMap>) → OrderedMap
    // Create a new map by appending the keys in this map that don't
    // appear in `map` after the keys in `map`.
    append: function(e) {
      return e = t.from(e), e.size ? new t(this.subtract(e).content.concat(e.content)) : this;
    },
    // :: (union<Object, OrderedMap>) → OrderedMap
    // Create a map containing all the keys in this map that don't
    // appear in `map`.
    subtract: function(e) {
      var r = this;
      e = t.from(e);
      for (var n = 0; n < e.content.length; n += 2)
        r = r.remove(e.content[n]);
      return r;
    },
    // :: () → Object
    // Turn ordered map into a plain object.
    toObject: function() {
      var e = {};
      return this.forEach(function(r, n) {
        e[r] = n;
      }), e;
    },
    // :: number
    // The amount of keys in this map.
    get size() {
      return this.content.length >> 1;
    }
  }, t.from = function(e) {
    if (e instanceof t)
      return e;
    var r = [];
    if (e)
      for (var n in e)
        r.push(n, e[n]);
    return new t(r);
  }, vu = t, vu;
}
var kv;
function io() {
  if (kv)
    return Or;
  kv = 1;
  function t(N, S) {
    return i(N) || a(N, S) || r(N, S) || e();
  }
  function e() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function r(N, S) {
    if (N) {
      if (typeof N == "string")
        return n(N, S);
      var v = Object.prototype.toString.call(N).slice(8, -1);
      if (v === "Object" && N.constructor && (v = N.constructor.name), v === "Map" || v === "Set")
        return Array.from(N);
      if (v === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(v))
        return n(N, S);
    }
  }
  function n(N, S) {
    (S == null || S > N.length) && (S = N.length);
    for (var v = 0, b = new Array(S); v < S; v++)
      b[v] = N[v];
    return b;
  }
  function a(N, S) {
    var v = N == null ? null : typeof Symbol < "u" && N[Symbol.iterator] || N["@@iterator"];
    if (v != null) {
      var b = [], A = !0, B = !1, z, G;
      try {
        for (v = v.call(N); !(A = (z = v.next()).done) && (b.push(z.value), !(S && b.length === S)); A = !0)
          ;
      } catch (fe) {
        B = !0, G = fe;
      } finally {
        try {
          !A && v.return != null && v.return();
        } finally {
          if (B)
            throw G;
        }
      }
      return b;
    }
  }
  function i(N) {
    if (Array.isArray(N))
      return N;
  }
  function o() {
    return typeof Reflect < "u" && Reflect.get ? o = Reflect.get : o = function(S, v, b) {
      var A = u(S, v);
      if (A) {
        var B = Object.getOwnPropertyDescriptor(A, v);
        return B.get ? B.get.call(arguments.length < 3 ? S : b) : B.value;
      }
    }, o.apply(this, arguments);
  }
  function u(N, S) {
    for (; !Object.prototype.hasOwnProperty.call(N, S) && (N = K(N), N !== null); )
      ;
    return N;
  }
  function m(N, S) {
    if (typeof S != "function" && S !== null)
      throw new TypeError("Super expression must either be null or a function");
    N.prototype = Object.create(S && S.prototype, { constructor: { value: N, writable: !0, configurable: !0 } }), Object.defineProperty(N, "prototype", { writable: !1 }), S && _(N, S);
  }
  function y(N) {
    var S = P();
    return function() {
      var b = K(N), A;
      if (S) {
        var B = K(this).constructor;
        A = Reflect.construct(b, arguments, B);
      } else
        A = b.apply(this, arguments);
      return C(this, A);
    };
  }
  function C(N, S) {
    if (S && (oe(S) === "object" || typeof S == "function"))
      return S;
    if (S !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return T(N);
  }
  function T(N) {
    if (N === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return N;
  }
  function x(N) {
    var S = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return x = function(b) {
      if (b === null || !q(b))
        return b;
      if (typeof b != "function")
        throw new TypeError("Super expression must either be null or a function");
      if (typeof S < "u") {
        if (S.has(b))
          return S.get(b);
        S.set(b, A);
      }
      function A() {
        return M(b, arguments, K(this).constructor);
      }
      return A.prototype = Object.create(b.prototype, { constructor: { value: A, enumerable: !1, writable: !0, configurable: !0 } }), _(A, b);
    }, x(N);
  }
  function M(N, S, v) {
    return P() ? M = Reflect.construct : M = function(A, B, z) {
      var G = [null];
      G.push.apply(G, B);
      var fe = Function.bind.apply(A, G), Ce = new fe();
      return z && _(Ce, z.prototype), Ce;
    }, M.apply(null, arguments);
  }
  function P() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function q(N) {
    return Function.toString.call(N).indexOf("[native code]") !== -1;
  }
  function _(N, S) {
    return _ = Object.setPrototypeOf || function(b, A) {
      return b.__proto__ = A, b;
    }, _(N, S);
  }
  function K(N) {
    return K = Object.setPrototypeOf ? Object.getPrototypeOf : function(v) {
      return v.__proto__ || Object.getPrototypeOf(v);
    }, K(N);
  }
  function X(N, S) {
    if (!(N instanceof S))
      throw new TypeError("Cannot call a class as a function");
  }
  function ie(N, S) {
    for (var v = 0; v < S.length; v++) {
      var b = S[v];
      b.enumerable = b.enumerable || !1, b.configurable = !0, "value" in b && (b.writable = !0), Object.defineProperty(N, b.key, b);
    }
  }
  function ee(N, S, v) {
    return S && ie(N.prototype, S), v && ie(N, v), Object.defineProperty(N, "prototype", { writable: !1 }), N;
  }
  function oe(N) {
    "@babel/helpers - typeof";
    return oe = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(S) {
      return typeof S;
    } : function(S) {
      return S && typeof Symbol == "function" && S.constructor === Symbol && S !== Symbol.prototype ? "symbol" : typeof S;
    }, oe(N);
  }
  Object.defineProperty(Or, "__esModule", {
    value: !0
  });
  var ue = aJ();
  function pe(N) {
    return N && oe(N) === "object" && "default" in N ? N : {
      default: N
    };
  }
  var Se = pe(ue);
  function Re(N, S, v) {
    for (var b = 0; ; b++) {
      if (b == N.childCount || b == S.childCount)
        return N.childCount == S.childCount ? null : v;
      var A = N.child(b), B = S.child(b);
      if (A == B) {
        v += A.nodeSize;
        continue;
      }
      if (!A.sameMarkup(B))
        return v;
      if (A.isText && A.text != B.text) {
        for (var z = 0; A.text[z] == B.text[z]; z++)
          v++;
        return v;
      }
      if (A.content.size || B.content.size) {
        var G = Re(A.content, B.content, v + 1);
        if (G != null)
          return G;
      }
      v += A.nodeSize;
    }
  }
  function Me(N, S, v, b) {
    for (var A = N.childCount, B = S.childCount; ; ) {
      if (A == 0 || B == 0)
        return A == B ? null : {
          a: v,
          b
        };
      var z = N.child(--A), G = S.child(--B), fe = z.nodeSize;
      if (z == G) {
        v -= fe, b -= fe;
        continue;
      }
      if (!z.sameMarkup(G))
        return {
          a: v,
          b
        };
      if (z.isText && z.text != G.text) {
        for (var Ce = 0, Ie = Math.min(z.text.length, G.text.length); Ce < Ie && z.text[z.text.length - Ce - 1] == G.text[G.text.length - Ce - 1]; )
          Ce++, v--, b--;
        return {
          a: v,
          b
        };
      }
      if (z.content.size || G.content.size) {
        var Le = Me(z.content, G.content, v - 1, b - 1);
        if (Le)
          return Le;
      }
      v -= fe, b -= fe;
    }
  }
  var ze = function() {
    function N(S, v) {
      if (X(this, N), this.content = S, this.size = v || 0, v == null)
        for (var b = 0; b < S.length; b++)
          this.size += S[b].nodeSize;
    }
    return ee(N, [{
      key: "nodesBetween",
      value: function(v, b, A) {
        for (var B = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, z = arguments.length > 4 ? arguments[4] : void 0, G = 0, fe = 0; fe < b; G++) {
          var Ce = this.content[G], Ie = fe + Ce.nodeSize;
          if (Ie > v && A(Ce, B + fe, z || null, G) !== !1 && Ce.content.size) {
            var Le = fe + 1;
            Ce.nodesBetween(Math.max(0, v - Le), Math.min(Ce.content.size, b - Le), A, B + Le);
          }
          fe = Ie;
        }
      }
    }, {
      key: "descendants",
      value: function(v) {
        this.nodesBetween(0, this.size, v);
      }
    }, {
      key: "textBetween",
      value: function(v, b, A, B) {
        var z = "", G = !0;
        return this.nodesBetween(v, b, function(fe, Ce) {
          fe.isText ? (z += fe.text.slice(Math.max(v, Ce) - Ce, b - Ce), G = !A) : fe.isLeaf ? (B ? z += typeof B == "function" ? B(fe) : B : fe.type.spec.leafText && (z += fe.type.spec.leafText(fe)), G = !A) : !G && fe.isBlock && (z += A, G = !0);
        }, 0), z;
      }
    }, {
      key: "append",
      value: function(v) {
        if (!v.size)
          return this;
        if (!this.size)
          return v;
        var b = this.lastChild, A = v.firstChild, B = this.content.slice(), z = 0;
        for (b.isText && b.sameMarkup(A) && (B[B.length - 1] = b.withText(b.text + A.text), z = 1); z < v.content.length; z++)
          B.push(v.content[z]);
        return new N(B, this.size + v.size);
      }
    }, {
      key: "cut",
      value: function(v) {
        var b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.size;
        if (v == 0 && b == this.size)
          return this;
        var A = [], B = 0;
        if (b > v)
          for (var z = 0, G = 0; G < b; z++) {
            var fe = this.content[z], Ce = G + fe.nodeSize;
            Ce > v && ((G < v || Ce > b) && (fe.isText ? fe = fe.cut(Math.max(0, v - G), Math.min(fe.text.length, b - G)) : fe = fe.cut(Math.max(0, v - G - 1), Math.min(fe.content.size, b - G - 1))), A.push(fe), B += fe.nodeSize), G = Ce;
          }
        return new N(A, B);
      }
    }, {
      key: "cutByIndex",
      value: function(v, b) {
        return v == b ? N.empty : v == 0 && b == this.content.length ? this : new N(this.content.slice(v, b));
      }
    }, {
      key: "replaceChild",
      value: function(v, b) {
        var A = this.content[v];
        if (A == b)
          return this;
        var B = this.content.slice(), z = this.size + b.nodeSize - A.nodeSize;
        return B[v] = b, new N(B, z);
      }
    }, {
      key: "addToStart",
      value: function(v) {
        return new N([v].concat(this.content), this.size + v.nodeSize);
      }
    }, {
      key: "addToEnd",
      value: function(v) {
        return new N(this.content.concat(v), this.size + v.nodeSize);
      }
    }, {
      key: "eq",
      value: function(v) {
        if (this.content.length != v.content.length)
          return !1;
        for (var b = 0; b < this.content.length; b++)
          if (!this.content[b].eq(v.content[b]))
            return !1;
        return !0;
      }
    }, {
      key: "firstChild",
      get: function() {
        return this.content.length ? this.content[0] : null;
      }
    }, {
      key: "lastChild",
      get: function() {
        return this.content.length ? this.content[this.content.length - 1] : null;
      }
    }, {
      key: "childCount",
      get: function() {
        return this.content.length;
      }
    }, {
      key: "child",
      value: function(v) {
        var b = this.content[v];
        if (!b)
          throw new RangeError("Index " + v + " out of range for " + this);
        return b;
      }
    }, {
      key: "maybeChild",
      value: function(v) {
        return this.content[v] || null;
      }
    }, {
      key: "forEach",
      value: function(v) {
        for (var b = 0, A = 0; b < this.content.length; b++) {
          var B = this.content[b];
          v(B, A, b), A += B.nodeSize;
        }
      }
    }, {
      key: "findDiffStart",
      value: function(v) {
        var b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        return Re(this, v, b);
      }
    }, {
      key: "findDiffEnd",
      value: function(v) {
        var b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.size, A = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : v.size;
        return Me(this, v, b, A);
      }
    }, {
      key: "findIndex",
      value: function(v) {
        var b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
        if (v == 0)
          return je(0, v);
        if (v == this.size)
          return je(this.content.length, v);
        if (v > this.size || v < 0)
          throw new RangeError("Position ".concat(v, " outside of fragment (").concat(this, ")"));
        for (var A = 0, B = 0; ; A++) {
          var z = this.child(A), G = B + z.nodeSize;
          if (G >= v)
            return G == v || b > 0 ? je(A + 1, G) : je(A, B);
          B = G;
        }
      }
    }, {
      key: "toString",
      value: function() {
        return "<" + this.toStringInner() + ">";
      }
    }, {
      key: "toStringInner",
      value: function() {
        return this.content.join(", ");
      }
    }, {
      key: "toJSON",
      value: function() {
        return this.content.length ? this.content.map(function(v) {
          return v.toJSON();
        }) : null;
      }
    }], [{
      key: "fromJSON",
      value: function(v, b) {
        if (!b)
          return N.empty;
        if (!Array.isArray(b))
          throw new RangeError("Invalid input for Fragment.fromJSON");
        return new N(b.map(v.nodeFromJSON));
      }
    }, {
      key: "fromArray",
      value: function(v) {
        if (!v.length)
          return N.empty;
        for (var b, A = 0, B = 0; B < v.length; B++) {
          var z = v[B];
          A += z.nodeSize, B && z.isText && v[B - 1].sameMarkup(z) ? (b || (b = v.slice(0, B)), b[b.length - 1] = z.withText(b[b.length - 1].text + z.text)) : b && b.push(z);
        }
        return new N(b || v, A);
      }
    }, {
      key: "from",
      value: function(v) {
        if (!v)
          return N.empty;
        if (v instanceof N)
          return v;
        if (Array.isArray(v))
          return this.fromArray(v);
        if (v.attrs)
          return new N([v], v.nodeSize);
        throw new RangeError("Can not convert " + v + " to a Fragment" + (v.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
      }
    }]), N;
  }();
  ze.empty = new ze([], 0);
  var vt = {
    index: 0,
    offset: 0
  };
  function je(N, S) {
    return vt.index = N, vt.offset = S, vt;
  }
  function rt(N, S) {
    if (N === S)
      return !0;
    if (!(N && oe(N) == "object") || !(S && oe(S) == "object"))
      return !1;
    var v = Array.isArray(N);
    if (Array.isArray(S) != v)
      return !1;
    if (v) {
      if (N.length != S.length)
        return !1;
      for (var b = 0; b < N.length; b++)
        if (!rt(N[b], S[b]))
          return !1;
    } else {
      for (var A in N)
        if (!(A in S) || !rt(N[A], S[A]))
          return !1;
      for (var B in S)
        if (!(B in N))
          return !1;
    }
    return !0;
  }
  var at = function() {
    function N(S, v) {
      X(this, N), this.type = S, this.attrs = v;
    }
    return ee(N, [{
      key: "addToSet",
      value: function(v) {
        for (var b, A = !1, B = 0; B < v.length; B++) {
          var z = v[B];
          if (this.eq(z))
            return v;
          if (this.type.excludes(z.type))
            b || (b = v.slice(0, B));
          else {
            if (z.type.excludes(this.type))
              return v;
            !A && z.type.rank > this.type.rank && (b || (b = v.slice(0, B)), b.push(this), A = !0), b && b.push(z);
          }
        }
        return b || (b = v.slice()), A || b.push(this), b;
      }
    }, {
      key: "removeFromSet",
      value: function(v) {
        for (var b = 0; b < v.length; b++)
          if (this.eq(v[b]))
            return v.slice(0, b).concat(v.slice(b + 1));
        return v;
      }
    }, {
      key: "isInSet",
      value: function(v) {
        for (var b = 0; b < v.length; b++)
          if (this.eq(v[b]))
            return !0;
        return !1;
      }
    }, {
      key: "eq",
      value: function(v) {
        return this == v || this.type == v.type && rt(this.attrs, v.attrs);
      }
    }, {
      key: "toJSON",
      value: function() {
        var v = {
          type: this.type.name
        };
        for (var b in this.attrs) {
          v.attrs = this.attrs;
          break;
        }
        return v;
      }
    }], [{
      key: "fromJSON",
      value: function(v, b) {
        if (!b)
          throw new RangeError("Invalid input for Mark.fromJSON");
        var A = v.marks[b.type];
        if (!A)
          throw new RangeError("There is no mark type ".concat(b.type, " in this schema"));
        return A.create(b.attrs);
      }
    }, {
      key: "sameSet",
      value: function(v, b) {
        if (v == b)
          return !0;
        if (v.length != b.length)
          return !1;
        for (var A = 0; A < v.length; A++)
          if (!v[A].eq(b[A]))
            return !1;
        return !0;
      }
    }, {
      key: "setFrom",
      value: function(v) {
        if (!v || Array.isArray(v) && v.length == 0)
          return N.none;
        if (v instanceof N)
          return [v];
        var b = v.slice();
        return b.sort(function(A, B) {
          return A.type.rank - B.type.rank;
        }), b;
      }
    }]), N;
  }();
  at.none = [];
  var St = function(N) {
    m(v, N);
    var S = y(v);
    function v() {
      return X(this, v), S.apply(this, arguments);
    }
    return ee(v);
  }(x(Error)), pt = function() {
    function N(S, v, b) {
      X(this, N), this.content = S, this.openStart = v, this.openEnd = b;
    }
    return ee(N, [{
      key: "size",
      get: function() {
        return this.content.size - this.openStart - this.openEnd;
      }
    }, {
      key: "insertAt",
      value: function(v, b) {
        var A = Ft(this.content, v + this.openStart, b);
        return A && new N(A, this.openStart, this.openEnd);
      }
    }, {
      key: "removeBetween",
      value: function(v, b) {
        return new N(Pt(this.content, v + this.openStart, b + this.openStart), this.openStart, this.openEnd);
      }
    }, {
      key: "eq",
      value: function(v) {
        return this.content.eq(v.content) && this.openStart == v.openStart && this.openEnd == v.openEnd;
      }
    }, {
      key: "toString",
      value: function() {
        return this.content + "(" + this.openStart + "," + this.openEnd + ")";
      }
    }, {
      key: "toJSON",
      value: function() {
        if (!this.content.size)
          return null;
        var v = {
          content: this.content.toJSON()
        };
        return this.openStart > 0 && (v.openStart = this.openStart), this.openEnd > 0 && (v.openEnd = this.openEnd), v;
      }
    }], [{
      key: "fromJSON",
      value: function(v, b) {
        if (!b)
          return N.empty;
        var A = b.openStart || 0, B = b.openEnd || 0;
        if (typeof A != "number" || typeof B != "number")
          throw new RangeError("Invalid input for Slice.fromJSON");
        return new N(ze.fromJSON(v, b.content), A, B);
      }
    }, {
      key: "maxOpen",
      value: function(v) {
        for (var b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, A = 0, B = 0, z = v.firstChild; z && !z.isLeaf && (b || !z.type.spec.isolating); z = z.firstChild)
          A++;
        for (var G = v.lastChild; G && !G.isLeaf && (b || !G.type.spec.isolating); G = G.lastChild)
          B++;
        return new N(v, A, B);
      }
    }]), N;
  }();
  pt.empty = new pt(ze.empty, 0, 0);
  function Pt(N, S, v) {
    var b = N.findIndex(S), A = b.index, B = b.offset, z = N.maybeChild(A), G = N.findIndex(v), fe = G.index, Ce = G.offset;
    if (B == S || z.isText) {
      if (Ce != v && !N.child(fe).isText)
        throw new RangeError("Removing non-flat range");
      return N.cut(0, S).append(N.cut(v));
    }
    if (A != fe)
      throw new RangeError("Removing non-flat range");
    return N.replaceChild(A, z.copy(Pt(z.content, S - B - 1, v - B - 1)));
  }
  function Ft(N, S, v, b) {
    var A = N.findIndex(S), B = A.index, z = A.offset, G = N.maybeChild(B);
    if (z == S || G.isText)
      return b && !b.canReplace(B, B, v) ? null : N.cut(0, S).append(v).append(N.cut(S));
    var fe = Ft(G.content, S - z - 1, v);
    return fe && N.replaceChild(B, G.copy(fe));
  }
  function Je(N, S, v) {
    if (v.openStart > N.depth)
      throw new St("Inserted content deeper than insertion position");
    if (N.depth - v.openStart != S.depth - v.openEnd)
      throw new St("Inconsistent open depths");
    return Nt(N, S, v, 0);
  }
  function Nt(N, S, v, b) {
    var A = N.index(b), B = N.node(b);
    if (A == S.index(b) && b < N.depth - v.openStart) {
      var z = Nt(N, S, v, b + 1);
      return B.copy(B.content.replaceChild(A, z));
    } else if (v.content.size)
      if (!v.openStart && !v.openEnd && N.depth == b && S.depth == b) {
        var G = N.parent, fe = G.content;
        return he(G, fe.cut(0, N.parentOffset).append(v.content).append(fe.cut(S.parentOffset)));
      } else {
        var Ce = ae(v, N), Ie = Ce.start, Le = Ce.end;
        return he(B, le(N, Ie, Le, S, b));
      }
    else
      return he(B, te(N, S, b));
  }
  function yt(N, S) {
    if (!S.type.compatibleContent(N.type))
      throw new St("Cannot join " + S.type.name + " onto " + N.type.name);
  }
  function At(N, S, v) {
    var b = N.node(v);
    return yt(b, S.node(v)), b;
  }
  function lt(N, S) {
    var v = S.length - 1;
    v >= 0 && N.isText && N.sameMarkup(S[v]) ? S[v] = N.withText(S[v].text + N.text) : S.push(N);
  }
  function Rt(N, S, v, b) {
    var A = (S || N).node(v), B = 0, z = S ? S.index(v) : A.childCount;
    N && (B = N.index(v), N.depth > v ? B++ : N.textOffset && (lt(N.nodeAfter, b), B++));
    for (var G = B; G < z; G++)
      lt(A.child(G), b);
    S && S.depth == v && S.textOffset && lt(S.nodeBefore, b);
  }
  function he(N, S) {
    return N.type.checkContent(S), N.copy(S);
  }
  function le(N, S, v, b, A) {
    var B = N.depth > A && At(N, S, A + 1), z = b.depth > A && At(v, b, A + 1), G = [];
    return Rt(null, N, A, G), B && z && S.index(A) == v.index(A) ? (yt(B, z), lt(he(B, le(N, S, v, b, A + 1)), G)) : (B && lt(he(B, te(N, S, A + 1)), G), Rt(S, v, A, G), z && lt(he(z, te(v, b, A + 1)), G)), Rt(b, null, A, G), new ze(G);
  }
  function te(N, S, v) {
    var b = [];
    if (Rt(null, N, v, b), N.depth > v) {
      var A = At(N, S, v + 1);
      lt(he(A, te(N, S, v + 1)), b);
    }
    return Rt(S, null, v, b), new ze(b);
  }
  function ae(N, S) {
    for (var v = S.depth - N.openStart, b = S.node(v), A = b.copy(N.content), B = v - 1; B >= 0; B--)
      A = S.node(B).copy(ze.from(A));
    return {
      start: A.resolveNoCache(N.openStart + v),
      end: A.resolveNoCache(A.content.size - N.openEnd - v)
    };
  }
  var Z = function() {
    function N(S, v, b) {
      X(this, N), this.pos = S, this.path = v, this.parentOffset = b, this.depth = v.length / 3 - 1;
    }
    return ee(N, [{
      key: "resolveDepth",
      value: function(v) {
        return v == null ? this.depth : v < 0 ? this.depth + v : v;
      }
    }, {
      key: "parent",
      get: function() {
        return this.node(this.depth);
      }
    }, {
      key: "doc",
      get: function() {
        return this.node(0);
      }
    }, {
      key: "node",
      value: function(v) {
        return this.path[this.resolveDepth(v) * 3];
      }
    }, {
      key: "index",
      value: function(v) {
        return this.path[this.resolveDepth(v) * 3 + 1];
      }
    }, {
      key: "indexAfter",
      value: function(v) {
        return v = this.resolveDepth(v), this.index(v) + (v == this.depth && !this.textOffset ? 0 : 1);
      }
    }, {
      key: "start",
      value: function(v) {
        return v = this.resolveDepth(v), v == 0 ? 0 : this.path[v * 3 - 1] + 1;
      }
    }, {
      key: "end",
      value: function(v) {
        return v = this.resolveDepth(v), this.start(v) + this.node(v).content.size;
      }
    }, {
      key: "before",
      value: function(v) {
        if (v = this.resolveDepth(v), !v)
          throw new RangeError("There is no position before the top-level node");
        return v == this.depth + 1 ? this.pos : this.path[v * 3 - 1];
      }
    }, {
      key: "after",
      value: function(v) {
        if (v = this.resolveDepth(v), !v)
          throw new RangeError("There is no position after the top-level node");
        return v == this.depth + 1 ? this.pos : this.path[v * 3 - 1] + this.path[v * 3].nodeSize;
      }
    }, {
      key: "textOffset",
      get: function() {
        return this.pos - this.path[this.path.length - 1];
      }
    }, {
      key: "nodeAfter",
      get: function() {
        var v = this.parent, b = this.index(this.depth);
        if (b == v.childCount)
          return null;
        var A = this.pos - this.path[this.path.length - 1], B = v.child(b);
        return A ? v.child(b).cut(A) : B;
      }
    }, {
      key: "nodeBefore",
      get: function() {
        var v = this.index(this.depth), b = this.pos - this.path[this.path.length - 1];
        return b ? this.parent.child(v).cut(0, b) : v == 0 ? null : this.parent.child(v - 1);
      }
    }, {
      key: "posAtIndex",
      value: function(v, b) {
        b = this.resolveDepth(b);
        for (var A = this.path[b * 3], B = b == 0 ? 0 : this.path[b * 3 - 1] + 1, z = 0; z < v; z++)
          B += A.child(z).nodeSize;
        return B;
      }
    }, {
      key: "marks",
      value: function() {
        var v = this.parent, b = this.index();
        if (v.content.size == 0)
          return at.none;
        if (this.textOffset)
          return v.child(b).marks;
        var A = v.maybeChild(b - 1), B = v.maybeChild(b);
        if (!A) {
          var z = A;
          A = B, B = z;
        }
        for (var G = A.marks, fe = 0; fe < G.length; fe++)
          G[fe].type.spec.inclusive === !1 && (!B || !G[fe].isInSet(B.marks)) && (G = G[fe--].removeFromSet(G));
        return G;
      }
    }, {
      key: "marksAcross",
      value: function(v) {
        var b = this.parent.maybeChild(this.index());
        if (!b || !b.isInline)
          return null;
        for (var A = b.marks, B = v.parent.maybeChild(v.index()), z = 0; z < A.length; z++)
          A[z].type.spec.inclusive === !1 && (!B || !A[z].isInSet(B.marks)) && (A = A[z--].removeFromSet(A));
        return A;
      }
    }, {
      key: "sharedDepth",
      value: function(v) {
        for (var b = this.depth; b > 0; b--)
          if (this.start(b) <= v && this.end(b) >= v)
            return b;
        return 0;
      }
    }, {
      key: "blockRange",
      value: function() {
        var v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this, b = arguments.length > 1 ? arguments[1] : void 0;
        if (v.pos < this.pos)
          return v.blockRange(this);
        for (var A = this.depth - (this.parent.inlineContent || this.pos == v.pos ? 1 : 0); A >= 0; A--)
          if (v.pos <= this.end(A) && (!b || b(this.node(A))))
            return new ft(this, v, A);
        return null;
      }
    }, {
      key: "sameParent",
      value: function(v) {
        return this.pos - this.parentOffset == v.pos - v.parentOffset;
      }
    }, {
      key: "max",
      value: function(v) {
        return v.pos > this.pos ? v : this;
      }
    }, {
      key: "min",
      value: function(v) {
        return v.pos < this.pos ? v : this;
      }
    }, {
      key: "toString",
      value: function() {
        for (var v = "", b = 1; b <= this.depth; b++)
          v += (v ? "/" : "") + this.node(b).type.name + "_" + this.index(b - 1);
        return v + ":" + this.parentOffset;
      }
    }], [{
      key: "resolve",
      value: function(v, b) {
        if (!(b >= 0 && b <= v.content.size))
          throw new RangeError("Position " + b + " out of range");
        for (var A = [], B = 0, z = b, G = v; ; ) {
          var fe = G.content.findIndex(z), Ce = fe.index, Ie = fe.offset, Le = z - Ie;
          if (A.push(G, Ce, B + Ie), !Le || (G = G.child(Ce), G.isText))
            break;
          z = Le - 1, B += Ie + 1;
        }
        return new N(b, A, z);
      }
    }, {
      key: "resolveCached",
      value: function(v, b) {
        for (var A = 0; A < de.length; A++) {
          var B = de[A];
          if (B.pos == b && B.doc == v)
            return B;
        }
        var z = de[Te] = N.resolve(v, b);
        return Te = (Te + 1) % Pe, z;
      }
    }]), N;
  }(), de = [], Te = 0, Pe = 12, ft = function() {
    function N(S, v, b) {
      X(this, N), this.$from = S, this.$to = v, this.depth = b;
    }
    return ee(N, [{
      key: "start",
      get: function() {
        return this.$from.before(this.depth + 1);
      }
    }, {
      key: "end",
      get: function() {
        return this.$to.after(this.depth + 1);
      }
    }, {
      key: "parent",
      get: function() {
        return this.$from.node(this.depth);
      }
    }, {
      key: "startIndex",
      get: function() {
        return this.$from.index(this.depth);
      }
    }, {
      key: "endIndex",
      get: function() {
        return this.$to.indexAfter(this.depth);
      }
    }]), N;
  }(), ht = /* @__PURE__ */ Object.create(null), wt = function() {
    function N(S, v, b) {
      var A = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : at.none;
      X(this, N), this.type = S, this.attrs = v, this.marks = A, this.content = b || ze.empty;
    }
    return ee(N, [{
      key: "nodeSize",
      get: function() {
        return this.isLeaf ? 1 : 2 + this.content.size;
      }
    }, {
      key: "childCount",
      get: function() {
        return this.content.childCount;
      }
    }, {
      key: "child",
      value: function(v) {
        return this.content.child(v);
      }
    }, {
      key: "maybeChild",
      value: function(v) {
        return this.content.maybeChild(v);
      }
    }, {
      key: "forEach",
      value: function(v) {
        this.content.forEach(v);
      }
    }, {
      key: "nodesBetween",
      value: function(v, b, A) {
        var B = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        this.content.nodesBetween(v, b, A, B, this);
      }
    }, {
      key: "descendants",
      value: function(v) {
        this.nodesBetween(0, this.content.size, v);
      }
    }, {
      key: "textContent",
      get: function() {
        return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
      }
    }, {
      key: "textBetween",
      value: function(v, b, A, B) {
        return this.content.textBetween(v, b, A, B);
      }
    }, {
      key: "firstChild",
      get: function() {
        return this.content.firstChild;
      }
    }, {
      key: "lastChild",
      get: function() {
        return this.content.lastChild;
      }
    }, {
      key: "eq",
      value: function(v) {
        return this == v || this.sameMarkup(v) && this.content.eq(v.content);
      }
    }, {
      key: "sameMarkup",
      value: function(v) {
        return this.hasMarkup(v.type, v.attrs, v.marks);
      }
    }, {
      key: "hasMarkup",
      value: function(v, b, A) {
        return this.type == v && rt(this.attrs, b || v.defaultAttrs || ht) && at.sameSet(this.marks, A || at.none);
      }
    }, {
      key: "copy",
      value: function() {
        var v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        return v == this.content ? this : new N(this.type, this.attrs, v, this.marks);
      }
    }, {
      key: "mark",
      value: function(v) {
        return v == this.marks ? this : new N(this.type, this.attrs, this.content, v);
      }
    }, {
      key: "cut",
      value: function(v) {
        var b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.content.size;
        return v == 0 && b == this.content.size ? this : this.copy(this.content.cut(v, b));
      }
    }, {
      key: "slice",
      value: function(v) {
        var b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.content.size, A = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
        if (v == b)
          return pt.empty;
        var B = this.resolve(v), z = this.resolve(b), G = A ? 0 : B.sharedDepth(b), fe = B.start(G), Ce = B.node(G), Ie = Ce.content.cut(B.pos - fe, z.pos - fe);
        return new pt(Ie, B.depth - G, z.depth - G);
      }
    }, {
      key: "replace",
      value: function(v, b, A) {
        return Je(this.resolve(v), this.resolve(b), A);
      }
    }, {
      key: "nodeAt",
      value: function(v) {
        for (var b = this; ; ) {
          var A = b.content.findIndex(v), B = A.index, z = A.offset;
          if (b = b.maybeChild(B), !b)
            return null;
          if (z == v || b.isText)
            return b;
          v -= z + 1;
        }
      }
    }, {
      key: "childAfter",
      value: function(v) {
        var b = this.content.findIndex(v), A = b.index, B = b.offset;
        return {
          node: this.content.maybeChild(A),
          index: A,
          offset: B
        };
      }
    }, {
      key: "childBefore",
      value: function(v) {
        if (v == 0)
          return {
            node: null,
            index: 0,
            offset: 0
          };
        var b = this.content.findIndex(v), A = b.index, B = b.offset;
        if (B < v)
          return {
            node: this.content.child(A),
            index: A,
            offset: B
          };
        var z = this.content.child(A - 1);
        return {
          node: z,
          index: A - 1,
          offset: B - z.nodeSize
        };
      }
    }, {
      key: "resolve",
      value: function(v) {
        return Z.resolveCached(this, v);
      }
    }, {
      key: "resolveNoCache",
      value: function(v) {
        return Z.resolve(this, v);
      }
    }, {
      key: "rangeHasMark",
      value: function(v, b, A) {
        var B = !1;
        return b > v && this.nodesBetween(v, b, function(z) {
          return A.isInSet(z.marks) && (B = !0), !B;
        }), B;
      }
    }, {
      key: "isBlock",
      get: function() {
        return this.type.isBlock;
      }
    }, {
      key: "isTextblock",
      get: function() {
        return this.type.isTextblock;
      }
    }, {
      key: "inlineContent",
      get: function() {
        return this.type.inlineContent;
      }
    }, {
      key: "isInline",
      get: function() {
        return this.type.isInline;
      }
    }, {
      key: "isText",
      get: function() {
        return this.type.isText;
      }
    }, {
      key: "isLeaf",
      get: function() {
        return this.type.isLeaf;
      }
    }, {
      key: "isAtom",
      get: function() {
        return this.type.isAtom;
      }
    }, {
      key: "toString",
      value: function() {
        if (this.type.spec.toDebugString)
          return this.type.spec.toDebugString(this);
        var v = this.type.name;
        return this.content.size && (v += "(" + this.content.toStringInner() + ")"), Ut(this.marks, v);
      }
    }, {
      key: "contentMatchAt",
      value: function(v) {
        var b = this.type.contentMatch.matchFragment(this.content, 0, v);
        if (!b)
          throw new Error("Called contentMatchAt on a node with invalid content");
        return b;
      }
    }, {
      key: "canReplace",
      value: function(v, b) {
        var A = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ze.empty, B = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, z = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : A.childCount, G = this.contentMatchAt(v).matchFragment(A, B, z), fe = G && G.matchFragment(this.content, b);
        if (!fe || !fe.validEnd)
          return !1;
        for (var Ce = B; Ce < z; Ce++)
          if (!this.type.allowsMarks(A.child(Ce).marks))
            return !1;
        return !0;
      }
    }, {
      key: "canReplaceWith",
      value: function(v, b, A, B) {
        if (B && !this.type.allowsMarks(B))
          return !1;
        var z = this.contentMatchAt(v).matchType(A), G = z && z.matchFragment(this.content, b);
        return G ? G.validEnd : !1;
      }
    }, {
      key: "canAppend",
      value: function(v) {
        return v.content.size ? this.canReplace(this.childCount, this.childCount, v.content) : this.type.compatibleContent(v.type);
      }
    }, {
      key: "check",
      value: function() {
        this.type.checkContent(this.content);
        for (var v = at.none, b = 0; b < this.marks.length; b++)
          v = this.marks[b].addToSet(v);
        if (!at.sameSet(v, this.marks))
          throw new RangeError("Invalid collection of marks for node ".concat(this.type.name, ": ").concat(this.marks.map(function(A) {
            return A.type.name;
          })));
        this.content.forEach(function(A) {
          return A.check();
        });
      }
    }, {
      key: "toJSON",
      value: function() {
        var v = {
          type: this.type.name
        };
        for (var b in this.attrs) {
          v.attrs = this.attrs;
          break;
        }
        return this.content.size && (v.content = this.content.toJSON()), this.marks.length && (v.marks = this.marks.map(function(A) {
          return A.toJSON();
        })), v;
      }
    }], [{
      key: "fromJSON",
      value: function(v, b) {
        if (!b)
          throw new RangeError("Invalid input for Node.fromJSON");
        var A = null;
        if (b.marks) {
          if (!Array.isArray(b.marks))
            throw new RangeError("Invalid mark data for Node.fromJSON");
          A = b.marks.map(v.markFromJSON);
        }
        if (b.type == "text") {
          if (typeof b.text != "string")
            throw new RangeError("Invalid text node in JSON");
          return v.text(b.text, A);
        }
        var B = ze.fromJSON(v, b.content);
        return v.nodeType(b.type).create(b.attrs, B, A);
      }
    }]), N;
  }();
  wt.prototype.text = void 0;
  var Ot = function(N) {
    m(v, N);
    var S = y(v);
    function v(b, A, B, z) {
      var G;
      if (X(this, v), G = S.call(this, b, A, null, z), !B)
        throw new RangeError("Empty text nodes are not allowed");
      return G.text = B, G;
    }
    return ee(v, [{
      key: "toString",
      value: function() {
        return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : Ut(this.marks, JSON.stringify(this.text));
      }
    }, {
      key: "textContent",
      get: function() {
        return this.text;
      }
    }, {
      key: "textBetween",
      value: function(A, B) {
        return this.text.slice(A, B);
      }
    }, {
      key: "nodeSize",
      get: function() {
        return this.text.length;
      }
    }, {
      key: "mark",
      value: function(A) {
        return A == this.marks ? this : new v(this.type, this.attrs, this.text, A);
      }
    }, {
      key: "withText",
      value: function(A) {
        return A == this.text ? this : new v(this.type, this.attrs, A, this.marks);
      }
    }, {
      key: "cut",
      value: function() {
        var A = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, B = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.text.length;
        return A == 0 && B == this.text.length ? this : this.withText(this.text.slice(A, B));
      }
    }, {
      key: "eq",
      value: function(A) {
        return this.sameMarkup(A) && this.text == A.text;
      }
    }, {
      key: "toJSON",
      value: function() {
        var A = o(K(v.prototype), "toJSON", this).call(this);
        return A.text = this.text, A;
      }
    }]), v;
  }(wt);
  function Ut(N, S) {
    for (var v = N.length - 1; v >= 0; v--)
      S = N[v].type.name + "(" + S + ")";
    return S;
  }
  var Kt = function() {
    function N(S) {
      X(this, N), this.validEnd = S, this.next = [], this.wrapCache = [];
    }
    return ee(N, [{
      key: "matchType",
      value: function(v) {
        for (var b = 0; b < this.next.length; b++)
          if (this.next[b].type == v)
            return this.next[b].next;
        return null;
      }
    }, {
      key: "matchFragment",
      value: function(v) {
        for (var b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, A = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : v.childCount, B = this, z = b; B && z < A; z++)
          B = B.matchType(v.child(z).type);
        return B;
      }
    }, {
      key: "inlineContent",
      get: function() {
        return this.next.length != 0 && this.next[0].type.isInline;
      }
    }, {
      key: "defaultType",
      get: function() {
        for (var v = 0; v < this.next.length; v++) {
          var b = this.next[v].type;
          if (!(b.isText || b.hasRequiredAttrs()))
            return b;
        }
        return null;
      }
    }, {
      key: "compatible",
      value: function(v) {
        for (var b = 0; b < this.next.length; b++)
          for (var A = 0; A < v.next.length; A++)
            if (this.next[b].type == v.next[A].type)
              return !0;
        return !1;
      }
    }, {
      key: "fillBefore",
      value: function(v) {
        var b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, A = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, B = [this];
        function z(G, fe) {
          var Ce = G.matchFragment(v, A);
          if (Ce && (!b || Ce.validEnd))
            return ze.from(fe.map(function(nr) {
              return nr.createAndFill();
            }));
          for (var Ie = 0; Ie < G.next.length; Ie++) {
            var Le = G.next[Ie], Fe = Le.type, it = Le.next;
            if (!(Fe.isText || Fe.hasRequiredAttrs()) && B.indexOf(it) == -1) {
              B.push(it);
              var Ht = z(it, fe.concat(Fe));
              if (Ht)
                return Ht;
            }
          }
          return null;
        }
        return z(this, []);
      }
    }, {
      key: "findWrapping",
      value: function(v) {
        for (var b = 0; b < this.wrapCache.length; b += 2)
          if (this.wrapCache[b] == v)
            return this.wrapCache[b + 1];
        var A = this.computeWrapping(v);
        return this.wrapCache.push(v, A), A;
      }
    }, {
      key: "computeWrapping",
      value: function(v) {
        for (var b = /* @__PURE__ */ Object.create(null), A = [{
          match: this,
          type: null,
          via: null
        }]; A.length; ) {
          var B = A.shift(), z = B.match;
          if (z.matchType(v)) {
            for (var G = [], fe = B; fe.type; fe = fe.via)
              G.push(fe.type);
            return G.reverse();
          }
          for (var Ce = 0; Ce < z.next.length; Ce++) {
            var Ie = z.next[Ce], Le = Ie.type, Fe = Ie.next;
            !Le.isLeaf && !Le.hasRequiredAttrs() && !(Le.name in b) && (!B.type || Fe.validEnd) && (A.push({
              match: Le.contentMatch,
              type: Le,
              via: B
            }), b[Le.name] = !0);
          }
        }
        return null;
      }
    }, {
      key: "edgeCount",
      get: function() {
        return this.next.length;
      }
    }, {
      key: "edge",
      value: function(v) {
        if (v >= this.next.length)
          throw new RangeError("There's no ".concat(v, "th edge in this content match"));
        return this.next[v];
      }
    }, {
      key: "toString",
      value: function() {
        var v = [];
        function b(A) {
          v.push(A);
          for (var B = 0; B < A.next.length; B++)
            v.indexOf(A.next[B].next) == -1 && b(A.next[B].next);
        }
        return b(this), v.map(function(A, B) {
          for (var z = B + (A.validEnd ? "*" : " ") + " ", G = 0; G < A.next.length; G++)
            z += (G ? ", " : "") + A.next[G].type.name + "->" + v.indexOf(A.next[G].next);
          return z;
        }).join(`
`);
      }
    }], [{
      key: "parse",
      value: function(v, b) {
        var A = new qr(v, b);
        if (A.next == null)
          return N.empty;
        var B = Jt(A);
        A.next && A.err("Unexpected trailing text");
        var z = Ct(_e(B));
        return rr(z, A), z;
      }
    }]), N;
  }();
  Kt.empty = new Kt(!0);
  var qr = function() {
    function N(S, v) {
      X(this, N), this.string = S, this.nodeTypes = v, this.inline = null, this.pos = 0, this.tokens = S.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
    }
    return ee(N, [{
      key: "next",
      get: function() {
        return this.tokens[this.pos];
      }
    }, {
      key: "eat",
      value: function(v) {
        return this.next == v && (this.pos++ || !0);
      }
    }, {
      key: "err",
      value: function(v) {
        throw new SyntaxError(v + " (in content expression '" + this.string + "')");
      }
    }]), N;
  }();
  function Jt(N) {
    var S = [];
    do
      S.push(_t(N));
    while (N.eat("|"));
    return S.length == 1 ? S[0] : {
      type: "choice",
      exprs: S
    };
  }
  function _t(N) {
    var S = [];
    do
      S.push(pr(N));
    while (N.next && N.next != ")" && N.next != "|");
    return S.length == 1 ? S[0] : {
      type: "seq",
      exprs: S
    };
  }
  function pr(N) {
    for (var S = He(N); ; )
      if (N.eat("+"))
        S = {
          type: "plus",
          expr: S
        };
      else if (N.eat("*"))
        S = {
          type: "star",
          expr: S
        };
      else if (N.eat("?"))
        S = {
          type: "opt",
          expr: S
        };
      else if (N.eat("{"))
        S = Fr(N, S);
      else
        break;
    return S;
  }
  function hr(N) {
    /\D/.test(N.next) && N.err("Expected number, got '" + N.next + "'");
    var S = Number(N.next);
    return N.pos++, S;
  }
  function Fr(N, S) {
    var v = hr(N), b = v;
    return N.eat(",") && (N.next != "}" ? b = hr(N) : b = -1), N.eat("}") || N.err("Unclosed braced range"), {
      type: "range",
      min: v,
      max: b,
      expr: S
    };
  }
  function _r(N, S) {
    var v = N.nodeTypes, b = v[S];
    if (b)
      return [b];
    var A = [];
    for (var B in v) {
      var z = v[B];
      z.groups.indexOf(S) > -1 && A.push(z);
    }
    return A.length == 0 && N.err("No node type or group '" + S + "' found"), A;
  }
  function He(N) {
    if (N.eat("(")) {
      var S = Jt(N);
      return N.eat(")") || N.err("Missing closing paren"), S;
    } else if (/\W/.test(N.next))
      N.err("Unexpected token '" + N.next + "'");
    else {
      var v = _r(N, N.next).map(function(b) {
        return N.inline == null ? N.inline = b.isInline : N.inline != b.isInline && N.err("Mixing inline and block content"), {
          type: "name",
          value: b
        };
      });
      return N.pos++, v.length == 1 ? v[0] : {
        type: "choice",
        exprs: v
      };
    }
  }
  function _e(N) {
    var S = [[]];
    return A(B(N, 0), v()), S;
    function v() {
      return S.push([]) - 1;
    }
    function b(z, G, fe) {
      var Ce = {
        term: fe,
        to: G
      };
      return S[z].push(Ce), Ce;
    }
    function A(z, G) {
      z.forEach(function(fe) {
        return fe.to = G;
      });
    }
    function B(z, G) {
      if (z.type == "choice")
        return z.exprs.reduce(function(Ur, zr) {
          return Ur.concat(B(zr, G));
        }, []);
      if (z.type == "seq")
        for (var fe = 0; ; fe++) {
          var Ce = B(z.exprs[fe], G);
          if (fe == z.exprs.length - 1)
            return Ce;
          A(Ce, G = v());
        }
      else if (z.type == "star") {
        var Ie = v();
        return b(G, Ie), A(B(z.expr, Ie), Ie), [b(Ie)];
      } else if (z.type == "plus") {
        var Le = v();
        return A(B(z.expr, G), Le), A(B(z.expr, Le), Le), [b(Le)];
      } else {
        if (z.type == "opt")
          return [b(G)].concat(B(z.expr, G));
        if (z.type == "range") {
          for (var Fe = G, it = 0; it < z.min; it++) {
            var Ht = v();
            A(B(z.expr, Fe), Ht), Fe = Ht;
          }
          if (z.max == -1)
            A(B(z.expr, Fe), Fe);
          else
            for (var nr = z.min; nr < z.max; nr++) {
              var Mr = v();
              b(Fe, Mr), A(B(z.expr, Fe), Mr), Fe = Mr;
            }
          return [b(Fe)];
        } else {
          if (z.type == "name")
            return [b(G, void 0, z.value)];
          throw new Error("Unknown expr type");
        }
      }
    }
  }
  function Xe(N, S) {
    return S - N;
  }
  function st(N, S) {
    var v = [];
    return b(S), v.sort(Xe);
    function b(A) {
      var B = N[A];
      if (B.length == 1 && !B[0].term)
        return b(B[0].to);
      v.push(A);
      for (var z = 0; z < B.length; z++) {
        var G = B[z], fe = G.term, Ce = G.to;
        !fe && v.indexOf(Ce) == -1 && b(Ce);
      }
    }
  }
  function Ct(N) {
    var S = /* @__PURE__ */ Object.create(null);
    return v(st(N, 0));
    function v(b) {
      var A = [];
      b.forEach(function(fe) {
        N[fe].forEach(function(Ce) {
          var Ie = Ce.term, Le = Ce.to;
          if (Ie) {
            for (var Fe, it = 0; it < A.length; it++)
              A[it][0] == Ie && (Fe = A[it][1]);
            st(N, Le).forEach(function(Ht) {
              Fe || A.push([Ie, Fe = []]), Fe.indexOf(Ht) == -1 && Fe.push(Ht);
            });
          }
        });
      });
      for (var B = S[b.join(",")] = new Kt(b.indexOf(N.length - 1) > -1), z = 0; z < A.length; z++) {
        var G = A[z][1].sort(Xe);
        B.next.push({
          type: A[z][0],
          next: S[G.join(",")] || v(G)
        });
      }
      return B;
    }
  }
  function rr(N, S) {
    for (var v = 0, b = [N]; v < b.length; v++) {
      for (var A = b[v], B = !A.validEnd, z = [], G = 0; G < A.next.length; G++) {
        var fe = A.next[G], Ce = fe.type, Ie = fe.next;
        z.push(Ce.name), B && !(Ce.isText || Ce.hasRequiredAttrs()) && (B = !1), b.indexOf(Ie) == -1 && b.push(Ie);
      }
      B && S.err("Only non-generatable nodes (" + z.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
    }
  }
  function lr(N) {
    var S = /* @__PURE__ */ Object.create(null);
    for (var v in N) {
      var b = N[v];
      if (!b.hasDefault)
        return null;
      S[v] = b.default;
    }
    return S;
  }
  function Yt(N, S) {
    var v = /* @__PURE__ */ Object.create(null);
    for (var b in N) {
      var A = S && S[b];
      if (A === void 0) {
        var B = N[b];
        if (B.hasDefault)
          A = B.default;
        else
          throw new RangeError("No value supplied for attribute " + b);
      }
      v[b] = A;
    }
    return v;
  }
  function Zt(N) {
    var S = /* @__PURE__ */ Object.create(null);
    if (N)
      for (var v in N)
        S[v] = new Cr(N[v]);
    return S;
  }
  var Rr = function() {
    function N(S, v, b) {
      X(this, N), this.name = S, this.schema = v, this.spec = b, this.markSet = null, this.groups = b.group ? b.group.split(" ") : [], this.attrs = Zt(b.attrs), this.defaultAttrs = lr(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(b.inline || S == "text"), this.isText = S == "text";
    }
    return ee(N, [{
      key: "isInline",
      get: function() {
        return !this.isBlock;
      }
    }, {
      key: "isTextblock",
      get: function() {
        return this.isBlock && this.inlineContent;
      }
    }, {
      key: "isLeaf",
      get: function() {
        return this.contentMatch == Kt.empty;
      }
    }, {
      key: "isAtom",
      get: function() {
        return this.isLeaf || !!this.spec.atom;
      }
    }, {
      key: "whitespace",
      get: function() {
        return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
      }
    }, {
      key: "hasRequiredAttrs",
      value: function() {
        for (var v in this.attrs)
          if (this.attrs[v].isRequired)
            return !0;
        return !1;
      }
    }, {
      key: "compatibleContent",
      value: function(v) {
        return this == v || this.contentMatch.compatible(v.contentMatch);
      }
    }, {
      key: "computeAttrs",
      value: function(v) {
        return !v && this.defaultAttrs ? this.defaultAttrs : Yt(this.attrs, v);
      }
    }, {
      key: "create",
      value: function() {
        var v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, b = arguments.length > 1 ? arguments[1] : void 0, A = arguments.length > 2 ? arguments[2] : void 0;
        if (this.isText)
          throw new Error("NodeType.create can't construct text nodes");
        return new wt(this, this.computeAttrs(v), ze.from(b), at.setFrom(A));
      }
    }, {
      key: "createChecked",
      value: function() {
        var v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, b = arguments.length > 1 ? arguments[1] : void 0, A = arguments.length > 2 ? arguments[2] : void 0;
        return b = ze.from(b), this.checkContent(b), new wt(this, this.computeAttrs(v), b, at.setFrom(A));
      }
    }, {
      key: "createAndFill",
      value: function() {
        var v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, b = arguments.length > 1 ? arguments[1] : void 0, A = arguments.length > 2 ? arguments[2] : void 0;
        if (v = this.computeAttrs(v), b = ze.from(b), b.size) {
          var B = this.contentMatch.fillBefore(b);
          if (!B)
            return null;
          b = B.append(b);
        }
        var z = this.contentMatch.matchFragment(b), G = z && z.fillBefore(ze.empty, !0);
        return G ? new wt(this, v, b.append(G), at.setFrom(A)) : null;
      }
    }, {
      key: "validContent",
      value: function(v) {
        var b = this.contentMatch.matchFragment(v);
        if (!b || !b.validEnd)
          return !1;
        for (var A = 0; A < v.childCount; A++)
          if (!this.allowsMarks(v.child(A).marks))
            return !1;
        return !0;
      }
    }, {
      key: "checkContent",
      value: function(v) {
        if (!this.validContent(v))
          throw new RangeError("Invalid content for node ".concat(this.name, ": ").concat(v.toString().slice(0, 50)));
      }
    }, {
      key: "allowsMarkType",
      value: function(v) {
        return this.markSet == null || this.markSet.indexOf(v) > -1;
      }
    }, {
      key: "allowsMarks",
      value: function(v) {
        if (this.markSet == null)
          return !0;
        for (var b = 0; b < v.length; b++)
          if (!this.allowsMarkType(v[b].type))
            return !1;
        return !0;
      }
    }, {
      key: "allowedMarks",
      value: function(v) {
        if (this.markSet == null)
          return v;
        for (var b, A = 0; A < v.length; A++)
          this.allowsMarkType(v[A].type) ? b && b.push(v[A]) : b || (b = v.slice(0, A));
        return b ? b.length ? b : at.none : v;
      }
    }], [{
      key: "compile",
      value: function(v, b) {
        var A = /* @__PURE__ */ Object.create(null);
        v.forEach(function(G, fe) {
          return A[G] = new N(G, b, fe);
        });
        var B = b.spec.topNode || "doc";
        if (!A[B])
          throw new RangeError("Schema is missing its top node type ('" + B + "')");
        if (!A.text)
          throw new RangeError("Every schema needs a 'text' type");
        for (var z in A.text.attrs)
          throw new RangeError("The text node type should not have attributes");
        return A;
      }
    }]), N;
  }(), Cr = function() {
    function N(S) {
      X(this, N), this.hasDefault = Object.prototype.hasOwnProperty.call(S, "default"), this.default = S.default;
    }
    return ee(N, [{
      key: "isRequired",
      get: function() {
        return !this.hasDefault;
      }
    }]), N;
  }(), Qt = function() {
    function N(S, v, b, A) {
      X(this, N), this.name = S, this.rank = v, this.schema = b, this.spec = A, this.attrs = Zt(A.attrs), this.excluded = null;
      var B = lr(this.attrs);
      this.instance = B ? new at(this, B) : null;
    }
    return ee(N, [{
      key: "create",
      value: function() {
        var v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        return !v && this.instance ? this.instance : new at(this, Yt(this.attrs, v));
      }
    }, {
      key: "removeFromSet",
      value: function(v) {
        for (var b = 0; b < v.length; b++)
          v[b].type == this && (v = v.slice(0, b).concat(v.slice(b + 1)), b--);
        return v;
      }
    }, {
      key: "isInSet",
      value: function(v) {
        for (var b = 0; b < v.length; b++)
          if (v[b].type == this)
            return v[b];
      }
    }, {
      key: "excludes",
      value: function(v) {
        return this.excluded.indexOf(v) > -1;
      }
    }], [{
      key: "compile",
      value: function(v, b) {
        var A = /* @__PURE__ */ Object.create(null), B = 0;
        return v.forEach(function(z, G) {
          return A[z] = new N(z, B++, b, G);
        }), A;
      }
    }]), N;
  }(), Hr = function() {
    function N(S) {
      X(this, N), this.cached = /* @__PURE__ */ Object.create(null);
      var v = this.spec = {};
      for (var b in S)
        v[b] = S[b];
      v.nodes = Se.default.from(S.nodes), v.marks = Se.default.from(S.marks || {}), this.nodes = Rr.compile(this.spec.nodes, this), this.marks = Qt.compile(this.spec.marks, this);
      var A = /* @__PURE__ */ Object.create(null);
      for (var B in this.nodes) {
        if (B in this.marks)
          throw new RangeError(B + " can not be both a node and a mark");
        var z = this.nodes[B], G = z.spec.content || "", fe = z.spec.marks;
        z.contentMatch = A[G] || (A[G] = Kt.parse(G, this.nodes)), z.inlineContent = z.contentMatch.inlineContent, z.markSet = fe == "_" ? null : fe ? Tr(this, fe.split(" ")) : fe == "" || !z.inlineContent ? [] : null;
      }
      for (var Ce in this.marks) {
        var Ie = this.marks[Ce], Le = Ie.spec.excludes;
        Ie.excluded = Le == null ? [Ie] : Le == "" ? [] : Tr(this, Le.split(" "));
      }
      this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
    }
    return ee(N, [{
      key: "node",
      value: function(v) {
        var b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, A = arguments.length > 2 ? arguments[2] : void 0, B = arguments.length > 3 ? arguments[3] : void 0;
        if (typeof v == "string")
          v = this.nodeType(v);
        else if (v instanceof Rr) {
          if (v.schema != this)
            throw new RangeError("Node type from different schema used (" + v.name + ")");
        } else
          throw new RangeError("Invalid node type: " + v);
        return v.createChecked(b, A, B);
      }
    }, {
      key: "text",
      value: function(v, b) {
        var A = this.nodes.text;
        return new Ot(A, A.defaultAttrs, v, at.setFrom(b));
      }
    }, {
      key: "mark",
      value: function(v, b) {
        return typeof v == "string" && (v = this.marks[v]), v.create(b);
      }
    }, {
      key: "nodeFromJSON",
      value: function(v) {
        return wt.fromJSON(this, v);
      }
    }, {
      key: "markFromJSON",
      value: function(v) {
        return at.fromJSON(this, v);
      }
    }, {
      key: "nodeType",
      value: function(v) {
        var b = this.nodes[v];
        if (!b)
          throw new RangeError("Unknown node type: " + v);
        return b;
      }
    }]), N;
  }();
  function Tr(N, S) {
    for (var v = [], b = 0; b < S.length; b++) {
      var A = S[b], B = N.marks[A], z = B;
      if (B)
        v.push(B);
      else
        for (var G in N.marks) {
          var fe = N.marks[G];
          (A == "_" || fe.spec.group && fe.spec.group.split(" ").indexOf(A) > -1) && v.push(z = fe);
        }
      if (!z)
        throw new SyntaxError("Unknown mark type: '" + S[b] + "'");
    }
    return v;
  }
  var nn = function() {
    function N(S, v) {
      var b = this;
      X(this, N), this.schema = S, this.rules = v, this.tags = [], this.styles = [], v.forEach(function(A) {
        A.tag ? b.tags.push(A) : A.style && b.styles.push(A);
      }), this.normalizeLists = !this.tags.some(function(A) {
        if (!/^(ul|ol)\b/.test(A.tag) || !A.node)
          return !1;
        var B = S.nodes[A.node];
        return B.contentMatch.matchType(B);
      });
    }
    return ee(N, [{
      key: "parse",
      value: function(v) {
        var b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, A = new me(this, b, !1);
        return A.addAll(v, b.from, b.to), A.finish();
      }
    }, {
      key: "parseSlice",
      value: function(v) {
        var b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, A = new me(this, b, !0);
        return A.addAll(v, b.from, b.to), pt.maxOpen(A.finish());
      }
    }, {
      key: "matchTag",
      value: function(v, b, A) {
        for (var B = A ? this.tags.indexOf(A) + 1 : 0; B < this.tags.length; B++) {
          var z = this.tags[B];
          if (Oe(v, z.tag) && (z.namespace === void 0 || v.namespaceURI == z.namespace) && (!z.context || b.matchesContext(z.context))) {
            if (z.getAttrs) {
              var G = z.getAttrs(v);
              if (G === !1)
                continue;
              z.attrs = G || void 0;
            }
            return z;
          }
        }
      }
    }, {
      key: "matchStyle",
      value: function(v, b, A, B) {
        for (var z = B ? this.styles.indexOf(B) + 1 : 0; z < this.styles.length; z++) {
          var G = this.styles[z], fe = G.style;
          if (!(fe.indexOf(v) != 0 || G.context && !A.matchesContext(G.context) || fe.length > v.length && (fe.charCodeAt(v.length) != 61 || fe.slice(v.length + 1) != b))) {
            if (G.getAttrs) {
              var Ce = G.getAttrs(b);
              if (Ce === !1)
                continue;
              G.attrs = Ce || void 0;
            }
            return G;
          }
        }
      }
    }], [{
      key: "schemaRules",
      value: function(v) {
        var b = [];
        function A(Ce) {
          for (var Ie = Ce.priority == null ? 50 : Ce.priority, Le = 0; Le < b.length; Le++) {
            var Fe = b[Le], it = Fe.priority == null ? 50 : Fe.priority;
            if (it < Ie)
              break;
          }
          b.splice(Le, 0, Ce);
        }
        var B = function(Ie) {
          var Le = v.marks[Ie].spec.parseDOM;
          Le && Le.forEach(function(Fe) {
            A(Fe = We(Fe)), Fe.mark || Fe.ignore || Fe.clearMark || (Fe.mark = Ie);
          });
        };
        for (var z in v.marks)
          B(z);
        var G = function(Ie) {
          var Le = v.nodes[Ie].spec.parseDOM;
          Le && Le.forEach(function(Fe) {
            A(Fe = We(Fe)), Fe.node || Fe.ignore || Fe.mark || (Fe.node = Ie);
          });
        };
        for (var fe in v.nodes)
          G(fe);
        return b;
      }
    }, {
      key: "fromSchema",
      value: function(v) {
        return v.cached.domParser || (v.cached.domParser = new N(v, N.schemaRules(v)));
      }
    }]), N;
  }(), W = {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    canvas: !0,
    dd: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    figcaption: !0,
    figure: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    li: !0,
    noscript: !0,
    ol: !0,
    output: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    tfoot: !0,
    ul: !0
  }, V = {
    head: !0,
    noscript: !0,
    object: !0,
    script: !0,
    style: !0,
    title: !0
  }, R = {
    ol: !0,
    ul: !0
  }, D = 1, I = 2, H = 4;
  function J(N, S, v) {
    return S != null ? (S ? D : 0) | (S === "full" ? I : 0) : N && N.whitespace == "pre" ? D | I : v & ~H;
  }
  var ve = function() {
    function N(S, v, b, A, B, z, G) {
      X(this, N), this.type = S, this.attrs = v, this.marks = b, this.pendingMarks = A, this.solid = B, this.options = G, this.content = [], this.activeMarks = at.none, this.stashMarks = [], this.match = z || (G & H ? null : S.contentMatch);
    }
    return ee(N, [{
      key: "findWrapping",
      value: function(v) {
        if (!this.match) {
          if (!this.type)
            return [];
          var b = this.type.contentMatch.fillBefore(ze.from(v));
          if (b)
            this.match = this.type.contentMatch.matchFragment(b);
          else {
            var A = this.type.contentMatch, B;
            return (B = A.findWrapping(v.type)) ? (this.match = A, B) : null;
          }
        }
        return this.match.findWrapping(v.type);
      }
    }, {
      key: "finish",
      value: function(v) {
        if (!(this.options & D)) {
          var b = this.content[this.content.length - 1], A;
          if (b && b.isText && (A = /[ \t\r\n\u000c]+$/.exec(b.text))) {
            var B = b;
            b.text.length == A[0].length ? this.content.pop() : this.content[this.content.length - 1] = B.withText(B.text.slice(0, B.text.length - A[0].length));
          }
        }
        var z = ze.from(this.content);
        return !v && this.match && (z = z.append(this.match.fillBefore(ze.empty, !0))), this.type ? this.type.create(this.attrs, z, this.marks) : z;
      }
    }, {
      key: "popFromStashMark",
      value: function(v) {
        for (var b = this.stashMarks.length - 1; b >= 0; b--)
          if (v.eq(this.stashMarks[b]))
            return this.stashMarks.splice(b, 1)[0];
      }
    }, {
      key: "applyPending",
      value: function(v) {
        for (var b = 0, A = this.pendingMarks; b < A.length; b++) {
          var B = A[b];
          (this.type ? this.type.allowsMarkType(B.type) : ut(B.type, v)) && !B.isInSet(this.activeMarks) && (this.activeMarks = B.addToSet(this.activeMarks), this.pendingMarks = B.removeFromSet(this.pendingMarks));
        }
      }
    }, {
      key: "inlineContext",
      value: function(v) {
        return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : v.parentNode && !W.hasOwnProperty(v.parentNode.nodeName.toLowerCase());
      }
    }]), N;
  }(), me = function() {
    function N(S, v, b) {
      X(this, N), this.parser = S, this.options = v, this.isOpen = b, this.open = 0;
      var A = v.topNode, B, z = J(null, v.preserveWhitespace, 0) | (b ? H : 0);
      A ? B = new ve(A.type, A.attrs, at.none, at.none, !0, v.topMatch || A.type.contentMatch, z) : b ? B = new ve(null, null, at.none, at.none, !0, null, z) : B = new ve(S.schema.topNodeType, null, at.none, at.none, !0, null, z), this.nodes = [B], this.find = v.findPositions, this.needsBlock = !1;
    }
    return ee(N, [{
      key: "top",
      get: function() {
        return this.nodes[this.open];
      }
    }, {
      key: "addDOM",
      value: function(v) {
        v.nodeType == 3 ? this.addTextNode(v) : v.nodeType == 1 && this.addElement(v);
      }
    }, {
      key: "withStyleRules",
      value: function(v, b) {
        var A = v.getAttribute("style");
        if (!A)
          return b();
        var B = this.readStyles(Ye(A));
        if (B) {
          for (var z = t(B, 2), G = z[0], fe = z[1], Ce = this.top, Ie = 0; Ie < fe.length; Ie++)
            this.removePendingMark(fe[Ie], Ce);
          for (var Le = 0; Le < G.length; Le++)
            this.addPendingMark(G[Le]);
          b();
          for (var Fe = 0; Fe < G.length; Fe++)
            this.removePendingMark(G[Fe], Ce);
          for (var it = 0; it < fe.length; it++)
            this.addPendingMark(fe[it]);
        }
      }
    }, {
      key: "addTextNode",
      value: function(v) {
        var b = v.nodeValue, A = this.top;
        if (A.options & I || A.inlineContext(v) || /[^ \t\r\n\u000c]/.test(b)) {
          if (A.options & D)
            A.options & I ? b = b.replace(/\r\n?/g, `
`) : b = b.replace(/\r?\n|\r/g, " ");
          else if (b = b.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(b) && this.open == this.nodes.length - 1) {
            var B = A.content[A.content.length - 1], z = v.previousSibling;
            (!B || z && z.nodeName == "BR" || B.isText && /[ \t\r\n\u000c]$/.test(B.text)) && (b = b.slice(1));
          }
          b && this.insertNode(this.parser.schema.text(b)), this.findInText(v);
        } else
          this.findInside(v);
      }
    }, {
      key: "addElement",
      value: function(v, b) {
        var A = this, B = v.nodeName.toLowerCase(), z;
        R.hasOwnProperty(B) && this.parser.normalizeLists && be(v);
        var G = this.options.ruleFromNode && this.options.ruleFromNode(v) || (z = this.parser.matchTag(v, this, b));
        if (G ? G.ignore : V.hasOwnProperty(B))
          this.findInside(v), this.ignoreFallback(v);
        else if (!G || G.skip || G.closeParent) {
          G && G.closeParent ? this.open = Math.max(0, this.open - 1) : G && G.skip.nodeType && (v = G.skip);
          var fe, Ce = this.top, Ie = this.needsBlock;
          if (W.hasOwnProperty(B))
            Ce.content.length && Ce.content[0].isInline && this.open && (this.open--, Ce = this.top), fe = !0, Ce.type || (this.needsBlock = !0);
          else if (!v.firstChild) {
            this.leafFallback(v);
            return;
          }
          G && G.skip ? this.addAll(v) : this.withStyleRules(v, function() {
            return A.addAll(v);
          }), fe && this.sync(Ce), this.needsBlock = Ie;
        } else
          this.withStyleRules(v, function() {
            A.addElementByRule(v, G, G.consuming === !1 ? z : void 0);
          });
      }
    }, {
      key: "leafFallback",
      value: function(v) {
        v.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(v.ownerDocument.createTextNode(`
`));
      }
    }, {
      key: "ignoreFallback",
      value: function(v) {
        v.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"));
      }
    }, {
      key: "readStyles",
      value: function(v) {
        for (var b = this, A = at.none, B = at.none, z = 0; z < v.length; z += 2)
          for (var G = function(Le) {
            var Fe = b.parser.matchStyle(v[z], v[z + 1], b, Le);
            if (!Fe)
              return fe = Le, "break";
            if (Fe.ignore)
              return fe = Le, {
                v: null
              };
            if (Fe.clearMark ? b.top.pendingMarks.concat(b.top.activeMarks).forEach(function(it) {
              Fe.clearMark(it) && (B = it.addToSet(B));
            }) : A = b.parser.schema.marks[Fe.mark].create(Fe.attrs).addToSet(A), Fe.consuming === !1)
              Le = Fe;
            else
              return fe = Le, "break";
            fe = Le;
          }, fe = void 0; ; ) {
            var Ce = G(fe);
            if (Ce === "break")
              break;
            if (oe(Ce) === "object")
              return Ce.v;
          }
        return [A, B];
      }
    }, {
      key: "addElementByRule",
      value: function(v, b, A) {
        var B = this, z, G, fe;
        if (b.node)
          G = this.parser.schema.nodes[b.node], G.isLeaf ? this.insertNode(G.create(b.attrs)) || this.leafFallback(v) : z = this.enter(G, b.attrs || null, b.preserveWhitespace);
        else {
          var Ce = this.parser.schema.marks[b.mark];
          fe = Ce.create(b.attrs), this.addPendingMark(fe);
        }
        var Ie = this.top;
        if (G && G.isLeaf)
          this.findInside(v);
        else if (A)
          this.addElement(v, A);
        else if (b.getContent)
          this.findInside(v), b.getContent(v, this.parser.schema).forEach(function(Fe) {
            return B.insertNode(Fe);
          });
        else {
          var Le = v;
          typeof b.contentElement == "string" ? Le = v.querySelector(b.contentElement) : typeof b.contentElement == "function" ? Le = b.contentElement(v) : b.contentElement && (Le = b.contentElement), this.findAround(v, Le, !0), this.addAll(Le);
        }
        z && this.sync(Ie) && this.open--, fe && this.removePendingMark(fe, Ie);
      }
    }, {
      key: "addAll",
      value: function(v, b, A) {
        for (var B = b || 0, z = b ? v.childNodes[b] : v.firstChild, G = A == null ? null : v.childNodes[A]; z != G; z = z.nextSibling, ++B)
          this.findAtPoint(v, B), this.addDOM(z);
        this.findAtPoint(v, B);
      }
    }, {
      key: "findPlace",
      value: function(v) {
        for (var b, A, B = this.open; B >= 0; B--) {
          var z = this.nodes[B], G = z.findWrapping(v);
          if (G && (!b || b.length > G.length) && (b = G, A = z, !G.length) || z.solid)
            break;
        }
        if (!b)
          return !1;
        this.sync(A);
        for (var fe = 0; fe < b.length; fe++)
          this.enterInner(b[fe], null, !1);
        return !0;
      }
    }, {
      key: "insertNode",
      value: function(v) {
        if (v.isInline && this.needsBlock && !this.top.type) {
          var b = this.textblockFromContext();
          b && this.enterInner(b);
        }
        if (this.findPlace(v)) {
          this.closeExtra();
          var A = this.top;
          A.applyPending(v.type), A.match && (A.match = A.match.matchType(v.type));
          for (var B = A.activeMarks, z = 0; z < v.marks.length; z++)
            (!A.type || A.type.allowsMarkType(v.marks[z].type)) && (B = v.marks[z].addToSet(B));
          return A.content.push(v.mark(B)), !0;
        }
        return !1;
      }
    }, {
      key: "enter",
      value: function(v, b, A) {
        var B = this.findPlace(v.create(b));
        return B && this.enterInner(v, b, !0, A), B;
      }
    }, {
      key: "enterInner",
      value: function(v) {
        var b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, A = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, B = arguments.length > 3 ? arguments[3] : void 0;
        this.closeExtra();
        var z = this.top;
        z.applyPending(v), z.match = z.match && z.match.matchType(v);
        var G = J(v, B, z.options);
        z.options & H && z.content.length == 0 && (G |= H), this.nodes.push(new ve(v, b, z.activeMarks, z.pendingMarks, A, null, G)), this.open++;
      }
    }, {
      key: "closeExtra",
      value: function() {
        var v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, b = this.nodes.length - 1;
        if (b > this.open) {
          for (; b > this.open; b--)
            this.nodes[b - 1].content.push(this.nodes[b].finish(v));
          this.nodes.length = this.open + 1;
        }
      }
    }, {
      key: "finish",
      value: function() {
        return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(this.isOpen || this.options.topOpen);
      }
    }, {
      key: "sync",
      value: function(v) {
        for (var b = this.open; b >= 0; b--)
          if (this.nodes[b] == v)
            return this.open = b, !0;
        return !1;
      }
    }, {
      key: "currentPos",
      get: function() {
        this.closeExtra();
        for (var v = 0, b = this.open; b >= 0; b--) {
          for (var A = this.nodes[b].content, B = A.length - 1; B >= 0; B--)
            v += A[B].nodeSize;
          b && v++;
        }
        return v;
      }
    }, {
      key: "findAtPoint",
      value: function(v, b) {
        if (this.find)
          for (var A = 0; A < this.find.length; A++)
            this.find[A].node == v && this.find[A].offset == b && (this.find[A].pos = this.currentPos);
      }
    }, {
      key: "findInside",
      value: function(v) {
        if (this.find)
          for (var b = 0; b < this.find.length; b++)
            this.find[b].pos == null && v.nodeType == 1 && v.contains(this.find[b].node) && (this.find[b].pos = this.currentPos);
      }
    }, {
      key: "findAround",
      value: function(v, b, A) {
        if (v != b && this.find) {
          for (var B = 0; B < this.find.length; B++)
            if (this.find[B].pos == null && v.nodeType == 1 && v.contains(this.find[B].node)) {
              var z = b.compareDocumentPosition(this.find[B].node);
              z & (A ? 2 : 4) && (this.find[B].pos = this.currentPos);
            }
        }
      }
    }, {
      key: "findInText",
      value: function(v) {
        if (this.find)
          for (var b = 0; b < this.find.length; b++)
            this.find[b].node == v && (this.find[b].pos = this.currentPos - (v.nodeValue.length - this.find[b].offset));
      }
    }, {
      key: "matchesContext",
      value: function(v) {
        var b = this;
        if (v.indexOf("|") > -1)
          return v.split(/\s*\|\s*/).some(this.matchesContext, this);
        var A = v.split("/"), B = this.options.context, z = !this.isOpen && (!B || B.parent.type == this.nodes[0].type), G = -(B ? B.depth + 1 : 0) + (z ? 0 : 1), fe = function Ce(Ie, Le) {
          for (; Ie >= 0; Ie--) {
            var Fe = A[Ie];
            if (Fe == "") {
              if (Ie == A.length - 1 || Ie == 0)
                continue;
              for (; Le >= G; Le--)
                if (Ce(Ie - 1, Le))
                  return !0;
              return !1;
            } else {
              var it = Le > 0 || Le == 0 && z ? b.nodes[Le].type : B && Le >= G ? B.node(Le - G).type : null;
              if (!it || it.name != Fe && it.groups.indexOf(Fe) == -1)
                return !1;
              Le--;
            }
          }
          return !0;
        };
        return fe(A.length - 1, this.open);
      }
    }, {
      key: "textblockFromContext",
      value: function() {
        var v = this.options.context;
        if (v)
          for (var b = v.depth; b >= 0; b--) {
            var A = v.node(b).contentMatchAt(v.indexAfter(b)).defaultType;
            if (A && A.isTextblock && A.defaultAttrs)
              return A;
          }
        for (var B in this.parser.schema.nodes) {
          var z = this.parser.schema.nodes[B];
          if (z.isTextblock && z.defaultAttrs)
            return z;
        }
      }
    }, {
      key: "addPendingMark",
      value: function(v) {
        var b = ct(v, this.top.pendingMarks);
        b && this.top.stashMarks.push(b), this.top.pendingMarks = v.addToSet(this.top.pendingMarks);
      }
    }, {
      key: "removePendingMark",
      value: function(v, b) {
        for (var A = this.open; A >= 0; A--) {
          var B = this.nodes[A], z = B.pendingMarks.lastIndexOf(v);
          if (z > -1)
            B.pendingMarks = v.removeFromSet(B.pendingMarks);
          else {
            B.activeMarks = v.removeFromSet(B.activeMarks);
            var G = B.popFromStashMark(v);
            G && B.type && B.type.allowsMarkType(G.type) && (B.activeMarks = G.addToSet(B.activeMarks));
          }
          if (B == b)
            break;
        }
      }
    }]), N;
  }();
  function be(N) {
    for (var S = N.firstChild, v = null; S; S = S.nextSibling) {
      var b = S.nodeType == 1 ? S.nodeName.toLowerCase() : null;
      b && R.hasOwnProperty(b) && v ? (v.appendChild(S), S = v) : b == "li" ? v = S : b && (v = null);
    }
  }
  function Oe(N, S) {
    return (N.matches || N.msMatchesSelector || N.webkitMatchesSelector || N.mozMatchesSelector).call(N, S);
  }
  function Ye(N) {
    for (var S = /\s*([\w-]+)\s*:\s*([^;]+)/g, v, b = []; v = S.exec(N); )
      b.push(v[1], v[2].trim());
    return b;
  }
  function We(N) {
    var S = {};
    for (var v in N)
      S[v] = N[v];
    return S;
  }
  function ut(N, S) {
    var v = S.schema.nodes, b = function(G) {
      var fe = v[G];
      if (!fe.allowsMarkType(N))
        return "continue";
      var Ce = [], Ie = function Le(Fe) {
        Ce.push(Fe);
        for (var it = 0; it < Fe.edgeCount; it++) {
          var Ht = Fe.edge(it), nr = Ht.type, Mr = Ht.next;
          if (nr == S || Ce.indexOf(Mr) < 0 && Le(Mr))
            return !0;
        }
      };
      if (Ie(fe.contentMatch))
        return {
          v: !0
        };
    };
    for (var A in v) {
      var B = b(A);
      if (B !== "continue" && oe(B) === "object")
        return B.v;
    }
  }
  function ct(N, S) {
    for (var v = 0; v < S.length; v++)
      if (N.eq(S[v]))
        return S[v];
  }
  var Ae = function() {
    function N(S, v) {
      X(this, N), this.nodes = S, this.marks = v;
    }
    return ee(N, [{
      key: "serializeFragment",
      value: function(v) {
        var b = this, A = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, B = arguments.length > 2 ? arguments[2] : void 0;
        B || (B = Ee(A).createDocumentFragment());
        var z = B, G = [];
        return v.forEach(function(fe) {
          if (G.length || fe.marks.length) {
            for (var Ce = 0, Ie = 0; Ce < G.length && Ie < fe.marks.length; ) {
              var Le = fe.marks[Ie];
              if (!b.marks[Le.type.name]) {
                Ie++;
                continue;
              }
              if (!Le.eq(G[Ce][0]) || Le.type.spec.spanning === !1)
                break;
              Ce++, Ie++;
            }
            for (; Ce < G.length; )
              z = G.pop()[1];
            for (; Ie < fe.marks.length; ) {
              var Fe = fe.marks[Ie++], it = b.serializeMark(Fe, fe.isInline, A);
              it && (G.push([Fe, z]), z.appendChild(it.dom), z = it.contentDOM || it.dom);
            }
          }
          z.appendChild(b.serializeNodeInner(fe, A));
        }), B;
      }
    }, {
      key: "serializeNodeInner",
      value: function(v, b) {
        var A = N.renderSpec(Ee(b), this.nodes[v.type.name](v)), B = A.dom, z = A.contentDOM;
        if (z) {
          if (v.isLeaf)
            throw new RangeError("Content hole not allowed in a leaf node spec");
          this.serializeFragment(v.content, b, z);
        }
        return B;
      }
    }, {
      key: "serializeNode",
      value: function(v) {
        for (var b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, A = this.serializeNodeInner(v, b), B = v.marks.length - 1; B >= 0; B--) {
          var z = this.serializeMark(v.marks[B], v.isInline, b);
          z && ((z.contentDOM || z.dom).appendChild(A), A = z.dom);
        }
        return A;
      }
    }, {
      key: "serializeMark",
      value: function(v, b) {
        var A = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, B = this.marks[v.type.name];
        return B && N.renderSpec(Ee(A), B(v, b));
      }
    }], [{
      key: "renderSpec",
      value: function(v, b) {
        var A = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
        if (typeof b == "string")
          return {
            dom: v.createTextNode(b)
          };
        if (b.nodeType != null)
          return {
            dom: b
          };
        if (b.dom && b.dom.nodeType != null)
          return b;
        var B = b[0], z = B.indexOf(" ");
        z > 0 && (A = B.slice(0, z), B = B.slice(z + 1));
        var G, fe = A ? v.createElementNS(A, B) : v.createElement(B), Ce = b[1], Ie = 1;
        if (Ce && oe(Ce) == "object" && Ce.nodeType == null && !Array.isArray(Ce)) {
          Ie = 2;
          for (var Le in Ce)
            if (Ce[Le] != null) {
              var Fe = Le.indexOf(" ");
              Fe > 0 ? fe.setAttributeNS(Le.slice(0, Fe), Le.slice(Fe + 1), Ce[Le]) : fe.setAttribute(Le, Ce[Le]);
            }
        }
        for (var it = Ie; it < b.length; it++) {
          var Ht = b[it];
          if (Ht === 0) {
            if (it < b.length - 1 || it > Ie)
              throw new RangeError("Content hole must be the only child of its parent node");
            return {
              dom: fe,
              contentDOM: fe
            };
          } else {
            var nr = N.renderSpec(v, Ht, A), Mr = nr.dom, Ur = nr.contentDOM;
            if (fe.appendChild(Mr), Ur) {
              if (G)
                throw new RangeError("Multiple content holes");
              G = Ur;
            }
          }
        }
        return {
          dom: fe,
          contentDOM: G
        };
      }
    }, {
      key: "fromSchema",
      value: function(v) {
        return v.cached.domSerializer || (v.cached.domSerializer = new N(this.nodesFromSchema(v), this.marksFromSchema(v)));
      }
    }, {
      key: "nodesFromSchema",
      value: function(v) {
        var b = ne(v.nodes);
        return b.text || (b.text = function(A) {
          return A.text;
        }), b;
      }
    }, {
      key: "marksFromSchema",
      value: function(v) {
        return ne(v.marks);
      }
    }]), N;
  }();
  function ne(N) {
    var S = {};
    for (var v in N) {
      var b = N[v].spec.toDOM;
      b && (S[v] = b);
    }
    return S;
  }
  function Ee(N) {
    return N.document || window.document;
  }
  return Or.ContentMatch = Kt, Or.DOMParser = nn, Or.DOMSerializer = Ae, Or.Fragment = ze, Or.Mark = at, Or.MarkType = Qt, Or.Node = wt, Or.NodeRange = ft, Or.NodeType = Rr, Or.ReplaceError = St, Or.ResolvedPos = Z, Or.Schema = Hr, Or.Slice = pt, Or;
}
var Qe = io(), Zn = {}, ln = {}, du = {}, wv;
function Rs() {
  return wv || (wv = 1, function(t) {
    function e(W) {
      "@babel/helpers - typeof";
      return e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(V) {
        return typeof V;
      } : function(V) {
        return V && typeof Symbol == "function" && V.constructor === Symbol && V !== Symbol.prototype ? "symbol" : typeof V;
      }, e(W);
    }
    function r(W) {
      var V = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
      return r = function(D) {
        if (D === null || !a(D))
          return D;
        if (typeof D != "function")
          throw new TypeError("Super expression must either be null or a function");
        if (typeof V < "u") {
          if (V.has(D))
            return V.get(D);
          V.set(D, I);
        }
        function I() {
          return n(D, arguments, T(this).constructor);
        }
        return I.prototype = Object.create(D.prototype, { constructor: { value: I, enumerable: !1, writable: !0, configurable: !0 } }), o(I, D);
      }, r(W);
    }
    function n(W, V, R) {
      return C() ? n = Reflect.construct : n = function(I, H, J) {
        var ve = [null];
        ve.push.apply(ve, H);
        var me = Function.bind.apply(I, ve), be = new me();
        return J && o(be, J.prototype), be;
      }, n.apply(null, arguments);
    }
    function a(W) {
      return Function.toString.call(W).indexOf("[native code]") !== -1;
    }
    function i(W, V) {
      if (typeof V != "function" && V !== null)
        throw new TypeError("Super expression must either be null or a function");
      W.prototype = Object.create(V && V.prototype, { constructor: { value: W, writable: !0, configurable: !0 } }), Object.defineProperty(W, "prototype", { writable: !1 }), V && o(W, V);
    }
    function o(W, V) {
      return o = Object.setPrototypeOf || function(D, I) {
        return D.__proto__ = I, D;
      }, o(W, V);
    }
    function u(W) {
      var V = C();
      return function() {
        var D = T(W), I;
        if (V) {
          var H = T(this).constructor;
          I = Reflect.construct(D, arguments, H);
        } else
          I = D.apply(this, arguments);
        return m(this, I);
      };
    }
    function m(W, V) {
      if (V && (e(V) === "object" || typeof V == "function"))
        return V;
      if (V !== void 0)
        throw new TypeError("Derived constructors may only return object or undefined");
      return y(W);
    }
    function y(W) {
      if (W === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return W;
    }
    function C() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function T(W) {
      return T = Object.setPrototypeOf ? Object.getPrototypeOf : function(R) {
        return R.__proto__ || Object.getPrototypeOf(R);
      }, T(W);
    }
    function x(W, V) {
      if (!(W instanceof V))
        throw new TypeError("Cannot call a class as a function");
    }
    function M(W, V) {
      for (var R = 0; R < V.length; R++) {
        var D = V[R];
        D.enumerable = D.enumerable || !1, D.configurable = !0, "value" in D && (D.writable = !0), Object.defineProperty(W, D.key, D);
      }
    }
    function P(W, V, R) {
      return V && M(W.prototype, V), R && M(W, R), Object.defineProperty(W, "prototype", { writable: !1 }), W;
    }
    var q = io(), _ = 65535, K = Math.pow(2, 16);
    function X(W, V) {
      return W + V * K;
    }
    function ie(W) {
      return W & _;
    }
    function ee(W) {
      return (W - (W & _)) / K;
    }
    var oe = 1, ue = 2, pe = 4, Se = 8, Re = function() {
      function W(V, R, D) {
        x(this, W), this.pos = V, this.delInfo = R, this.recover = D;
      }
      return P(W, [{
        key: "deleted",
        get: function() {
          return (this.delInfo & Se) > 0;
        }
      }, {
        key: "deletedBefore",
        get: function() {
          return (this.delInfo & (oe | pe)) > 0;
        }
      }, {
        key: "deletedAfter",
        get: function() {
          return (this.delInfo & (ue | pe)) > 0;
        }
      }, {
        key: "deletedAcross",
        get: function() {
          return (this.delInfo & pe) > 0;
        }
      }]), W;
    }(), Me = function() {
      function W(V) {
        var R = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
        if (x(this, W), this.ranges = V, this.inverted = R, !V.length && W.empty)
          return W.empty;
      }
      return P(W, [{
        key: "recover",
        value: function(R) {
          var D = 0, I = ie(R);
          if (!this.inverted)
            for (var H = 0; H < I; H++)
              D += this.ranges[H * 3 + 2] - this.ranges[H * 3 + 1];
          return this.ranges[I * 3] + D + ee(R);
        }
      }, {
        key: "mapResult",
        value: function(R) {
          var D = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return this._map(R, D, !1);
        }
      }, {
        key: "map",
        value: function(R) {
          var D = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return this._map(R, D, !0);
        }
      }, {
        key: "_map",
        value: function(R, D, I) {
          for (var H = 0, J = this.inverted ? 2 : 1, ve = this.inverted ? 1 : 2, me = 0; me < this.ranges.length; me += 3) {
            var be = this.ranges[me] - (this.inverted ? H : 0);
            if (be > R)
              break;
            var Oe = this.ranges[me + J], Ye = this.ranges[me + ve], We = be + Oe;
            if (R <= We) {
              var ut = Oe ? R == be ? -1 : R == We ? 1 : D : D, ct = be + H + (ut < 0 ? 0 : Ye);
              if (I)
                return ct;
              var Ae = R == (D < 0 ? be : We) ? null : X(me / 3, R - be), ne = R == be ? ue : R == We ? oe : pe;
              return (D < 0 ? R != be : R != We) && (ne |= Se), new Re(ct, ne, Ae);
            }
            H += Ye - Oe;
          }
          return I ? R + H : new Re(R + H, 0, null);
        }
      }, {
        key: "touches",
        value: function(R, D) {
          for (var I = 0, H = ie(D), J = this.inverted ? 2 : 1, ve = this.inverted ? 1 : 2, me = 0; me < this.ranges.length; me += 3) {
            var be = this.ranges[me] - (this.inverted ? I : 0);
            if (be > R)
              break;
            var Oe = this.ranges[me + J], Ye = be + Oe;
            if (R <= Ye && me == H * 3)
              return !0;
            I += this.ranges[me + ve] - Oe;
          }
          return !1;
        }
      }, {
        key: "forEach",
        value: function(R) {
          for (var D = this.inverted ? 2 : 1, I = this.inverted ? 1 : 2, H = 0, J = 0; H < this.ranges.length; H += 3) {
            var ve = this.ranges[H], me = ve - (this.inverted ? J : 0), be = ve + (this.inverted ? 0 : J), Oe = this.ranges[H + D], Ye = this.ranges[H + I];
            R(me, me + Oe, be, be + Ye), J += Ye - Oe;
          }
        }
      }, {
        key: "invert",
        value: function() {
          return new W(this.ranges, !this.inverted);
        }
      }, {
        key: "toString",
        value: function() {
          return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
        }
      }], [{
        key: "offset",
        value: function(R) {
          return R == 0 ? W.empty : new W(R < 0 ? [0, -R, 0] : [0, 0, R]);
        }
      }]), W;
    }();
    Me.empty = new Me([]);
    var ze = function() {
      function W() {
        var V = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], R = arguments.length > 1 ? arguments[1] : void 0, D = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, I = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : V.length;
        x(this, W), this.maps = V, this.mirror = R, this.from = D, this.to = I;
      }
      return P(W, [{
        key: "slice",
        value: function() {
          var R = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, D = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.maps.length;
          return new W(this.maps, this.mirror, R, D);
        }
      }, {
        key: "copy",
        value: function() {
          return new W(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
        }
      }, {
        key: "appendMap",
        value: function(R, D) {
          this.to = this.maps.push(R), D != null && this.setMirror(this.maps.length - 1, D);
        }
      }, {
        key: "appendMapping",
        value: function(R) {
          for (var D = 0, I = this.maps.length; D < R.maps.length; D++) {
            var H = R.getMirror(D);
            this.appendMap(R.maps[D], H != null && H < D ? I + H : void 0);
          }
        }
      }, {
        key: "getMirror",
        value: function(R) {
          if (this.mirror) {
            for (var D = 0; D < this.mirror.length; D++)
              if (this.mirror[D] == R)
                return this.mirror[D + (D % 2 ? -1 : 1)];
          }
        }
      }, {
        key: "setMirror",
        value: function(R, D) {
          this.mirror || (this.mirror = []), this.mirror.push(R, D);
        }
      }, {
        key: "appendMappingInverted",
        value: function(R) {
          for (var D = R.maps.length - 1, I = this.maps.length + R.maps.length; D >= 0; D--) {
            var H = R.getMirror(D);
            this.appendMap(R.maps[D].invert(), H != null && H > D ? I - H - 1 : void 0);
          }
        }
      }, {
        key: "invert",
        value: function() {
          var R = new W();
          return R.appendMappingInverted(this), R;
        }
      }, {
        key: "map",
        value: function(R) {
          var D = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          if (this.mirror)
            return this._map(R, D, !0);
          for (var I = this.from; I < this.to; I++)
            R = this.maps[I].map(R, D);
          return R;
        }
      }, {
        key: "mapResult",
        value: function(R) {
          var D = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return this._map(R, D, !1);
        }
      }, {
        key: "_map",
        value: function(R, D, I) {
          for (var H = 0, J = this.from; J < this.to; J++) {
            var ve = this.maps[J], me = ve.mapResult(R, D);
            if (me.recover != null) {
              var be = this.getMirror(J);
              if (be != null && be > J && be < this.to) {
                J = be, R = this.maps[be].recover(me.recover);
                continue;
              }
            }
            H |= me.delInfo, R = me.pos;
          }
          return I ? R : new Re(R, H, null);
        }
      }]), W;
    }(), vt = /* @__PURE__ */ Object.create(null), je = function() {
      function W() {
        x(this, W);
      }
      return P(W, [{
        key: "getMap",
        value: function() {
          return Me.empty;
        }
      }, {
        key: "merge",
        value: function(R) {
          return null;
        }
      }], [{
        key: "fromJSON",
        value: function(R, D) {
          if (!D || !D.stepType)
            throw new RangeError("Invalid input for Step.fromJSON");
          var I = vt[D.stepType];
          if (!I)
            throw new RangeError("No step type ".concat(D.stepType, " defined"));
          return I.fromJSON(R, D);
        }
      }, {
        key: "jsonID",
        value: function(R, D) {
          if (R in vt)
            throw new RangeError("Duplicate use of step JSON ID " + R);
          return vt[R] = D, D.prototype.jsonID = R, D;
        }
      }]), W;
    }(), rt = function() {
      function W(V, R) {
        x(this, W), this.doc = V, this.failed = R;
      }
      return P(W, null, [{
        key: "ok",
        value: function(R) {
          return new W(R, null);
        }
      }, {
        key: "fail",
        value: function(R) {
          return new W(null, R);
        }
      }, {
        key: "fromReplace",
        value: function(R, D, I, H) {
          try {
            return W.ok(R.replace(D, I, H));
          } catch (J) {
            if (J instanceof q.ReplaceError)
              return W.fail(J.message);
            throw J;
          }
        }
      }]), W;
    }();
    function at(W, V, R) {
      for (var D = [], I = 0; I < W.childCount; I++) {
        var H = W.child(I);
        H.content.size && (H = H.copy(at(H.content, V, H))), H.isInline && (H = V(H, R, I)), D.push(H);
      }
      return q.Fragment.fromArray(D);
    }
    var St = function(W) {
      i(R, W);
      var V = u(R);
      function R(D, I, H) {
        var J;
        return x(this, R), J = V.call(this), J.from = D, J.to = I, J.mark = H, J;
      }
      return P(R, [{
        key: "apply",
        value: function(I) {
          var H = this, J = I.slice(this.from, this.to), ve = I.resolve(this.from), me = ve.node(ve.sharedDepth(this.to)), be = new q.Slice(at(J.content, function(Oe, Ye) {
            return !Oe.isAtom || !Ye.type.allowsMarkType(H.mark.type) ? Oe : Oe.mark(H.mark.addToSet(Oe.marks));
          }, me), J.openStart, J.openEnd);
          return rt.fromReplace(I, this.from, this.to, be);
        }
      }, {
        key: "invert",
        value: function() {
          return new pt(this.from, this.to, this.mark);
        }
      }, {
        key: "map",
        value: function(I) {
          var H = I.mapResult(this.from, 1), J = I.mapResult(this.to, -1);
          return H.deleted && J.deleted || H.pos >= J.pos ? null : new R(H.pos, J.pos, this.mark);
        }
      }, {
        key: "merge",
        value: function(I) {
          return I instanceof R && I.mark.eq(this.mark) && this.from <= I.to && this.to >= I.from ? new R(Math.min(this.from, I.from), Math.max(this.to, I.to), this.mark) : null;
        }
      }, {
        key: "toJSON",
        value: function() {
          return {
            stepType: "addMark",
            mark: this.mark.toJSON(),
            from: this.from,
            to: this.to
          };
        }
      }], [{
        key: "fromJSON",
        value: function(I, H) {
          if (typeof H.from != "number" || typeof H.to != "number")
            throw new RangeError("Invalid input for AddMarkStep.fromJSON");
          return new R(H.from, H.to, I.markFromJSON(H.mark));
        }
      }]), R;
    }(je);
    je.jsonID("addMark", St);
    var pt = function(W) {
      i(R, W);
      var V = u(R);
      function R(D, I, H) {
        var J;
        return x(this, R), J = V.call(this), J.from = D, J.to = I, J.mark = H, J;
      }
      return P(R, [{
        key: "apply",
        value: function(I) {
          var H = this, J = I.slice(this.from, this.to), ve = new q.Slice(at(J.content, function(me) {
            return me.mark(H.mark.removeFromSet(me.marks));
          }, I), J.openStart, J.openEnd);
          return rt.fromReplace(I, this.from, this.to, ve);
        }
      }, {
        key: "invert",
        value: function() {
          return new St(this.from, this.to, this.mark);
        }
      }, {
        key: "map",
        value: function(I) {
          var H = I.mapResult(this.from, 1), J = I.mapResult(this.to, -1);
          return H.deleted && J.deleted || H.pos >= J.pos ? null : new R(H.pos, J.pos, this.mark);
        }
      }, {
        key: "merge",
        value: function(I) {
          return I instanceof R && I.mark.eq(this.mark) && this.from <= I.to && this.to >= I.from ? new R(Math.min(this.from, I.from), Math.max(this.to, I.to), this.mark) : null;
        }
      }, {
        key: "toJSON",
        value: function() {
          return {
            stepType: "removeMark",
            mark: this.mark.toJSON(),
            from: this.from,
            to: this.to
          };
        }
      }], [{
        key: "fromJSON",
        value: function(I, H) {
          if (typeof H.from != "number" || typeof H.to != "number")
            throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
          return new R(H.from, H.to, I.markFromJSON(H.mark));
        }
      }]), R;
    }(je);
    je.jsonID("removeMark", pt);
    var Pt = function(W) {
      i(R, W);
      var V = u(R);
      function R(D, I) {
        var H;
        return x(this, R), H = V.call(this), H.pos = D, H.mark = I, H;
      }
      return P(R, [{
        key: "apply",
        value: function(I) {
          var H = I.nodeAt(this.pos);
          if (!H)
            return rt.fail("No node at mark step's position");
          var J = H.type.create(H.attrs, null, this.mark.addToSet(H.marks));
          return rt.fromReplace(I, this.pos, this.pos + 1, new q.Slice(q.Fragment.from(J), 0, H.isLeaf ? 0 : 1));
        }
      }, {
        key: "invert",
        value: function(I) {
          var H = I.nodeAt(this.pos);
          if (H) {
            var J = this.mark.addToSet(H.marks);
            if (J.length == H.marks.length) {
              for (var ve = 0; ve < H.marks.length; ve++)
                if (!H.marks[ve].isInSet(J))
                  return new R(this.pos, H.marks[ve]);
              return new R(this.pos, this.mark);
            }
          }
          return new Ft(this.pos, this.mark);
        }
      }, {
        key: "map",
        value: function(I) {
          var H = I.mapResult(this.pos, 1);
          return H.deletedAfter ? null : new R(H.pos, this.mark);
        }
      }, {
        key: "toJSON",
        value: function() {
          return {
            stepType: "addNodeMark",
            pos: this.pos,
            mark: this.mark.toJSON()
          };
        }
      }], [{
        key: "fromJSON",
        value: function(I, H) {
          if (typeof H.pos != "number")
            throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
          return new R(H.pos, I.markFromJSON(H.mark));
        }
      }]), R;
    }(je);
    je.jsonID("addNodeMark", Pt);
    var Ft = function(W) {
      i(R, W);
      var V = u(R);
      function R(D, I) {
        var H;
        return x(this, R), H = V.call(this), H.pos = D, H.mark = I, H;
      }
      return P(R, [{
        key: "apply",
        value: function(I) {
          var H = I.nodeAt(this.pos);
          if (!H)
            return rt.fail("No node at mark step's position");
          var J = H.type.create(H.attrs, null, this.mark.removeFromSet(H.marks));
          return rt.fromReplace(I, this.pos, this.pos + 1, new q.Slice(q.Fragment.from(J), 0, H.isLeaf ? 0 : 1));
        }
      }, {
        key: "invert",
        value: function(I) {
          var H = I.nodeAt(this.pos);
          return !H || !this.mark.isInSet(H.marks) ? this : new Pt(this.pos, this.mark);
        }
      }, {
        key: "map",
        value: function(I) {
          var H = I.mapResult(this.pos, 1);
          return H.deletedAfter ? null : new R(H.pos, this.mark);
        }
      }, {
        key: "toJSON",
        value: function() {
          return {
            stepType: "removeNodeMark",
            pos: this.pos,
            mark: this.mark.toJSON()
          };
        }
      }], [{
        key: "fromJSON",
        value: function(I, H) {
          if (typeof H.pos != "number")
            throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
          return new R(H.pos, I.markFromJSON(H.mark));
        }
      }]), R;
    }(je);
    je.jsonID("removeNodeMark", Ft);
    var Je = function(W) {
      i(R, W);
      var V = u(R);
      function R(D, I, H) {
        var J, ve = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
        return x(this, R), J = V.call(this), J.from = D, J.to = I, J.slice = H, J.structure = ve, J;
      }
      return P(R, [{
        key: "apply",
        value: function(I) {
          return this.structure && yt(I, this.from, this.to) ? rt.fail("Structure replace would overwrite content") : rt.fromReplace(I, this.from, this.to, this.slice);
        }
      }, {
        key: "getMap",
        value: function() {
          return new Me([this.from, this.to - this.from, this.slice.size]);
        }
      }, {
        key: "invert",
        value: function(I) {
          return new R(this.from, this.from + this.slice.size, I.slice(this.from, this.to));
        }
      }, {
        key: "map",
        value: function(I) {
          var H = I.mapResult(this.from, 1), J = I.mapResult(this.to, -1);
          return H.deletedAcross && J.deletedAcross ? null : new R(H.pos, Math.max(H.pos, J.pos), this.slice);
        }
      }, {
        key: "merge",
        value: function(I) {
          if (!(I instanceof R) || I.structure || this.structure)
            return null;
          if (this.from + this.slice.size == I.from && !this.slice.openEnd && !I.slice.openStart) {
            var H = this.slice.size + I.slice.size == 0 ? q.Slice.empty : new q.Slice(this.slice.content.append(I.slice.content), this.slice.openStart, I.slice.openEnd);
            return new R(this.from, this.to + (I.to - I.from), H, this.structure);
          } else if (I.to == this.from && !this.slice.openStart && !I.slice.openEnd) {
            var J = this.slice.size + I.slice.size == 0 ? q.Slice.empty : new q.Slice(I.slice.content.append(this.slice.content), I.slice.openStart, this.slice.openEnd);
            return new R(I.from, this.to, J, this.structure);
          } else
            return null;
        }
      }, {
        key: "toJSON",
        value: function() {
          var I = {
            stepType: "replace",
            from: this.from,
            to: this.to
          };
          return this.slice.size && (I.slice = this.slice.toJSON()), this.structure && (I.structure = !0), I;
        }
      }], [{
        key: "fromJSON",
        value: function(I, H) {
          if (typeof H.from != "number" || typeof H.to != "number")
            throw new RangeError("Invalid input for ReplaceStep.fromJSON");
          return new R(H.from, H.to, q.Slice.fromJSON(I, H.slice), !!H.structure);
        }
      }]), R;
    }(je);
    je.jsonID("replace", Je);
    var Nt = function(W) {
      i(R, W);
      var V = u(R);
      function R(D, I, H, J, ve, me) {
        var be, Oe = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : !1;
        return x(this, R), be = V.call(this), be.from = D, be.to = I, be.gapFrom = H, be.gapTo = J, be.slice = ve, be.insert = me, be.structure = Oe, be;
      }
      return P(R, [{
        key: "apply",
        value: function(I) {
          if (this.structure && (yt(I, this.from, this.gapFrom) || yt(I, this.gapTo, this.to)))
            return rt.fail("Structure gap-replace would overwrite content");
          var H = I.slice(this.gapFrom, this.gapTo);
          if (H.openStart || H.openEnd)
            return rt.fail("Gap is not a flat range");
          var J = this.slice.insertAt(this.insert, H.content);
          return J ? rt.fromReplace(I, this.from, this.to, J) : rt.fail("Content does not fit in gap");
        }
      }, {
        key: "getMap",
        value: function() {
          return new Me([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);
        }
      }, {
        key: "invert",
        value: function(I) {
          var H = this.gapTo - this.gapFrom;
          return new R(this.from, this.from + this.slice.size + H, this.from + this.insert, this.from + this.insert + H, I.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
        }
      }, {
        key: "map",
        value: function(I) {
          var H = I.mapResult(this.from, 1), J = I.mapResult(this.to, -1), ve = I.map(this.gapFrom, -1), me = I.map(this.gapTo, 1);
          return H.deletedAcross && J.deletedAcross || ve < H.pos || me > J.pos ? null : new R(H.pos, J.pos, ve, me, this.slice, this.insert, this.structure);
        }
      }, {
        key: "toJSON",
        value: function() {
          var I = {
            stepType: "replaceAround",
            from: this.from,
            to: this.to,
            gapFrom: this.gapFrom,
            gapTo: this.gapTo,
            insert: this.insert
          };
          return this.slice.size && (I.slice = this.slice.toJSON()), this.structure && (I.structure = !0), I;
        }
      }], [{
        key: "fromJSON",
        value: function(I, H) {
          if (typeof H.from != "number" || typeof H.to != "number" || typeof H.gapFrom != "number" || typeof H.gapTo != "number" || typeof H.insert != "number")
            throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
          return new R(H.from, H.to, H.gapFrom, H.gapTo, q.Slice.fromJSON(I, H.slice), H.insert, !!H.structure);
        }
      }]), R;
    }(je);
    je.jsonID("replaceAround", Nt);
    function yt(W, V, R) {
      for (var D = W.resolve(V), I = R - V, H = D.depth; I > 0 && H > 0 && D.indexAfter(H) == D.node(H).childCount; )
        H--, I--;
      if (I > 0)
        for (var J = D.node(H).maybeChild(D.indexAfter(H)); I > 0; ) {
          if (!J || J.isLeaf)
            return !0;
          J = J.firstChild, I--;
        }
      return !1;
    }
    function At(W, V, R, D) {
      var I = [], H = [], J, ve;
      W.doc.nodesBetween(V, R, function(me, be, Oe) {
        if (me.isInline) {
          var Ye = me.marks;
          if (!D.isInSet(Ye) && Oe.type.allowsMarkType(D.type)) {
            for (var We = Math.max(be, V), ut = Math.min(be + me.nodeSize, R), ct = D.addToSet(Ye), Ae = 0; Ae < Ye.length; Ae++)
              Ye[Ae].isInSet(ct) || (J && J.to == We && J.mark.eq(Ye[Ae]) ? J.to = ut : I.push(J = new pt(We, ut, Ye[Ae])));
            ve && ve.to == We ? ve.to = ut : H.push(ve = new St(We, ut, D));
          }
        }
      }), I.forEach(function(me) {
        return W.step(me);
      }), H.forEach(function(me) {
        return W.step(me);
      });
    }
    function lt(W, V, R, D) {
      var I = [], H = 0;
      W.doc.nodesBetween(V, R, function(J, ve) {
        if (J.isInline) {
          H++;
          var me = null;
          if (D instanceof q.MarkType)
            for (var be = J.marks, Oe; Oe = D.isInSet(be); )
              (me || (me = [])).push(Oe), be = Oe.removeFromSet(be);
          else
            D ? D.isInSet(J.marks) && (me = [D]) : me = J.marks;
          if (me && me.length)
            for (var Ye = Math.min(ve + J.nodeSize, R), We = 0; We < me.length; We++) {
              for (var ut = me[We], ct = void 0, Ae = 0; Ae < I.length; Ae++) {
                var ne = I[Ae];
                ne.step == H - 1 && ut.eq(I[Ae].style) && (ct = ne);
              }
              ct ? (ct.to = Ye, ct.step = H) : I.push({
                style: ut,
                from: Math.max(ve, V),
                to: Ye,
                step: H
              });
            }
        }
      }), I.forEach(function(J) {
        return W.step(new pt(J.from, J.to, J.style));
      });
    }
    function Rt(W, V, R) {
      for (var D = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : R.contentMatch, I = W.doc.nodeAt(V), H = [], J = V + 1, ve = 0; ve < I.childCount; ve++) {
        var me = I.child(ve), be = J + me.nodeSize, Oe = D.matchType(me.type);
        if (!Oe)
          H.push(new Je(J, be, q.Slice.empty));
        else {
          D = Oe;
          for (var Ye = 0; Ye < me.marks.length; Ye++)
            R.allowsMarkType(me.marks[Ye].type) || W.step(new pt(J, be, me.marks[Ye]));
          if (me.isText && !R.spec.code)
            for (var We = void 0, ut = /\r?\n|\r/g, ct = void 0; We = ut.exec(me.text); )
              ct || (ct = new q.Slice(q.Fragment.from(R.schema.text(" ", R.allowedMarks(me.marks))), 0, 0)), H.push(new Je(J + We.index, J + We.index + We[0].length, ct));
        }
        J = be;
      }
      if (!D.validEnd) {
        var Ae = D.fillBefore(q.Fragment.empty, !0);
        W.replace(J, J, new q.Slice(Ae, 0, 0));
      }
      for (var ne = H.length - 1; ne >= 0; ne--)
        W.step(H[ne]);
    }
    function he(W, V, R) {
      return (V == 0 || W.canReplace(V, W.childCount)) && (R == W.childCount || W.canReplace(0, R));
    }
    function le(W) {
      for (var V = W.parent, R = V.content.cutByIndex(W.startIndex, W.endIndex), D = W.depth; ; --D) {
        var I = W.$from.node(D), H = W.$from.index(D), J = W.$to.indexAfter(D);
        if (D < W.depth && I.canReplace(H, J, R))
          return D;
        if (D == 0 || I.type.spec.isolating || !he(I, H, J))
          break;
      }
      return null;
    }
    function te(W, V, R) {
      for (var D = V.$from, I = V.$to, H = V.depth, J = D.before(H + 1), ve = I.after(H + 1), me = J, be = ve, Oe = q.Fragment.empty, Ye = 0, We = H, ut = !1; We > R; We--)
        ut || D.index(We) > 0 ? (ut = !0, Oe = q.Fragment.from(D.node(We).copy(Oe)), Ye++) : me--;
      for (var ct = q.Fragment.empty, Ae = 0, ne = H, Ee = !1; ne > R; ne--)
        Ee || I.after(ne + 1) < I.end(ne) ? (Ee = !0, ct = q.Fragment.from(I.node(ne).copy(ct)), Ae++) : be++;
      W.step(new Nt(me, be, J, ve, new q.Slice(Oe.append(ct), Ye, Ae), Oe.size - Ye, !0));
    }
    function ae(W, V) {
      var R = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, D = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : W, I = de(W, V), H = I && Te(D, V);
      return H ? I.map(Z).concat({
        type: V,
        attrs: R
      }).concat(H.map(Z)) : null;
    }
    function Z(W) {
      return {
        type: W,
        attrs: null
      };
    }
    function de(W, V) {
      var R = W.parent, D = W.startIndex, I = W.endIndex, H = R.contentMatchAt(D).findWrapping(V);
      if (!H)
        return null;
      var J = H.length ? H[0] : V;
      return R.canReplaceWith(D, I, J) ? H : null;
    }
    function Te(W, V) {
      var R = W.parent, D = W.startIndex, I = W.endIndex, H = R.child(D), J = V.contentMatch.findWrapping(H.type);
      if (!J)
        return null;
      for (var ve = J.length ? J[J.length - 1] : V, me = ve.contentMatch, be = D; me && be < I; be++)
        me = me.matchType(R.child(be).type);
      return !me || !me.validEnd ? null : J;
    }
    function Pe(W, V, R) {
      for (var D = q.Fragment.empty, I = R.length - 1; I >= 0; I--) {
        if (D.size) {
          var H = R[I].type.contentMatch.matchFragment(D);
          if (!H || !H.validEnd)
            throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
        }
        D = q.Fragment.from(R[I].type.create(R[I].attrs, D));
      }
      var J = V.start, ve = V.end;
      W.step(new Nt(J, ve, J, ve, new q.Slice(D, 0, 0), R.length, !0));
    }
    function ft(W, V, R, D, I) {
      if (!D.isTextblock)
        throw new RangeError("Type given to setBlockType should be a textblock");
      var H = W.steps.length;
      W.doc.nodesBetween(V, R, function(J, ve) {
        if (J.isTextblock && !J.hasMarkup(D, I) && ht(W.doc, W.mapping.slice(H).map(ve), D)) {
          W.clearIncompatible(W.mapping.slice(H).map(ve, 1), D);
          var me = W.mapping.slice(H), be = me.map(ve, 1), Oe = me.map(ve + J.nodeSize, 1);
          return W.step(new Nt(be, Oe, be + 1, Oe - 1, new q.Slice(q.Fragment.from(D.create(I, null, J.marks)), 0, 0), 1, !0)), !1;
        }
      });
    }
    function ht(W, V, R) {
      var D = W.resolve(V), I = D.index();
      return D.parent.canReplaceWith(I, I + 1, R);
    }
    function wt(W, V, R, D, I) {
      var H = W.doc.nodeAt(V);
      if (!H)
        throw new RangeError("No node at given position");
      R || (R = H.type);
      var J = R.create(D, null, I || H.marks);
      if (H.isLeaf)
        return W.replaceWith(V, V + H.nodeSize, J);
      if (!R.validContent(H.content))
        throw new RangeError("Invalid content for node type " + R.name);
      W.step(new Nt(V, V + H.nodeSize, V + 1, V + H.nodeSize - 1, new q.Slice(q.Fragment.from(J), 0, 0), 1, !0));
    }
    function Ot(W, V) {
      var R = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, D = arguments.length > 3 ? arguments[3] : void 0, I = W.resolve(V), H = I.depth - R, J = D && D[D.length - 1] || I.parent;
      if (H < 0 || I.parent.type.spec.isolating || !I.parent.canReplace(I.index(), I.parent.childCount) || !J.type.validContent(I.parent.content.cutByIndex(I.index(), I.parent.childCount)))
        return !1;
      for (var ve = I.depth - 1, me = R - 2; ve > H; ve--, me--) {
        var be = I.node(ve), Oe = I.index(ve);
        if (be.type.spec.isolating)
          return !1;
        var Ye = be.content.cutByIndex(Oe, be.childCount), We = D && D[me + 1];
        We && (Ye = Ye.replaceChild(0, We.type.create(We.attrs)));
        var ut = D && D[me] || be;
        if (!be.canReplace(Oe + 1, be.childCount) || !ut.type.validContent(Ye))
          return !1;
      }
      var ct = I.indexAfter(H), Ae = D && D[0];
      return I.node(H).canReplaceWith(ct, ct, Ae ? Ae.type : I.node(H + 1).type);
    }
    function Ut(W, V) {
      for (var R = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, D = arguments.length > 3 ? arguments[3] : void 0, I = W.doc.resolve(V), H = q.Fragment.empty, J = q.Fragment.empty, ve = I.depth, me = I.depth - R, be = R - 1; ve > me; ve--, be--) {
        H = q.Fragment.from(I.node(ve).copy(H));
        var Oe = D && D[be];
        J = q.Fragment.from(Oe ? Oe.type.create(Oe.attrs, J) : I.node(ve).copy(J));
      }
      W.step(new Je(V, V, new q.Slice(H.append(J), R, R), !0));
    }
    function Kt(W, V) {
      var R = W.resolve(V), D = R.index();
      return qr(R.nodeBefore, R.nodeAfter) && R.parent.canReplace(D, D + 1);
    }
    function qr(W, V) {
      return !!(W && V && !W.isLeaf && W.canAppend(V));
    }
    function Jt(W, V) {
      for (var R = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1, D = W.resolve(V), I = D.depth; ; I--) {
        var H = void 0, J = void 0, ve = D.index(I);
        if (I == D.depth ? (H = D.nodeBefore, J = D.nodeAfter) : R > 0 ? (H = D.node(I + 1), ve++, J = D.node(I).maybeChild(ve)) : (H = D.node(I).maybeChild(ve - 1), J = D.node(I + 1)), H && !H.isTextblock && qr(H, J) && D.node(I).canReplace(ve, ve + 1))
          return V;
        if (I == 0)
          break;
        V = R < 0 ? D.before(I) : D.after(I);
      }
    }
    function _t(W, V, R) {
      var D = new Je(V - R, V + R, q.Slice.empty, !0);
      W.step(D);
    }
    function pr(W, V, R) {
      var D = W.resolve(V);
      if (D.parent.canReplaceWith(D.index(), D.index(), R))
        return V;
      if (D.parentOffset == 0)
        for (var I = D.depth - 1; I >= 0; I--) {
          var H = D.index(I);
          if (D.node(I).canReplaceWith(H, H, R))
            return D.before(I + 1);
          if (H > 0)
            return null;
        }
      if (D.parentOffset == D.parent.content.size)
        for (var J = D.depth - 1; J >= 0; J--) {
          var ve = D.indexAfter(J);
          if (D.node(J).canReplaceWith(ve, ve, R))
            return D.after(J + 1);
          if (ve < D.node(J).childCount)
            return null;
        }
      return null;
    }
    function hr(W, V, R) {
      var D = W.resolve(V);
      if (!R.content.size)
        return V;
      for (var I = R.content, H = 0; H < R.openStart; H++)
        I = I.firstChild.content;
      for (var J = 1; J <= (R.openStart == 0 && R.size ? 2 : 1); J++)
        for (var ve = D.depth; ve >= 0; ve--) {
          var me = ve == D.depth ? 0 : D.pos <= (D.start(ve + 1) + D.end(ve + 1)) / 2 ? -1 : 1, be = D.index(ve) + (me > 0 ? 1 : 0), Oe = D.node(ve), Ye = !1;
          if (J == 1)
            Ye = Oe.canReplace(be, be, I);
          else {
            var We = Oe.contentMatchAt(be).findWrapping(I.firstChild.type);
            Ye = We && Oe.canReplaceWith(be, be, We[0]);
          }
          if (Ye)
            return me == 0 ? D.pos : me < 0 ? D.before(ve + 1) : D.after(ve + 1);
        }
      return null;
    }
    function Fr(W, V) {
      var R = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : V, D = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : q.Slice.empty;
      if (V == R && !D.size)
        return null;
      var I = W.resolve(V), H = W.resolve(R);
      return _r(I, H, D) ? new Je(V, R, D) : new He(I, H, D).fit();
    }
    function _r(W, V, R) {
      return !R.openStart && !R.openEnd && W.start() == V.start() && W.parent.canReplace(W.index(), V.index(), R.content);
    }
    var He = function() {
      function W(V, R, D) {
        x(this, W), this.$from = V, this.$to = R, this.unplaced = D, this.frontier = [], this.placed = q.Fragment.empty;
        for (var I = 0; I <= V.depth; I++) {
          var H = V.node(I);
          this.frontier.push({
            type: H.type,
            match: H.contentMatchAt(V.indexAfter(I))
          });
        }
        for (var J = V.depth; J > 0; J--)
          this.placed = q.Fragment.from(V.node(J).copy(this.placed));
      }
      return P(W, [{
        key: "depth",
        get: function() {
          return this.frontier.length - 1;
        }
      }, {
        key: "fit",
        value: function() {
          for (; this.unplaced.size; ) {
            var R = this.findFittable();
            R ? this.placeNodes(R) : this.openMore() || this.dropNode();
          }
          var D = this.mustMoveInline(), I = this.placed.size - this.depth - this.$from.depth, H = this.$from, J = this.close(D < 0 ? this.$to : H.doc.resolve(D));
          if (!J)
            return null;
          for (var ve = this.placed, me = H.depth, be = J.depth; me && be && ve.childCount == 1; )
            ve = ve.firstChild.content, me--, be--;
          var Oe = new q.Slice(ve, me, be);
          return D > -1 ? new Nt(H.pos, D, this.$to.pos, this.$to.end(), Oe, I) : Oe.size || H.pos != this.$to.pos ? new Je(H.pos, J.pos, Oe) : null;
        }
      }, {
        key: "findFittable",
        value: function() {
          for (var R = this.unplaced.openStart, D = this.unplaced.content, I = 0, H = this.unplaced.openEnd; I < R; I++) {
            var J = D.firstChild;
            if (D.childCount > 1 && (H = 0), J.type.spec.isolating && H <= I) {
              R = I;
              break;
            }
            D = J.content;
          }
          for (var ve = 1; ve <= 2; ve++)
            for (var me = ve == 1 ? R : this.unplaced.openStart; me >= 0; me--) {
              var be = void 0, Oe = null;
              me ? (Oe = st(this.unplaced.content, me - 1).firstChild, be = Oe.content) : be = this.unplaced.content;
              for (var Ye = be.firstChild, We = this.depth; We >= 0; We--) {
                var ut = this.frontier[We], ct = ut.type, Ae = ut.match, ne = void 0, Ee = null;
                if (ve == 1 && (Ye ? Ae.matchType(Ye.type) || (Ee = Ae.fillBefore(q.Fragment.from(Ye), !1)) : Oe && ct.compatibleContent(Oe.type)))
                  return {
                    sliceDepth: me,
                    frontierDepth: We,
                    parent: Oe,
                    inject: Ee
                  };
                if (ve == 2 && Ye && (ne = Ae.findWrapping(Ye.type)))
                  return {
                    sliceDepth: me,
                    frontierDepth: We,
                    parent: Oe,
                    wrap: ne
                  };
                if (Oe && Ae.matchType(Oe.type))
                  break;
              }
            }
        }
      }, {
        key: "openMore",
        value: function() {
          var R = this.unplaced, D = R.content, I = R.openStart, H = R.openEnd, J = st(D, I);
          return !J.childCount || J.firstChild.isLeaf ? !1 : (this.unplaced = new q.Slice(D, I + 1, Math.max(H, J.size + I >= D.size - H ? I + 1 : 0)), !0);
        }
      }, {
        key: "dropNode",
        value: function() {
          var R = this.unplaced, D = R.content, I = R.openStart, H = R.openEnd, J = st(D, I);
          if (J.childCount <= 1 && I > 0) {
            var ve = D.size - I <= I + J.size;
            this.unplaced = new q.Slice(_e(D, I - 1, 1), I - 1, ve ? I - 1 : H);
          } else
            this.unplaced = new q.Slice(_e(D, I, 1), I, H);
        }
      }, {
        key: "placeNodes",
        value: function(R) {
          for (var D = R.sliceDepth, I = R.frontierDepth, H = R.parent, J = R.inject, ve = R.wrap; this.depth > I; )
            this.closeFrontierNode();
          if (ve)
            for (var me = 0; me < ve.length; me++)
              this.openFrontierNode(ve[me]);
          var be = this.unplaced, Oe = H ? H.content : be.content, Ye = be.openStart - D, We = 0, ut = [], ct = this.frontier[I], Ae = ct.match, ne = ct.type;
          if (J) {
            for (var me = 0; me < J.childCount; me++)
              ut.push(J.child(me));
            Ae = Ae.matchFragment(J);
          }
          for (var Ee = Oe.size + D - (be.content.size - be.openEnd); We < Oe.childCount; ) {
            var N = Oe.child(We), S = Ae.matchType(N.type);
            if (!S)
              break;
            We++, (We > 1 || Ye == 0 || N.content.size) && (Ae = S, ut.push(Ct(N.mark(ne.allowedMarks(N.marks)), We == 1 ? Ye : 0, We == Oe.childCount ? Ee : -1)));
          }
          var v = We == Oe.childCount;
          v || (Ee = -1), this.placed = Xe(this.placed, I, q.Fragment.from(ut)), this.frontier[I].match = Ae, v && Ee < 0 && H && H.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
          for (var b = 0, A = Oe; b < Ee; b++) {
            var B = A.lastChild;
            this.frontier.push({
              type: B.type,
              match: B.contentMatchAt(B.childCount)
            }), A = B.content;
          }
          this.unplaced = v ? D == 0 ? q.Slice.empty : new q.Slice(_e(be.content, D - 1, 1), D - 1, Ee < 0 ? be.openEnd : D - 1) : new q.Slice(_e(be.content, D, We), be.openStart, be.openEnd);
        }
      }, {
        key: "mustMoveInline",
        value: function() {
          if (!this.$to.parent.isTextblock)
            return -1;
          var R = this.frontier[this.depth], D;
          if (!R.type.isTextblock || !rr(this.$to, this.$to.depth, R.type, R.match, !1) || this.$to.depth == this.depth && (D = this.findCloseLevel(this.$to)) && D.depth == this.depth)
            return -1;
          for (var I = this.$to.depth, H = this.$to.after(I); I > 1 && H == this.$to.end(--I); )
            ++H;
          return H;
        }
      }, {
        key: "findCloseLevel",
        value: function(R) {
          e:
            for (var D = Math.min(this.depth, R.depth); D >= 0; D--) {
              var I = this.frontier[D], H = I.match, J = I.type, ve = D < R.depth && R.end(D + 1) == R.pos + (R.depth - (D + 1)), me = rr(R, D, J, H, ve);
              if (me) {
                for (var be = D - 1; be >= 0; be--) {
                  var Oe = this.frontier[be], Ye = Oe.match, We = Oe.type, ut = rr(R, be, We, Ye, !0);
                  if (!ut || ut.childCount)
                    continue e;
                }
                return {
                  depth: D,
                  fit: me,
                  move: ve ? R.doc.resolve(R.after(D + 1)) : R
                };
              }
            }
        }
      }, {
        key: "close",
        value: function(R) {
          var D = this.findCloseLevel(R);
          if (!D)
            return null;
          for (; this.depth > D.depth; )
            this.closeFrontierNode();
          D.fit.childCount && (this.placed = Xe(this.placed, D.depth, D.fit)), R = D.move;
          for (var I = D.depth + 1; I <= R.depth; I++) {
            var H = R.node(I), J = H.type.contentMatch.fillBefore(H.content, !0, R.index(I));
            this.openFrontierNode(H.type, H.attrs, J);
          }
          return R;
        }
      }, {
        key: "openFrontierNode",
        value: function(R) {
          var D = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, I = arguments.length > 2 ? arguments[2] : void 0, H = this.frontier[this.depth];
          H.match = H.match.matchType(R), this.placed = Xe(this.placed, this.depth, q.Fragment.from(R.create(D, I))), this.frontier.push({
            type: R,
            match: R.contentMatch
          });
        }
      }, {
        key: "closeFrontierNode",
        value: function() {
          var R = this.frontier.pop(), D = R.match.fillBefore(q.Fragment.empty, !0);
          D.childCount && (this.placed = Xe(this.placed, this.frontier.length, D));
        }
      }]), W;
    }();
    function _e(W, V, R) {
      return V == 0 ? W.cutByIndex(R, W.childCount) : W.replaceChild(0, W.firstChild.copy(_e(W.firstChild.content, V - 1, R)));
    }
    function Xe(W, V, R) {
      return V == 0 ? W.append(R) : W.replaceChild(W.childCount - 1, W.lastChild.copy(Xe(W.lastChild.content, V - 1, R)));
    }
    function st(W, V) {
      for (var R = 0; R < V; R++)
        W = W.firstChild.content;
      return W;
    }
    function Ct(W, V, R) {
      if (V <= 0)
        return W;
      var D = W.content;
      return V > 1 && (D = D.replaceChild(0, Ct(D.firstChild, V - 1, D.childCount == 1 ? R - 1 : 0))), V > 0 && (D = W.type.contentMatch.fillBefore(D).append(D), R <= 0 && (D = D.append(W.type.contentMatch.matchFragment(D).fillBefore(q.Fragment.empty, !0)))), W.copy(D);
    }
    function rr(W, V, R, D, I) {
      var H = W.node(V), J = I ? W.indexAfter(V) : W.index(V);
      if (J == H.childCount && !R.compatibleContent(H.type))
        return null;
      var ve = D.fillBefore(H.content, !0, J);
      return ve && !lr(R, H.content, J) ? ve : null;
    }
    function lr(W, V, R) {
      for (var D = R; D < V.childCount; D++)
        if (!W.allowsMarks(V.child(D).marks))
          return !0;
      return !1;
    }
    function Yt(W) {
      return W.spec.defining || W.spec.definingForContent;
    }
    function Zt(W, V, R, D) {
      if (!D.size)
        return W.deleteRange(V, R);
      var I = W.doc.resolve(V), H = W.doc.resolve(R);
      if (_r(I, H, D))
        return W.step(new Je(V, R, D));
      var J = Hr(I, W.doc.resolve(R));
      J[J.length - 1] == 0 && J.pop();
      var ve = -(I.depth + 1);
      J.unshift(ve);
      for (var me = I.depth, be = I.pos - 1; me > 0; me--, be--) {
        var Oe = I.node(me).type.spec;
        if (Oe.defining || Oe.definingAsContext || Oe.isolating)
          break;
        J.indexOf(me) > -1 ? ve = me : I.before(me) == be && J.splice(1, 0, -me);
      }
      for (var Ye = J.indexOf(ve), We = [], ut = D.openStart, ct = D.content, Ae = 0; ; Ae++) {
        var ne = ct.firstChild;
        if (We.push(ne), Ae == D.openStart)
          break;
        ct = ne.content;
      }
      for (var Ee = ut - 1; Ee >= 0; Ee--) {
        var N = We[Ee], S = Yt(N.type);
        if (S && !N.sameMarkup(I.node(Math.abs(ve) - 1)))
          ut = Ee;
        else if (S || !N.type.isTextblock)
          break;
      }
      for (var v = D.openStart; v >= 0; v--) {
        var b = (v + ut + 1) % (D.openStart + 1), A = We[b];
        if (A)
          for (var B = 0; B < J.length; B++) {
            var z = J[(B + Ye) % J.length], G = !0;
            z < 0 && (G = !1, z = -z);
            var fe = I.node(z - 1), Ce = I.index(z - 1);
            if (fe.canReplaceWith(Ce, Ce, A.type, A.marks))
              return W.replace(I.before(z), G ? H.after(z) : R, new q.Slice(Rr(D.content, 0, D.openStart, b), b, D.openEnd));
          }
      }
      for (var Ie = W.steps.length, Le = J.length - 1; Le >= 0 && (W.replace(V, R, D), !(W.steps.length > Ie)); Le--) {
        var Fe = J[Le];
        Fe < 0 || (V = I.before(Fe), R = H.after(Fe));
      }
    }
    function Rr(W, V, R, D, I) {
      if (V < R) {
        var H = W.firstChild;
        W = W.replaceChild(0, H.copy(Rr(H.content, V + 1, R, D, H)));
      }
      if (V > D) {
        var J = I.contentMatchAt(0), ve = J.fillBefore(W).append(W);
        W = ve.append(J.matchFragment(ve).fillBefore(q.Fragment.empty, !0));
      }
      return W;
    }
    function Cr(W, V, R, D) {
      if (!D.isInline && V == R && W.doc.resolve(V).parent.content.size) {
        var I = pr(W.doc, V, D.type);
        I != null && (V = R = I);
      }
      W.replaceRange(V, R, new q.Slice(q.Fragment.from(D), 0, 0));
    }
    function Qt(W, V, R) {
      for (var D = W.doc.resolve(V), I = W.doc.resolve(R), H = Hr(D, I), J = 0; J < H.length; J++) {
        var ve = H[J], me = J == H.length - 1;
        if (me && ve == 0 || D.node(ve).type.contentMatch.validEnd)
          return W.delete(D.start(ve), I.end(ve));
        if (ve > 0 && (me || D.node(ve - 1).canReplace(D.index(ve - 1), I.indexAfter(ve - 1))))
          return W.delete(D.before(ve), I.after(ve));
      }
      for (var be = 1; be <= D.depth && be <= I.depth; be++)
        if (V - D.start(be) == D.depth - be && R > D.end(be) && I.end(be) - R != I.depth - be)
          return W.delete(D.before(be), R);
      W.delete(V, R);
    }
    function Hr(W, V) {
      for (var R = [], D = Math.min(W.depth, V.depth), I = D; I >= 0; I--) {
        var H = W.start(I);
        if (H < W.pos - (W.depth - I) || V.end(I) > V.pos + (V.depth - I) || W.node(I).type.spec.isolating || V.node(I).type.spec.isolating)
          break;
        (H == V.start(I) || I == W.depth && I == V.depth && W.parent.inlineContent && V.parent.inlineContent && I && V.start(I - 1) == H - 1) && R.push(I);
      }
      return R;
    }
    var Tr = function(W) {
      i(R, W);
      var V = u(R);
      function R(D, I, H) {
        var J;
        return x(this, R), J = V.call(this), J.pos = D, J.attr = I, J.value = H, J;
      }
      return P(R, [{
        key: "apply",
        value: function(I) {
          var H = I.nodeAt(this.pos);
          if (!H)
            return rt.fail("No node at attribute step's position");
          var J = /* @__PURE__ */ Object.create(null);
          for (var ve in H.attrs)
            J[ve] = H.attrs[ve];
          J[this.attr] = this.value;
          var me = H.type.create(J, null, H.marks);
          return rt.fromReplace(I, this.pos, this.pos + 1, new q.Slice(q.Fragment.from(me), 0, H.isLeaf ? 0 : 1));
        }
      }, {
        key: "getMap",
        value: function() {
          return Me.empty;
        }
      }, {
        key: "invert",
        value: function(I) {
          return new R(this.pos, this.attr, I.nodeAt(this.pos).attrs[this.attr]);
        }
      }, {
        key: "map",
        value: function(I) {
          var H = I.mapResult(this.pos, 1);
          return H.deletedAfter ? null : new R(H.pos, this.attr, this.value);
        }
      }, {
        key: "toJSON",
        value: function() {
          return {
            stepType: "attr",
            pos: this.pos,
            attr: this.attr,
            value: this.value
          };
        }
      }], [{
        key: "fromJSON",
        value: function(I, H) {
          if (typeof H.pos != "number" || typeof H.attr != "string")
            throw new RangeError("Invalid input for AttrStep.fromJSON");
          return new R(H.pos, H.attr, H.value);
        }
      }]), R;
    }(je);
    je.jsonID("attr", Tr), t.TransformError = function(W) {
      i(R, W);
      var V = u(R);
      function R() {
        return x(this, R), V.apply(this, arguments);
      }
      return P(R);
    }(r(Error)), t.TransformError = function W(V) {
      var R = Error.call(this, V);
      return R.__proto__ = W.prototype, R;
    }, t.TransformError.prototype = Object.create(Error.prototype), t.TransformError.prototype.constructor = t.TransformError, t.TransformError.prototype.name = "TransformError";
    var nn = function() {
      function W(V) {
        x(this, W), this.doc = V, this.steps = [], this.docs = [], this.mapping = new ze();
      }
      return P(W, [{
        key: "before",
        get: function() {
          return this.docs.length ? this.docs[0] : this.doc;
        }
      }, {
        key: "step",
        value: function(R) {
          var D = this.maybeStep(R);
          if (D.failed)
            throw new t.TransformError(D.failed);
          return this;
        }
      }, {
        key: "maybeStep",
        value: function(R) {
          var D = R.apply(this.doc);
          return D.failed || this.addStep(R, D.doc), D;
        }
      }, {
        key: "docChanged",
        get: function() {
          return this.steps.length > 0;
        }
      }, {
        key: "addStep",
        value: function(R, D) {
          this.docs.push(this.doc), this.steps.push(R), this.mapping.appendMap(R.getMap()), this.doc = D;
        }
      }, {
        key: "replace",
        value: function(R) {
          var D = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : R, I = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : q.Slice.empty, H = Fr(this.doc, R, D, I);
          return H && this.step(H), this;
        }
      }, {
        key: "replaceWith",
        value: function(R, D, I) {
          return this.replace(R, D, new q.Slice(q.Fragment.from(I), 0, 0));
        }
      }, {
        key: "delete",
        value: function(R, D) {
          return this.replace(R, D, q.Slice.empty);
        }
      }, {
        key: "insert",
        value: function(R, D) {
          return this.replaceWith(R, R, D);
        }
      }, {
        key: "replaceRange",
        value: function(R, D, I) {
          return Zt(this, R, D, I), this;
        }
      }, {
        key: "replaceRangeWith",
        value: function(R, D, I) {
          return Cr(this, R, D, I), this;
        }
      }, {
        key: "deleteRange",
        value: function(R, D) {
          return Qt(this, R, D), this;
        }
      }, {
        key: "lift",
        value: function(R, D) {
          return te(this, R, D), this;
        }
      }, {
        key: "join",
        value: function(R) {
          var D = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return _t(this, R, D), this;
        }
      }, {
        key: "wrap",
        value: function(R, D) {
          return Pe(this, R, D), this;
        }
      }, {
        key: "setBlockType",
        value: function(R) {
          var D = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : R, I = arguments.length > 2 ? arguments[2] : void 0, H = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
          return ft(this, R, D, I, H), this;
        }
      }, {
        key: "setNodeMarkup",
        value: function(R, D) {
          var I = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, H = arguments.length > 3 ? arguments[3] : void 0;
          return wt(this, R, D, I, H), this;
        }
      }, {
        key: "setNodeAttribute",
        value: function(R, D, I) {
          return this.step(new Tr(R, D, I)), this;
        }
      }, {
        key: "addNodeMark",
        value: function(R, D) {
          return this.step(new Pt(R, D)), this;
        }
      }, {
        key: "removeNodeMark",
        value: function(R, D) {
          if (!(D instanceof q.Mark)) {
            var I = this.doc.nodeAt(R);
            if (!I)
              throw new RangeError("No node at position " + R);
            if (D = D.isInSet(I.marks), !D)
              return this;
          }
          return this.step(new Ft(R, D)), this;
        }
      }, {
        key: "split",
        value: function(R) {
          var D = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, I = arguments.length > 2 ? arguments[2] : void 0;
          return Ut(this, R, D, I), this;
        }
      }, {
        key: "addMark",
        value: function(R, D, I) {
          return At(this, R, D, I), this;
        }
      }, {
        key: "removeMark",
        value: function(R, D, I) {
          return lt(this, R, D, I), this;
        }
      }, {
        key: "clearIncompatible",
        value: function(R, D, I) {
          return Rt(this, R, D, I), this;
        }
      }]), W;
    }();
    t.AddMarkStep = St, t.AddNodeMarkStep = Pt, t.AttrStep = Tr, t.MapResult = Re, t.Mapping = ze, t.RemoveMarkStep = pt, t.RemoveNodeMarkStep = Ft, t.ReplaceAroundStep = Nt, t.ReplaceStep = Je, t.Step = je, t.StepMap = Me, t.StepResult = rt, t.Transform = nn, t.canJoin = Kt, t.canSplit = Ot, t.dropPoint = hr, t.findWrapping = ae, t.insertPoint = pr, t.joinPoint = Jt, t.liftTarget = le, t.replaceStep = Fr;
  }(du)), du;
}
var Cv;
function oo() {
  if (Cv)
    return ln;
  Cv = 1;
  function t(he) {
    "@babel/helpers - typeof";
    return t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(le) {
      return typeof le;
    } : function(le) {
      return le && typeof Symbol == "function" && le.constructor === Symbol && le !== Symbol.prototype ? "symbol" : typeof le;
    }, t(he);
  }
  function e() {
    return typeof Reflect < "u" && Reflect.get ? e = Reflect.get : e = function(le, te, ae) {
      var Z = r(le, te);
      if (Z) {
        var de = Object.getOwnPropertyDescriptor(Z, te);
        return de.get ? de.get.call(arguments.length < 3 ? le : ae) : de.value;
      }
    }, e.apply(this, arguments);
  }
  function r(he, le) {
    for (; !Object.prototype.hasOwnProperty.call(he, le) && (he = y(he), he !== null); )
      ;
    return he;
  }
  function n(he, le) {
    if (typeof le != "function" && le !== null)
      throw new TypeError("Super expression must either be null or a function");
    he.prototype = Object.create(le && le.prototype, { constructor: { value: he, writable: !0, configurable: !0 } }), Object.defineProperty(he, "prototype", { writable: !1 }), le && a(he, le);
  }
  function a(he, le) {
    return a = Object.setPrototypeOf || function(ae, Z) {
      return ae.__proto__ = Z, ae;
    }, a(he, le);
  }
  function i(he) {
    var le = m();
    return function() {
      var ae = y(he), Z;
      if (le) {
        var de = y(this).constructor;
        Z = Reflect.construct(ae, arguments, de);
      } else
        Z = ae.apply(this, arguments);
      return o(this, Z);
    };
  }
  function o(he, le) {
    if (le && (t(le) === "object" || typeof le == "function"))
      return le;
    if (le !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return u(he);
  }
  function u(he) {
    if (he === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return he;
  }
  function m() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function y(he) {
    return y = Object.setPrototypeOf ? Object.getPrototypeOf : function(te) {
      return te.__proto__ || Object.getPrototypeOf(te);
    }, y(he);
  }
  function C(he, le) {
    if (!(he instanceof le))
      throw new TypeError("Cannot call a class as a function");
  }
  function T(he, le) {
    for (var te = 0; te < le.length; te++) {
      var ae = le[te];
      ae.enumerable = ae.enumerable || !1, ae.configurable = !0, "value" in ae && (ae.writable = !0), Object.defineProperty(he, ae.key, ae);
    }
  }
  function x(he, le, te) {
    return le && T(he.prototype, le), te && T(he, te), Object.defineProperty(he, "prototype", { writable: !1 }), he;
  }
  Object.defineProperty(ln, "__esModule", {
    value: !0
  });
  var M = io(), P = Rs(), q = /* @__PURE__ */ Object.create(null), _ = function() {
    function he(le, te, ae) {
      C(this, he), this.$anchor = le, this.$head = te, this.ranges = ae || [new K(le.min(te), le.max(te))];
    }
    return x(he, [{
      key: "anchor",
      get: function() {
        return this.$anchor.pos;
      }
    }, {
      key: "head",
      get: function() {
        return this.$head.pos;
      }
    }, {
      key: "from",
      get: function() {
        return this.$from.pos;
      }
    }, {
      key: "to",
      get: function() {
        return this.$to.pos;
      }
    }, {
      key: "$from",
      get: function() {
        return this.ranges[0].$from;
      }
    }, {
      key: "$to",
      get: function() {
        return this.ranges[0].$to;
      }
    }, {
      key: "empty",
      get: function() {
        for (var te = this.ranges, ae = 0; ae < te.length; ae++)
          if (te[ae].$from.pos != te[ae].$to.pos)
            return !1;
        return !0;
      }
    }, {
      key: "content",
      value: function() {
        return this.$from.doc.slice(this.from, this.to, !0);
      }
    }, {
      key: "replace",
      value: function(te) {
        for (var ae = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : M.Slice.empty, Z = ae.content.lastChild, de = null, Te = 0; Te < ae.openEnd; Te++)
          de = Z, Z = Z.lastChild;
        for (var Pe = te.steps.length, ft = this.ranges, ht = 0; ht < ft.length; ht++) {
          var wt = ft[ht], Ot = wt.$from, Ut = wt.$to, Kt = te.mapping.slice(Pe);
          te.replaceRange(Kt.map(Ot.pos), Kt.map(Ut.pos), ht ? M.Slice.empty : ae), ht == 0 && ze(te, Pe, (Z ? Z.isInline : de && de.isTextblock) ? -1 : 1);
        }
      }
    }, {
      key: "replaceWith",
      value: function(te, ae) {
        for (var Z = te.steps.length, de = this.ranges, Te = 0; Te < de.length; Te++) {
          var Pe = de[Te], ft = Pe.$from, ht = Pe.$to, wt = te.mapping.slice(Z), Ot = wt.map(ft.pos), Ut = wt.map(ht.pos);
          Te ? te.deleteRange(Ot, Ut) : (te.replaceRangeWith(Ot, Ut, ae), ze(te, Z, ae.isInline ? -1 : 1));
        }
      }
    }, {
      key: "getBookmark",
      value: function() {
        return ee.between(this.$anchor, this.$head).getBookmark();
      }
    }], [{
      key: "findFrom",
      value: function(te, ae) {
        var Z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, de = te.parent.inlineContent ? new ee(te) : Me(te.node(0), te.parent, te.pos, te.index(), ae, Z);
        if (de)
          return de;
        for (var Te = te.depth - 1; Te >= 0; Te--) {
          var Pe = ae < 0 ? Me(te.node(0), te.node(Te), te.before(Te + 1), te.index(Te), ae, Z) : Me(te.node(0), te.node(Te), te.after(Te + 1), te.index(Te) + 1, ae, Z);
          if (Pe)
            return Pe;
        }
        return null;
      }
    }, {
      key: "near",
      value: function(te) {
        var ae = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        return this.findFrom(te, ae) || this.findFrom(te, -ae) || new Se(te.node(0));
      }
    }, {
      key: "atStart",
      value: function(te) {
        return Me(te, te, 0, 0, 1) || new Se(te);
      }
    }, {
      key: "atEnd",
      value: function(te) {
        return Me(te, te, te.content.size, te.childCount, -1) || new Se(te);
      }
    }, {
      key: "fromJSON",
      value: function(te, ae) {
        if (!ae || !ae.type)
          throw new RangeError("Invalid input for Selection.fromJSON");
        var Z = q[ae.type];
        if (!Z)
          throw new RangeError("No selection type ".concat(ae.type, " defined"));
        return Z.fromJSON(te, ae);
      }
    }, {
      key: "jsonID",
      value: function(te, ae) {
        if (te in q)
          throw new RangeError("Duplicate use of selection JSON ID " + te);
        return q[te] = ae, ae.prototype.jsonID = te, ae;
      }
    }]), he;
  }();
  _.prototype.visible = !0;
  var K = x(function he(le, te) {
    C(this, he), this.$from = le, this.$to = te;
  }), X = !1;
  function ie(he) {
    !X && !he.parent.inlineContent && (X = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + he.parent.type.name + ")"));
  }
  var ee = function(he) {
    n(te, he);
    var le = i(te);
    function te(ae) {
      var Z = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ae;
      return C(this, te), ie(ae), ie(Z), le.call(this, ae, Z);
    }
    return x(te, [{
      key: "$cursor",
      get: function() {
        return this.$anchor.pos == this.$head.pos ? this.$head : null;
      }
    }, {
      key: "map",
      value: function(Z, de) {
        var Te = Z.resolve(de.map(this.head));
        if (!Te.parent.inlineContent)
          return _.near(Te);
        var Pe = Z.resolve(de.map(this.anchor));
        return new te(Pe.parent.inlineContent ? Pe : Te, Te);
      }
    }, {
      key: "replace",
      value: function(Z) {
        var de = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : M.Slice.empty;
        if (e(y(te.prototype), "replace", this).call(this, Z, de), de == M.Slice.empty) {
          var Te = this.$from.marksAcross(this.$to);
          Te && Z.ensureMarks(Te);
        }
      }
    }, {
      key: "eq",
      value: function(Z) {
        return Z instanceof te && Z.anchor == this.anchor && Z.head == this.head;
      }
    }, {
      key: "getBookmark",
      value: function() {
        return new oe(this.anchor, this.head);
      }
    }, {
      key: "toJSON",
      value: function() {
        return {
          type: "text",
          anchor: this.anchor,
          head: this.head
        };
      }
    }], [{
      key: "fromJSON",
      value: function(Z, de) {
        if (typeof de.anchor != "number" || typeof de.head != "number")
          throw new RangeError("Invalid input for TextSelection.fromJSON");
        return new te(Z.resolve(de.anchor), Z.resolve(de.head));
      }
    }, {
      key: "create",
      value: function(Z, de) {
        var Te = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : de, Pe = Z.resolve(de);
        return new this(Pe, Te == de ? Pe : Z.resolve(Te));
      }
    }, {
      key: "between",
      value: function(Z, de, Te) {
        var Pe = Z.pos - de.pos;
        if ((!Te || Pe) && (Te = Pe >= 0 ? 1 : -1), !de.parent.inlineContent) {
          var ft = _.findFrom(de, Te, !0) || _.findFrom(de, -Te, !0);
          if (ft)
            de = ft.$head;
          else
            return _.near(de, Te);
        }
        return Z.parent.inlineContent || (Pe == 0 ? Z = de : (Z = (_.findFrom(Z, -Te, !0) || _.findFrom(Z, Te, !0)).$anchor, Z.pos < de.pos != Pe < 0 && (Z = de))), new te(Z, de);
      }
    }]), te;
  }(_);
  _.jsonID("text", ee);
  var oe = function() {
    function he(le, te) {
      C(this, he), this.anchor = le, this.head = te;
    }
    return x(he, [{
      key: "map",
      value: function(te) {
        return new he(te.map(this.anchor), te.map(this.head));
      }
    }, {
      key: "resolve",
      value: function(te) {
        return ee.between(te.resolve(this.anchor), te.resolve(this.head));
      }
    }]), he;
  }(), ue = function(he) {
    n(te, he);
    var le = i(te);
    function te(ae) {
      var Z;
      C(this, te);
      var de = ae.nodeAfter, Te = ae.node(0).resolve(ae.pos + de.nodeSize);
      return Z = le.call(this, ae, Te), Z.node = de, Z;
    }
    return x(te, [{
      key: "map",
      value: function(Z, de) {
        var Te = de.mapResult(this.anchor), Pe = Te.deleted, ft = Te.pos, ht = Z.resolve(ft);
        return Pe ? _.near(ht) : new te(ht);
      }
    }, {
      key: "content",
      value: function() {
        return new M.Slice(M.Fragment.from(this.node), 0, 0);
      }
    }, {
      key: "eq",
      value: function(Z) {
        return Z instanceof te && Z.anchor == this.anchor;
      }
    }, {
      key: "toJSON",
      value: function() {
        return {
          type: "node",
          anchor: this.anchor
        };
      }
    }, {
      key: "getBookmark",
      value: function() {
        return new pe(this.anchor);
      }
    }], [{
      key: "fromJSON",
      value: function(Z, de) {
        if (typeof de.anchor != "number")
          throw new RangeError("Invalid input for NodeSelection.fromJSON");
        return new te(Z.resolve(de.anchor));
      }
    }, {
      key: "create",
      value: function(Z, de) {
        return new te(Z.resolve(de));
      }
    }, {
      key: "isSelectable",
      value: function(Z) {
        return !Z.isText && Z.type.spec.selectable !== !1;
      }
    }]), te;
  }(_);
  ue.prototype.visible = !1, _.jsonID("node", ue);
  var pe = function() {
    function he(le) {
      C(this, he), this.anchor = le;
    }
    return x(he, [{
      key: "map",
      value: function(te) {
        var ae = te.mapResult(this.anchor), Z = ae.deleted, de = ae.pos;
        return Z ? new oe(de, de) : new he(de);
      }
    }, {
      key: "resolve",
      value: function(te) {
        var ae = te.resolve(this.anchor), Z = ae.nodeAfter;
        return Z && ue.isSelectable(Z) ? new ue(ae) : _.near(ae);
      }
    }]), he;
  }(), Se = function(he) {
    n(te, he);
    var le = i(te);
    function te(ae) {
      return C(this, te), le.call(this, ae.resolve(0), ae.resolve(ae.content.size));
    }
    return x(te, [{
      key: "replace",
      value: function(Z) {
        var de = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : M.Slice.empty;
        if (de == M.Slice.empty) {
          Z.delete(0, Z.doc.content.size);
          var Te = _.atStart(Z.doc);
          Te.eq(Z.selection) || Z.setSelection(Te);
        } else
          e(y(te.prototype), "replace", this).call(this, Z, de);
      }
    }, {
      key: "toJSON",
      value: function() {
        return {
          type: "all"
        };
      }
    }, {
      key: "map",
      value: function(Z) {
        return new te(Z);
      }
    }, {
      key: "eq",
      value: function(Z) {
        return Z instanceof te;
      }
    }, {
      key: "getBookmark",
      value: function() {
        return Re;
      }
    }], [{
      key: "fromJSON",
      value: function(Z) {
        return new te(Z);
      }
    }]), te;
  }(_);
  _.jsonID("all", Se);
  var Re = {
    map: function() {
      return this;
    },
    resolve: function(le) {
      return new Se(le);
    }
  };
  function Me(he, le, te, ae, Z) {
    var de = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1;
    if (le.inlineContent)
      return ee.create(he, te);
    for (var Te = ae - (Z > 0 ? 0 : 1); Z > 0 ? Te < le.childCount : Te >= 0; Te += Z) {
      var Pe = le.child(Te);
      if (Pe.isAtom) {
        if (!de && ue.isSelectable(Pe))
          return ue.create(he, te - (Z < 0 ? Pe.nodeSize : 0));
      } else {
        var ft = Me(he, Pe, te + Z, Z < 0 ? Pe.childCount : 0, Z, de);
        if (ft)
          return ft;
      }
      te += Pe.nodeSize * Z;
    }
    return null;
  }
  function ze(he, le, te) {
    var ae = he.steps.length - 1;
    if (!(ae < le)) {
      var Z = he.steps[ae];
      if (Z instanceof P.ReplaceStep || Z instanceof P.ReplaceAroundStep) {
        var de = he.mapping.maps[ae], Te;
        de.forEach(function(Pe, ft, ht, wt) {
          Te == null && (Te = wt);
        }), he.setSelection(_.near(he.doc.resolve(Te), te));
      }
    }
  }
  var vt = 1, je = 2, rt = 4, at = function(he) {
    n(te, he);
    var le = i(te);
    function te(ae) {
      var Z;
      return C(this, te), Z = le.call(this, ae.doc), Z.curSelectionFor = 0, Z.updated = 0, Z.meta = /* @__PURE__ */ Object.create(null), Z.time = Date.now(), Z.curSelection = ae.selection, Z.storedMarks = ae.storedMarks, Z;
    }
    return x(te, [{
      key: "selection",
      get: function() {
        return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
      }
    }, {
      key: "setSelection",
      value: function(Z) {
        if (Z.$from.doc != this.doc)
          throw new RangeError("Selection passed to setSelection must point at the current document");
        return this.curSelection = Z, this.curSelectionFor = this.steps.length, this.updated = (this.updated | vt) & ~je, this.storedMarks = null, this;
      }
    }, {
      key: "selectionSet",
      get: function() {
        return (this.updated & vt) > 0;
      }
    }, {
      key: "setStoredMarks",
      value: function(Z) {
        return this.storedMarks = Z, this.updated |= je, this;
      }
    }, {
      key: "ensureMarks",
      value: function(Z) {
        return M.Mark.sameSet(this.storedMarks || this.selection.$from.marks(), Z) || this.setStoredMarks(Z), this;
      }
    }, {
      key: "addStoredMark",
      value: function(Z) {
        return this.ensureMarks(Z.addToSet(this.storedMarks || this.selection.$head.marks()));
      }
    }, {
      key: "removeStoredMark",
      value: function(Z) {
        return this.ensureMarks(Z.removeFromSet(this.storedMarks || this.selection.$head.marks()));
      }
    }, {
      key: "storedMarksSet",
      get: function() {
        return (this.updated & je) > 0;
      }
    }, {
      key: "addStep",
      value: function(Z, de) {
        e(y(te.prototype), "addStep", this).call(this, Z, de), this.updated = this.updated & ~je, this.storedMarks = null;
      }
    }, {
      key: "setTime",
      value: function(Z) {
        return this.time = Z, this;
      }
    }, {
      key: "replaceSelection",
      value: function(Z) {
        return this.selection.replace(this, Z), this;
      }
    }, {
      key: "replaceSelectionWith",
      value: function(Z) {
        var de = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, Te = this.selection;
        return de && (Z = Z.mark(this.storedMarks || (Te.empty ? Te.$from.marks() : Te.$from.marksAcross(Te.$to) || M.Mark.none))), Te.replaceWith(this, Z), this;
      }
    }, {
      key: "deleteSelection",
      value: function() {
        return this.selection.replace(this), this;
      }
    }, {
      key: "insertText",
      value: function(Z, de, Te) {
        var Pe = this.doc.type.schema;
        if (de == null)
          return Z ? this.replaceSelectionWith(Pe.text(Z), !0) : this.deleteSelection();
        if (Te == null && (Te = de), Te = Te ?? de, !Z)
          return this.deleteRange(de, Te);
        var ft = this.storedMarks;
        if (!ft) {
          var ht = this.doc.resolve(de);
          ft = Te == de ? ht.marks() : ht.marksAcross(this.doc.resolve(Te));
        }
        return this.replaceRangeWith(de, Te, Pe.text(Z, ft)), this.selection.empty || this.setSelection(_.near(this.selection.$to)), this;
      }
    }, {
      key: "setMeta",
      value: function(Z, de) {
        return this.meta[typeof Z == "string" ? Z : Z.key] = de, this;
      }
    }, {
      key: "getMeta",
      value: function(Z) {
        return this.meta[typeof Z == "string" ? Z : Z.key];
      }
    }, {
      key: "isGeneric",
      get: function() {
        for (var Z in this.meta)
          return !1;
        return !0;
      }
    }, {
      key: "scrollIntoView",
      value: function() {
        return this.updated |= rt, this;
      }
    }, {
      key: "scrolledIntoView",
      get: function() {
        return (this.updated & rt) > 0;
      }
    }]), te;
  }(P.Transform);
  function St(he, le) {
    return !le || !he ? he : he.bind(le);
  }
  var pt = x(function he(le, te, ae) {
    C(this, he), this.name = le, this.init = St(te.init, ae), this.apply = St(te.apply, ae);
  }), Pt = [new pt("doc", {
    init: function(le) {
      return le.doc || le.schema.topNodeType.createAndFill();
    },
    apply: function(le) {
      return le.doc;
    }
  }), new pt("selection", {
    init: function(le, te) {
      return le.selection || _.atStart(te.doc);
    },
    apply: function(le) {
      return le.selection;
    }
  }), new pt("storedMarks", {
    init: function(le) {
      return le.storedMarks || null;
    },
    apply: function(le, te, ae, Z) {
      return Z.selection.$cursor ? le.storedMarks : null;
    }
  }), new pt("scrollToSelection", {
    init: function() {
      return 0;
    },
    apply: function(le, te) {
      return le.scrolledIntoView ? te + 1 : te;
    }
  })], Ft = x(function he(le, te) {
    var ae = this;
    C(this, he), this.schema = le, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = Pt.slice(), te && te.forEach(function(Z) {
      if (ae.pluginsByKey[Z.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + Z.key + ")");
      ae.plugins.push(Z), ae.pluginsByKey[Z.key] = Z, Z.spec.state && ae.fields.push(new pt(Z.key, Z.spec.state, Z));
    });
  }), Je = function() {
    function he(le) {
      C(this, he), this.config = le;
    }
    return x(he, [{
      key: "schema",
      get: function() {
        return this.config.schema;
      }
    }, {
      key: "plugins",
      get: function() {
        return this.config.plugins;
      }
    }, {
      key: "apply",
      value: function(te) {
        return this.applyTransaction(te).state;
      }
    }, {
      key: "filterTransaction",
      value: function(te) {
        for (var ae = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1, Z = 0; Z < this.config.plugins.length; Z++)
          if (Z != ae) {
            var de = this.config.plugins[Z];
            if (de.spec.filterTransaction && !de.spec.filterTransaction.call(de, te, this))
              return !1;
          }
        return !0;
      }
    }, {
      key: "applyTransaction",
      value: function(te) {
        if (!this.filterTransaction(te))
          return {
            state: this,
            transactions: []
          };
        for (var ae = [te], Z = this.applyInner(te), de = null; ; ) {
          for (var Te = !1, Pe = 0; Pe < this.config.plugins.length; Pe++) {
            var ft = this.config.plugins[Pe];
            if (ft.spec.appendTransaction) {
              var ht = de ? de[Pe].n : 0, wt = de ? de[Pe].state : this, Ot = ht < ae.length && ft.spec.appendTransaction.call(ft, ht ? ae.slice(ht) : ae, wt, Z);
              if (Ot && Z.filterTransaction(Ot, Pe)) {
                if (Ot.setMeta("appendedTransaction", te), !de) {
                  de = [];
                  for (var Ut = 0; Ut < this.config.plugins.length; Ut++)
                    de.push(Ut < Pe ? {
                      state: Z,
                      n: ae.length
                    } : {
                      state: this,
                      n: 0
                    });
                }
                ae.push(Ot), Z = Z.applyInner(Ot), Te = !0;
              }
              de && (de[Pe] = {
                state: Z,
                n: ae.length
              });
            }
          }
          if (!Te)
            return {
              state: Z,
              transactions: ae
            };
        }
      }
    }, {
      key: "applyInner",
      value: function(te) {
        if (!te.before.eq(this.doc))
          throw new RangeError("Applying a mismatched transaction");
        for (var ae = new he(this.config), Z = this.config.fields, de = 0; de < Z.length; de++) {
          var Te = Z[de];
          ae[Te.name] = Te.apply(te, this[Te.name], this, ae);
        }
        return ae;
      }
    }, {
      key: "tr",
      get: function() {
        return new at(this);
      }
    }, {
      key: "reconfigure",
      value: function(te) {
        for (var ae = new Ft(this.schema, te.plugins), Z = ae.fields, de = new he(ae), Te = 0; Te < Z.length; Te++) {
          var Pe = Z[Te].name;
          de[Pe] = this.hasOwnProperty(Pe) ? this[Pe] : Z[Te].init(te, de);
        }
        return de;
      }
    }, {
      key: "toJSON",
      value: function(te) {
        var ae = {
          doc: this.doc.toJSON(),
          selection: this.selection.toJSON()
        };
        if (this.storedMarks && (ae.storedMarks = this.storedMarks.map(function(Pe) {
          return Pe.toJSON();
        })), te && t(te) == "object")
          for (var Z in te) {
            if (Z == "doc" || Z == "selection")
              throw new RangeError("The JSON fields `doc` and `selection` are reserved");
            var de = te[Z], Te = de.spec.state;
            Te && Te.toJSON && (ae[Z] = Te.toJSON.call(de, this[de.key]));
          }
        return ae;
      }
    }], [{
      key: "create",
      value: function(te) {
        for (var ae = new Ft(te.doc ? te.doc.type.schema : te.schema, te.plugins), Z = new he(ae), de = 0; de < ae.fields.length; de++)
          Z[ae.fields[de].name] = ae.fields[de].init(te, Z);
        return Z;
      }
    }, {
      key: "fromJSON",
      value: function(te, ae, Z) {
        if (!ae)
          throw new RangeError("Invalid input for EditorState.fromJSON");
        if (!te.schema)
          throw new RangeError("Required config field 'schema' missing");
        var de = new Ft(te.schema, te.plugins), Te = new he(de);
        return de.fields.forEach(function(Pe) {
          if (Pe.name == "doc")
            Te.doc = M.Node.fromJSON(te.schema, ae.doc);
          else if (Pe.name == "selection")
            Te.selection = _.fromJSON(Te.doc, ae.selection);
          else if (Pe.name == "storedMarks")
            ae.storedMarks && (Te.storedMarks = ae.storedMarks.map(te.schema.markFromJSON));
          else {
            if (Z)
              for (var ft in Z) {
                var ht = Z[ft], wt = ht.spec.state;
                if (ht.key == Pe.name && wt && wt.fromJSON && Object.prototype.hasOwnProperty.call(ae, ft)) {
                  Te[Pe.name] = wt.fromJSON.call(ht, te, ae[ft], Te);
                  return;
                }
              }
            Te[Pe.name] = Pe.init(te, Te);
          }
        }), Te;
      }
    }]), he;
  }();
  function Nt(he, le, te) {
    for (var ae in he) {
      var Z = he[ae];
      Z instanceof Function ? Z = Z.bind(le) : ae == "handleDOMEvents" && (Z = Nt(Z, le, {})), te[ae] = Z;
    }
    return te;
  }
  var yt = function() {
    function he(le) {
      C(this, he), this.spec = le, this.props = {}, le.props && Nt(le.props, this, this.props), this.key = le.key ? le.key.key : lt("plugin");
    }
    return x(he, [{
      key: "getState",
      value: function(te) {
        return te[this.key];
      }
    }]), he;
  }(), At = /* @__PURE__ */ Object.create(null);
  function lt(he) {
    return he in At ? he + "$" + ++At[he] : (At[he] = 0, he + "$");
  }
  var Rt = function() {
    function he() {
      var le = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "key";
      C(this, he), this.key = lt(le);
    }
    return x(he, [{
      key: "get",
      value: function(te) {
        return te.config.pluginsByKey[this.key];
      }
    }, {
      key: "getState",
      value: function(te) {
        return te[this.key];
      }
    }]), he;
  }();
  return ln.AllSelection = Se, ln.EditorState = Je, ln.NodeSelection = ue, ln.Plugin = yt, ln.PluginKey = Rt, ln.Selection = _, ln.SelectionRange = K, ln.TextSelection = ee, ln.Transaction = at, ln;
}
var Tv;
function Gp() {
  if (Tv)
    return Zn;
  Tv = 1;
  function t(s) {
    "@babel/helpers - typeof";
    return t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(h) {
      return typeof h;
    } : function(h) {
      return h && typeof Symbol == "function" && h.constructor === Symbol && h !== Symbol.prototype ? "symbol" : typeof h;
    }, t(s);
  }
  function e(s, h) {
    var l = typeof Symbol < "u" && s[Symbol.iterator] || s["@@iterator"];
    if (!l) {
      if (Array.isArray(s) || (l = r(s)) || h && s && typeof s.length == "number") {
        l && (s = l);
        var d = 0, g = function() {
        };
        return { s: g, n: function() {
          return d >= s.length ? { done: !0 } : { done: !1, value: s[d++] };
        }, e: function($) {
          throw $;
        }, f: g };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var w = !0, E = !1, L;
    return { s: function() {
      l = l.call(s);
    }, n: function() {
      var $ = l.next();
      return w = $.done, $;
    }, e: function($) {
      E = !0, L = $;
    }, f: function() {
      try {
        !w && l.return != null && l.return();
      } finally {
        if (E)
          throw L;
      }
    } };
  }
  function r(s, h) {
    if (s) {
      if (typeof s == "string")
        return n(s, h);
      var l = Object.prototype.toString.call(s).slice(8, -1);
      if (l === "Object" && s.constructor && (l = s.constructor.name), l === "Map" || l === "Set")
        return Array.from(s);
      if (l === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(l))
        return n(s, h);
    }
  }
  function n(s, h) {
    (h == null || h > s.length) && (h = s.length);
    for (var l = 0, d = new Array(h); l < h; l++)
      d[l] = s[l];
    return d;
  }
  function a() {
    return typeof Reflect < "u" && Reflect.get ? a = Reflect.get : a = function(h, l, d) {
      var g = i(h, l);
      if (g) {
        var w = Object.getOwnPropertyDescriptor(g, l);
        return w.get ? w.get.call(arguments.length < 3 ? h : d) : w.value;
      }
    }, a.apply(this, arguments);
  }
  function i(s, h) {
    for (; !Object.prototype.hasOwnProperty.call(s, h) && (s = x(s), s !== null); )
      ;
    return s;
  }
  function o(s, h) {
    if (typeof h != "function" && h !== null)
      throw new TypeError("Super expression must either be null or a function");
    s.prototype = Object.create(h && h.prototype, { constructor: { value: s, writable: !0, configurable: !0 } }), Object.defineProperty(s, "prototype", { writable: !1 }), h && u(s, h);
  }
  function u(s, h) {
    return u = Object.setPrototypeOf || function(d, g) {
      return d.__proto__ = g, d;
    }, u(s, h);
  }
  function m(s) {
    var h = T();
    return function() {
      var d = x(s), g;
      if (h) {
        var w = x(this).constructor;
        g = Reflect.construct(d, arguments, w);
      } else
        g = d.apply(this, arguments);
      return y(this, g);
    };
  }
  function y(s, h) {
    if (h && (t(h) === "object" || typeof h == "function"))
      return h;
    if (h !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return C(s);
  }
  function C(s) {
    if (s === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return s;
  }
  function T() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function x(s) {
    return x = Object.setPrototypeOf ? Object.getPrototypeOf : function(l) {
      return l.__proto__ || Object.getPrototypeOf(l);
    }, x(s);
  }
  function M(s, h) {
    if (!(s instanceof h))
      throw new TypeError("Cannot call a class as a function");
  }
  function P(s, h) {
    for (var l = 0; l < h.length; l++) {
      var d = h[l];
      d.enumerable = d.enumerable || !1, d.configurable = !0, "value" in d && (d.writable = !0), Object.defineProperty(s, d.key, d);
    }
  }
  function q(s, h, l) {
    return h && P(s.prototype, h), l && P(s, l), Object.defineProperty(s, "prototype", { writable: !1 }), s;
  }
  Object.defineProperty(Zn, "__esModule", {
    value: !0
  });
  var _ = oo(), K = io(), X = Rs(), ie = function(h) {
    for (var l = 0; ; l++)
      if (h = h.previousSibling, !h)
        return l;
  }, ee = function(h) {
    var l = h.assignedSlot || h.parentNode;
    return l && l.nodeType == 11 ? l.host : l;
  }, oe = null, ue = function(h, l, d) {
    var g = oe || (oe = document.createRange());
    return g.setEnd(h, d ?? h.nodeValue.length), g.setStart(h, l || 0), g;
  }, pe = function(h, l, d, g) {
    return d && (Re(h, l, d, g, -1) || Re(h, l, d, g, 1));
  }, Se = /^(img|br|input|textarea|hr)$/i;
  function Re(s, h, l, d, g) {
    for (; ; ) {
      if (s == l && h == d)
        return !0;
      if (h == (g < 0 ? 0 : Me(s))) {
        var w = s.parentNode;
        if (!w || w.nodeType != 1 || vt(s) || Se.test(s.nodeName) || s.contentEditable == "false")
          return !1;
        h = ie(s) + (g < 0 ? 0 : 1), s = w;
      } else if (s.nodeType == 1) {
        if (s = s.childNodes[h + (g < 0 ? -1 : 0)], s.contentEditable == "false")
          return !1;
        h = g < 0 ? Me(s) : 0;
      } else
        return !1;
    }
  }
  function Me(s) {
    return s.nodeType == 3 ? s.nodeValue.length : s.childNodes.length;
  }
  function ze(s, h, l) {
    for (var d = h == 0, g = h == Me(s); d || g; ) {
      if (s == l)
        return !0;
      var w = ie(s);
      if (s = s.parentNode, !s)
        return !1;
      d = d && w == 0, g = g && w == Me(s);
    }
  }
  function vt(s) {
    for (var h, l = s; l && !(h = l.pmViewDesc); l = l.parentNode)
      ;
    return h && h.node && h.node.isBlock && (h.dom == s || h.contentDOM == s);
  }
  var je = function(h) {
    return h.focusNode && pe(h.focusNode, h.focusOffset, h.anchorNode, h.anchorOffset);
  };
  function rt(s, h) {
    var l = document.createEvent("Event");
    return l.initEvent("keydown", !0, !0), l.keyCode = s, l.key = l.code = h, l;
  }
  function at(s) {
    for (var h = s.activeElement; h && h.shadowRoot; )
      h = h.shadowRoot.activeElement;
    return h;
  }
  function St(s, h, l) {
    if (s.caretPositionFromPoint)
      try {
        var d = s.caretPositionFromPoint(h, l);
        if (d)
          return {
            node: d.offsetNode,
            offset: d.offset
          };
      } catch {
      }
    if (s.caretRangeFromPoint) {
      var g = s.caretRangeFromPoint(h, l);
      if (g)
        return {
          node: g.startContainer,
          offset: g.startOffset
        };
    }
  }
  var pt = typeof navigator < "u" ? navigator : null, Pt = typeof document < "u" ? document : null, Ft = pt && pt.userAgent || "", Je = /Edge\/(\d+)/.exec(Ft), Nt = /MSIE \d/.exec(Ft), yt = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Ft), At = !!(Nt || yt || Je), lt = Nt ? document.documentMode : yt ? +yt[1] : Je ? +Je[1] : 0, Rt = !At && /gecko\/(\d+)/i.test(Ft);
  Rt && +(/Firefox\/(\d+)/.exec(Ft) || [0, 0])[1];
  var he = !At && /Chrome\/(\d+)/.exec(Ft), le = !!he, te = he ? +he[1] : 0, ae = !At && !!pt && /Apple Computer/.test(pt.vendor), Z = ae && (/Mobile\/\w+/.test(Ft) || !!pt && pt.maxTouchPoints > 2), de = Z || (pt ? /Mac/.test(pt.platform) : !1), Te = pt ? /Win/.test(pt.platform) : !1, Pe = /Android \d/.test(Ft), ft = !!Pt && "webkitFontSmoothing" in Pt.documentElement.style, ht = ft ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
  function wt(s) {
    return {
      left: 0,
      right: s.documentElement.clientWidth,
      top: 0,
      bottom: s.documentElement.clientHeight
    };
  }
  function Ot(s, h) {
    return typeof s == "number" ? s : s[h];
  }
  function Ut(s) {
    var h = s.getBoundingClientRect(), l = h.width / s.offsetWidth || 1, d = h.height / s.offsetHeight || 1;
    return {
      left: h.left,
      right: h.left + s.clientWidth * l,
      top: h.top,
      bottom: h.top + s.clientHeight * d
    };
  }
  function Kt(s, h, l) {
    for (var d = s.someProp("scrollThreshold") || 0, g = s.someProp("scrollMargin") || 5, w = s.dom.ownerDocument, E = l || s.dom; E; E = ee(E))
      if (E.nodeType == 1) {
        var L = E, F = L == w.body, $ = F ? wt(w) : Ut(L), Y = 0, ce = 0;
        if (h.top < $.top + Ot(d, "top") ? ce = -($.top - h.top + Ot(g, "top")) : h.bottom > $.bottom - Ot(d, "bottom") && (ce = h.bottom - h.top > $.bottom - $.top ? h.top + Ot(g, "top") - $.top : h.bottom - $.bottom + Ot(g, "bottom")), h.left < $.left + Ot(d, "left") ? Y = -($.left - h.left + Ot(g, "left")) : h.right > $.right - Ot(d, "right") && (Y = h.right - $.right + Ot(g, "right")), Y || ce)
          if (F)
            w.defaultView.scrollBy(Y, ce);
          else {
            var re = L.scrollLeft, ye = L.scrollTop;
            ce && (L.scrollTop += ce), Y && (L.scrollLeft += Y);
            var we = L.scrollLeft - re, qe = L.scrollTop - ye;
            h = {
              left: h.left - we,
              top: h.top - qe,
              right: h.right - we,
              bottom: h.bottom - qe
            };
          }
        if (F || /^(fixed|sticky)$/.test(getComputedStyle(E).position))
          break;
      }
  }
  function qr(s) {
    for (var h = s.dom.getBoundingClientRect(), l = Math.max(0, h.top), d, g, w = (h.left + h.right) / 2, E = l + 1; E < Math.min(innerHeight, h.bottom); E += 5) {
      var L = s.root.elementFromPoint(w, E);
      if (!(!L || L == s.dom || !s.dom.contains(L))) {
        var F = L.getBoundingClientRect();
        if (F.top >= l - 20) {
          d = L, g = F.top;
          break;
        }
      }
    }
    return {
      refDOM: d,
      refTop: g,
      stack: Jt(s.dom)
    };
  }
  function Jt(s) {
    for (var h = [], l = s.ownerDocument, d = s; d && (h.push({
      dom: d,
      top: d.scrollTop,
      left: d.scrollLeft
    }), s != l); d = ee(d))
      ;
    return h;
  }
  function _t(s) {
    var h = s.refDOM, l = s.refTop, d = s.stack, g = h ? h.getBoundingClientRect().top : 0;
    pr(d, g == 0 ? 0 : g - l);
  }
  function pr(s, h) {
    for (var l = 0; l < s.length; l++) {
      var d = s[l], g = d.dom, w = d.top, E = d.left;
      g.scrollTop != w + h && (g.scrollTop = w + h), g.scrollLeft != E && (g.scrollLeft = E);
    }
  }
  var hr = null;
  function Fr(s) {
    if (s.setActive)
      return s.setActive();
    if (hr)
      return s.focus(hr);
    var h = Jt(s);
    s.focus(hr == null ? {
      get preventScroll() {
        return hr = {
          preventScroll: !0
        }, !0;
      }
    } : void 0), hr || (hr = !1, pr(h, 0));
  }
  function _r(s, h) {
    for (var l, d = 2e8, g, w = 0, E = h.top, L = h.top, F, $, Y = s.firstChild, ce = 0; Y; Y = Y.nextSibling, ce++) {
      var re = void 0;
      if (Y.nodeType == 1)
        re = Y.getClientRects();
      else if (Y.nodeType == 3)
        re = ue(Y).getClientRects();
      else
        continue;
      for (var ye = 0; ye < re.length; ye++) {
        var we = re[ye];
        if (we.top <= E && we.bottom >= L) {
          E = Math.max(we.bottom, E), L = Math.min(we.top, L);
          var qe = we.left > h.left ? we.left - h.left : we.right < h.left ? h.left - we.right : 0;
          if (qe < d) {
            l = Y, d = qe, g = qe && l.nodeType == 3 ? {
              left: we.right < h.left ? we.right : we.left,
              top: h.top
            } : h, Y.nodeType == 1 && qe && (w = ce + (h.left >= (we.left + we.right) / 2 ? 1 : 0));
            continue;
          }
        } else
          we.top > h.top && !F && we.left <= h.left && we.right >= h.left && (F = Y, $ = {
            left: Math.max(we.left, Math.min(we.right, h.left)),
            top: we.top
          });
        !l && (h.left >= we.right && h.top >= we.top || h.left >= we.left && h.top >= we.bottom) && (w = ce + 1);
      }
    }
    return !l && F && (l = F, g = $, d = 0), l && l.nodeType == 3 ? He(l, g) : !l || d && l.nodeType == 1 ? {
      node: s,
      offset: w
    } : _r(l, g);
  }
  function He(s, h) {
    for (var l = s.nodeValue.length, d = document.createRange(), g = 0; g < l; g++) {
      d.setEnd(s, g + 1), d.setStart(s, g);
      var w = Zt(d, 1);
      if (w.top != w.bottom && _e(h, w))
        return {
          node: s,
          offset: g + (h.left >= (w.left + w.right) / 2 ? 1 : 0)
        };
    }
    return {
      node: s,
      offset: 0
    };
  }
  function _e(s, h) {
    return s.left >= h.left - 1 && s.left <= h.right + 1 && s.top >= h.top - 1 && s.top <= h.bottom + 1;
  }
  function Xe(s, h) {
    var l = s.parentNode;
    return l && /^li$/i.test(l.nodeName) && h.left < s.getBoundingClientRect().left ? l : s;
  }
  function st(s, h, l) {
    var d = _r(h, l), g = d.node, w = d.offset, E = -1;
    if (g.nodeType == 1 && !g.firstChild) {
      var L = g.getBoundingClientRect();
      E = L.left != L.right && l.left > (L.left + L.right) / 2 ? 1 : -1;
    }
    return s.docView.posFromDOM(g, w, E);
  }
  function Ct(s, h, l, d) {
    for (var g = -1, w = h, E = !1; w != s.dom; ) {
      var L = s.docView.nearestDesc(w, !0);
      if (!L)
        return null;
      if (L.dom.nodeType == 1 && (L.node.isBlock && L.parent && !E || !L.contentDOM)) {
        var F = L.dom.getBoundingClientRect();
        if (L.node.isBlock && L.parent && !E && (E = !0, F.left > d.left || F.top > d.top ? g = L.posBefore : (F.right < d.left || F.bottom < d.top) && (g = L.posAfter)), !L.contentDOM && g < 0 && !L.node.isText) {
          var $ = L.node.isBlock ? d.top < (F.top + F.bottom) / 2 : d.left < (F.left + F.right) / 2;
          return $ ? L.posBefore : L.posAfter;
        }
      }
      w = L.dom.parentNode;
    }
    return g > -1 ? g : s.docView.posFromDOM(h, l, -1);
  }
  function rr(s, h, l) {
    var d = s.childNodes.length;
    if (d && l.top < l.bottom)
      for (var g = Math.max(0, Math.min(d - 1, Math.floor(d * (h.top - l.top) / (l.bottom - l.top)) - 2)), w = g; ; ) {
        var E = s.childNodes[w];
        if (E.nodeType == 1)
          for (var L = E.getClientRects(), F = 0; F < L.length; F++) {
            var $ = L[F];
            if (_e(h, $))
              return rr(E, h, $);
          }
        if ((w = (w + 1) % d) == g)
          break;
      }
    return s;
  }
  function lr(s, h) {
    var l = s.dom.ownerDocument, d, g = 0, w = St(l, h.left, h.top);
    w && (d = w.node, g = w.offset);
    var E = (s.root.elementFromPoint ? s.root : l).elementFromPoint(h.left, h.top), L;
    if (!E || !s.dom.contains(E.nodeType != 1 ? E.parentNode : E)) {
      var F = s.dom.getBoundingClientRect();
      if (!_e(h, F) || (E = rr(s.dom, h, F), !E))
        return null;
    }
    if (ae)
      for (var $ = E; d && $; $ = ee($))
        $.draggable && (d = void 0);
    if (E = Xe(E, h), d) {
      if (Rt && d.nodeType == 1 && (g = Math.min(g, d.childNodes.length), g < d.childNodes.length)) {
        var Y = d.childNodes[g], ce;
        Y.nodeName == "IMG" && (ce = Y.getBoundingClientRect()).right <= h.left && ce.bottom > h.top && g++;
      }
      d == s.dom && g == d.childNodes.length - 1 && d.lastChild.nodeType == 1 && h.top > d.lastChild.getBoundingClientRect().bottom ? L = s.state.doc.content.size : (g == 0 || d.nodeType != 1 || d.childNodes[g - 1].nodeName != "BR") && (L = Ct(s, d, g, h));
    }
    L == null && (L = st(s, E, h));
    var re = s.docView.nearestDesc(E, !0);
    return {
      pos: L,
      inside: re ? re.posAtStart - re.border : -1
    };
  }
  function Yt(s) {
    return s.top < s.bottom || s.left < s.right;
  }
  function Zt(s, h) {
    var l = s.getClientRects();
    if (l.length) {
      var d = l[h < 0 ? 0 : l.length - 1];
      if (Yt(d))
        return d;
    }
    return Array.prototype.find.call(l, Yt) || s.getBoundingClientRect();
  }
  var Rr = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
  function Cr(s, h, l) {
    var d = s.docView.domFromPos(h, l < 0 ? -1 : 1), g = d.node, w = d.offset, E = d.atom, L = ft || Rt;
    if (g.nodeType == 3)
      if (L && (Rr.test(g.nodeValue) || (l < 0 ? !w : w == g.nodeValue.length))) {
        var F = Zt(ue(g, w, w), l);
        if (Rt && w && /\s/.test(g.nodeValue[w - 1]) && w < g.nodeValue.length) {
          var $ = Zt(ue(g, w - 1, w - 1), -1);
          if ($.top == F.top) {
            var Y = Zt(ue(g, w, w + 1), -1);
            if (Y.top != F.top)
              return Qt(Y, Y.left < $.left);
          }
        }
        return F;
      } else {
        var ce = w, re = w, ye = l < 0 ? 1 : -1;
        return l < 0 && !w ? (re++, ye = -1) : l >= 0 && w == g.nodeValue.length ? (ce--, ye = 1) : l < 0 ? ce-- : re++, Qt(Zt(ue(g, ce, re), ye), ye < 0);
      }
    var we = s.state.doc.resolve(h - (E || 0));
    if (!we.parent.inlineContent) {
      if (E == null && w && (l < 0 || w == Me(g))) {
        var qe = g.childNodes[w - 1];
        if (qe.nodeType == 1)
          return Hr(qe.getBoundingClientRect(), !1);
      }
      if (E == null && w < Me(g)) {
        var ot = g.childNodes[w];
        if (ot.nodeType == 1)
          return Hr(ot.getBoundingClientRect(), !0);
      }
      return Hr(g.getBoundingClientRect(), l >= 0);
    }
    if (E == null && w && (l < 0 || w == Me(g))) {
      var De = g.childNodes[w - 1], Dt = De.nodeType == 3 ? ue(De, Me(De) - (L ? 0 : 1)) : De.nodeType == 1 && (De.nodeName != "BR" || !De.nextSibling) ? De : null;
      if (Dt)
        return Qt(Zt(Dt, 1), !1);
    }
    if (E == null && w < Me(g)) {
      for (var mt = g.childNodes[w]; mt.pmViewDesc && mt.pmViewDesc.ignoreForCoords; )
        mt = mt.nextSibling;
      var Bt = mt ? mt.nodeType == 3 ? ue(mt, 0, L ? 0 : 1) : mt.nodeType == 1 ? mt : null : null;
      if (Bt)
        return Qt(Zt(Bt, -1), !0);
    }
    return Qt(Zt(g.nodeType == 3 ? ue(g) : g, -l), l >= 0);
  }
  function Qt(s, h) {
    if (s.width == 0)
      return s;
    var l = h ? s.left : s.right;
    return {
      top: s.top,
      bottom: s.bottom,
      left: l,
      right: l
    };
  }
  function Hr(s, h) {
    if (s.height == 0)
      return s;
    var l = h ? s.top : s.bottom;
    return {
      top: l,
      bottom: l,
      left: s.left,
      right: s.right
    };
  }
  function Tr(s, h, l) {
    var d = s.state, g = s.root.activeElement;
    d != h && s.updateState(h), g != s.dom && s.focus();
    try {
      return l();
    } finally {
      d != h && s.updateState(d), g != s.dom && g && g.focus();
    }
  }
  function nn(s, h, l) {
    var d = h.selection, g = l == "up" ? d.$from : d.$to;
    return Tr(s, h, function() {
      for (var w = s.docView.domFromPos(g.pos, l == "up" ? -1 : 1), E = w.node; ; ) {
        var L = s.docView.nearestDesc(E, !0);
        if (!L)
          break;
        if (L.node.isBlock) {
          E = L.contentDOM || L.dom;
          break;
        }
        E = L.dom.parentNode;
      }
      for (var F = Cr(s, g.pos, 1), $ = E.firstChild; $; $ = $.nextSibling) {
        var Y = void 0;
        if ($.nodeType == 1)
          Y = $.getClientRects();
        else if ($.nodeType == 3)
          Y = ue($, 0, $.nodeValue.length).getClientRects();
        else
          continue;
        for (var ce = 0; ce < Y.length; ce++) {
          var re = Y[ce];
          if (re.bottom > re.top + 1 && (l == "up" ? F.top - re.top > (re.bottom - F.top) * 2 : re.bottom - F.bottom > (F.bottom - re.top) * 2))
            return !1;
        }
      }
      return !0;
    });
  }
  var W = /[\u0590-\u08ac]/;
  function V(s, h, l) {
    var d = h.selection.$head;
    if (!d.parent.isTextblock)
      return !1;
    var g = d.parentOffset, w = !g, E = g == d.parent.content.size, L = s.domSelection();
    return !W.test(d.parent.textContent) || !L.modify ? l == "left" || l == "backward" ? w : E : Tr(s, h, function() {
      var F = s.domSelectionRange(), $ = F.focusNode, Y = F.focusOffset, ce = F.anchorNode, re = F.anchorOffset, ye = L.caretBidiLevel;
      L.modify("move", l, "character");
      var we = d.depth ? s.docView.domAfterPos(d.before()) : s.dom, qe = s.domSelectionRange(), ot = qe.focusNode, De = qe.focusOffset, Dt = ot && !we.contains(ot.nodeType == 1 ? ot : ot.parentNode) || $ == ot && Y == De;
      try {
        L.collapse(ce, re), $ && ($ != ce || Y != re) && L.extend && L.extend($, Y);
      } catch {
      }
      return ye != null && (L.caretBidiLevel = ye), Dt;
    });
  }
  var R = null, D = null, I = !1;
  function H(s, h, l) {
    return R == h && D == l ? I : (R = h, D = l, I = l == "up" || l == "down" ? nn(s, h, l) : V(s, h, l));
  }
  var J = 0, ve = 1, me = 2, be = 3, Oe = function() {
    function s(h, l, d, g) {
      M(this, s), this.parent = h, this.children = l, this.dom = d, this.contentDOM = g, this.dirty = J, d.pmViewDesc = this;
    }
    return q(s, [{
      key: "matchesWidget",
      value: function(l) {
        return !1;
      }
    }, {
      key: "matchesMark",
      value: function(l) {
        return !1;
      }
    }, {
      key: "matchesNode",
      value: function(l, d, g) {
        return !1;
      }
    }, {
      key: "matchesHack",
      value: function(l) {
        return !1;
      }
    }, {
      key: "parseRule",
      value: function() {
        return null;
      }
    }, {
      key: "stopEvent",
      value: function(l) {
        return !1;
      }
    }, {
      key: "size",
      get: function() {
        for (var l = 0, d = 0; d < this.children.length; d++)
          l += this.children[d].size;
        return l;
      }
    }, {
      key: "border",
      get: function() {
        return 0;
      }
    }, {
      key: "destroy",
      value: function() {
        this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
        for (var l = 0; l < this.children.length; l++)
          this.children[l].destroy();
      }
    }, {
      key: "posBeforeChild",
      value: function(l) {
        for (var d = 0, g = this.posAtStart; ; d++) {
          var w = this.children[d];
          if (w == l)
            return g;
          g += w.size;
        }
      }
    }, {
      key: "posBefore",
      get: function() {
        return this.parent.posBeforeChild(this);
      }
    }, {
      key: "posAtStart",
      get: function() {
        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
      }
    }, {
      key: "posAfter",
      get: function() {
        return this.posBefore + this.size;
      }
    }, {
      key: "posAtEnd",
      get: function() {
        return this.posAtStart + this.size - 2 * this.border;
      }
    }, {
      key: "localPosFromDOM",
      value: function(l, d, g) {
        if (this.contentDOM && this.contentDOM.contains(l.nodeType == 1 ? l : l.parentNode))
          if (g < 0) {
            var w, E;
            if (l == this.contentDOM)
              w = l.childNodes[d - 1];
            else {
              for (; l.parentNode != this.contentDOM; )
                l = l.parentNode;
              w = l.previousSibling;
            }
            for (; w && !((E = w.pmViewDesc) && E.parent == this); )
              w = w.previousSibling;
            return w ? this.posBeforeChild(E) + E.size : this.posAtStart;
          } else {
            var L, F;
            if (l == this.contentDOM)
              L = l.childNodes[d];
            else {
              for (; l.parentNode != this.contentDOM; )
                l = l.parentNode;
              L = l.nextSibling;
            }
            for (; L && !((F = L.pmViewDesc) && F.parent == this); )
              L = L.nextSibling;
            return L ? this.posBeforeChild(F) : this.posAtEnd;
          }
        var $;
        if (l == this.dom && this.contentDOM)
          $ = d > ie(this.contentDOM);
        else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
          $ = l.compareDocumentPosition(this.contentDOM) & 2;
        else if (this.dom.firstChild) {
          if (d == 0)
            for (var Y = l; ; Y = Y.parentNode) {
              if (Y == this.dom) {
                $ = !1;
                break;
              }
              if (Y.previousSibling)
                break;
            }
          if ($ == null && d == l.childNodes.length)
            for (var ce = l; ; ce = ce.parentNode) {
              if (ce == this.dom) {
                $ = !0;
                break;
              }
              if (ce.nextSibling)
                break;
            }
        }
        return $ ?? g > 0 ? this.posAtEnd : this.posAtStart;
      }
    }, {
      key: "nearestDesc",
      value: function(l) {
        for (var d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, g = !0, w = l; w; w = w.parentNode) {
          var E = this.getDesc(w), L = void 0;
          if (E && (!d || E.node))
            if (g && (L = E.nodeDOM) && !(L.nodeType == 1 ? L.contains(l.nodeType == 1 ? l : l.parentNode) : L == l))
              g = !1;
            else
              return E;
        }
      }
    }, {
      key: "getDesc",
      value: function(l) {
        for (var d = l.pmViewDesc, g = d; g; g = g.parent)
          if (g == this)
            return d;
      }
    }, {
      key: "posFromDOM",
      value: function(l, d, g) {
        for (var w = l; w; w = w.parentNode) {
          var E = this.getDesc(w);
          if (E)
            return E.localPosFromDOM(l, d, g);
        }
        return -1;
      }
    }, {
      key: "descAt",
      value: function(l) {
        for (var d = 0, g = 0; d < this.children.length; d++) {
          var w = this.children[d], E = g + w.size;
          if (g == l && E != g) {
            for (; !w.border && w.children.length; )
              w = w.children[0];
            return w;
          }
          if (l < E)
            return w.descAt(l - g - w.border);
          g = E;
        }
      }
    }, {
      key: "domFromPos",
      value: function(l, d) {
        if (!this.contentDOM)
          return {
            node: this.dom,
            offset: 0,
            atom: l + 1
          };
        for (var g = 0, w = 0, E = 0; g < this.children.length; g++) {
          var L = this.children[g], F = E + L.size;
          if (F > l || L instanceof Ee) {
            w = l - E;
            break;
          }
          E = F;
        }
        if (w)
          return this.children[g].domFromPos(w - this.children[g].border, d);
        for (var $; g && !($ = this.children[g - 1]).size && $ instanceof Ye && $.side >= 0; g--)
          ;
        if (d <= 0) {
          for (var Y, ce = !0; Y = g ? this.children[g - 1] : null, !(!Y || Y.dom.parentNode == this.contentDOM); g--, ce = !1)
            ;
          return Y && d && ce && !Y.border && !Y.domAtom ? Y.domFromPos(Y.size, d) : {
            node: this.contentDOM,
            offset: Y ? ie(Y.dom) + 1 : 0
          };
        } else {
          for (var re, ye = !0; re = g < this.children.length ? this.children[g] : null, !(!re || re.dom.parentNode == this.contentDOM); g++, ye = !1)
            ;
          return re && ye && !re.border && !re.domAtom ? re.domFromPos(0, d) : {
            node: this.contentDOM,
            offset: re ? ie(re.dom) : this.contentDOM.childNodes.length
          };
        }
      }
    }, {
      key: "parseRange",
      value: function(l, d) {
        var g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        if (this.children.length == 0)
          return {
            node: this.contentDOM,
            from: l,
            to: d,
            fromOffset: 0,
            toOffset: this.contentDOM.childNodes.length
          };
        for (var w = -1, E = -1, L = g, F = 0; ; F++) {
          var $ = this.children[F], Y = L + $.size;
          if (w == -1 && l <= Y) {
            var ce = L + $.border;
            if (l >= ce && d <= Y - $.border && $.node && $.contentDOM && this.contentDOM.contains($.contentDOM))
              return $.parseRange(l, d, ce);
            l = L;
            for (var re = F; re > 0; re--) {
              var ye = this.children[re - 1];
              if (ye.size && ye.dom.parentNode == this.contentDOM && !ye.emptyChildAt(1)) {
                w = ie(ye.dom) + 1;
                break;
              }
              l -= ye.size;
            }
            w == -1 && (w = 0);
          }
          if (w > -1 && (Y > d || F == this.children.length - 1)) {
            d = Y;
            for (var we = F + 1; we < this.children.length; we++) {
              var qe = this.children[we];
              if (qe.size && qe.dom.parentNode == this.contentDOM && !qe.emptyChildAt(-1)) {
                E = ie(qe.dom);
                break;
              }
              d += qe.size;
            }
            E == -1 && (E = this.contentDOM.childNodes.length);
            break;
          }
          L = Y;
        }
        return {
          node: this.contentDOM,
          from: l,
          to: d,
          fromOffset: w,
          toOffset: E
        };
      }
    }, {
      key: "emptyChildAt",
      value: function(l) {
        if (this.border || !this.contentDOM || !this.children.length)
          return !1;
        var d = this.children[l < 0 ? 0 : this.children.length - 1];
        return d.size == 0 || d.emptyChildAt(l);
      }
    }, {
      key: "domAfterPos",
      value: function(l) {
        var d = this.domFromPos(l, 0), g = d.node, w = d.offset;
        if (g.nodeType != 1 || w == g.childNodes.length)
          throw new RangeError("No node after pos " + l);
        return g.childNodes[w];
      }
    }, {
      key: "setSelection",
      value: function(l, d, g) {
        for (var w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, E = Math.min(l, d), L = Math.max(l, d), F = 0, $ = 0; F < this.children.length; F++) {
          var Y = this.children[F], ce = $ + Y.size;
          if (E > $ && L < ce)
            return Y.setSelection(l - $ - Y.border, d - $ - Y.border, g, w);
          $ = ce;
        }
        var re = this.domFromPos(l, l ? -1 : 1), ye = d == l ? re : this.domFromPos(d, d ? -1 : 1), we = g.getSelection(), qe = !1;
        if ((Rt || ae) && l == d) {
          var ot = re, De = ot.node, Dt = ot.offset;
          if (De.nodeType == 3) {
            if (qe = !!(Dt && De.nodeValue[Dt - 1] == `
`), qe && Dt == De.nodeValue.length)
              for (var mt = De, Bt; mt; mt = mt.parentNode) {
                if (Bt = mt.nextSibling) {
                  Bt.nodeName == "BR" && (re = ye = {
                    node: Bt.parentNode,
                    offset: ie(Bt) + 1
                  });
                  break;
                }
                var bt = mt.pmViewDesc;
                if (bt && bt.node && bt.node.isBlock)
                  break;
              }
          } else {
            var kt = De.childNodes[Dt - 1];
            qe = kt && (kt.nodeName == "BR" || kt.contentEditable == "false");
          }
        }
        if (Rt && we.focusNode && we.focusNode != ye.node && we.focusNode.nodeType == 1) {
          var Vt = we.focusNode.childNodes[we.focusOffset];
          Vt && Vt.contentEditable == "false" && (w = !0);
        }
        if (!(!(w || qe && ae) && pe(re.node, re.offset, we.anchorNode, we.anchorOffset) && pe(ye.node, ye.offset, we.focusNode, we.focusOffset))) {
          var Ir = !1;
          if ((we.extend || l == d) && !qe) {
            we.collapse(re.node, re.offset);
            try {
              l != d && we.extend(ye.node, ye.offset), Ir = !0;
            } catch {
            }
          }
          if (!Ir) {
            if (l > d) {
              var Jr = re;
              re = ye, ye = Jr;
            }
            var ur = document.createRange();
            ur.setEnd(ye.node, ye.offset), ur.setStart(re.node, re.offset), we.removeAllRanges(), we.addRange(ur);
          }
        }
      }
    }, {
      key: "ignoreMutation",
      value: function(l) {
        return !this.contentDOM && l.type != "selection";
      }
    }, {
      key: "contentLost",
      get: function() {
        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
      }
    }, {
      key: "markDirty",
      value: function(l, d) {
        for (var g = 0, w = 0; w < this.children.length; w++) {
          var E = this.children[w], L = g + E.size;
          if (g == L ? l <= L && d >= g : l < L && d > g) {
            var F = g + E.border, $ = L - E.border;
            if (l >= F && d <= $) {
              this.dirty = l == g || d == L ? me : ve, l == F && d == $ && (E.contentLost || E.dom.parentNode != this.contentDOM) ? E.dirty = be : E.markDirty(l - F, d - F);
              return;
            } else
              E.dirty = E.dom == E.contentDOM && E.dom.parentNode == this.contentDOM && !E.children.length ? me : be;
          }
          g = L;
        }
        this.dirty = me;
      }
    }, {
      key: "markParentsDirty",
      value: function() {
        for (var l = 1, d = this.parent; d; d = d.parent, l++) {
          var g = l == 1 ? me : ve;
          d.dirty < g && (d.dirty = g);
        }
      }
    }, {
      key: "domAtom",
      get: function() {
        return !1;
      }
    }, {
      key: "ignoreForCoords",
      get: function() {
        return !1;
      }
    }]), s;
  }(), Ye = function(s) {
    o(l, s);
    var h = m(l);
    function l(d, g, w, E) {
      var L;
      M(this, l);
      var F, $ = g.type.toDOM;
      if (typeof $ == "function" && ($ = $(w, function() {
        if (!F)
          return E;
        if (F.parent)
          return F.parent.posBeforeChild(F);
      })), !g.type.spec.raw) {
        if ($.nodeType != 1) {
          var Y = document.createElement("span");
          Y.appendChild($), $ = Y;
        }
        $.contentEditable = "false", $.classList.add("ProseMirror-widget");
      }
      return L = h.call(this, d, [], $, null), L.widget = g, L.widget = g, F = C(L), L;
    }
    return q(l, [{
      key: "matchesWidget",
      value: function(g) {
        return this.dirty == J && g.type.eq(this.widget.type);
      }
    }, {
      key: "parseRule",
      value: function() {
        return {
          ignore: !0
        };
      }
    }, {
      key: "stopEvent",
      value: function(g) {
        var w = this.widget.spec.stopEvent;
        return w ? w(g) : !1;
      }
    }, {
      key: "ignoreMutation",
      value: function(g) {
        return g.type != "selection" || this.widget.spec.ignoreSelection;
      }
    }, {
      key: "destroy",
      value: function() {
        this.widget.type.destroy(this.dom), a(x(l.prototype), "destroy", this).call(this);
      }
    }, {
      key: "domAtom",
      get: function() {
        return !0;
      }
    }, {
      key: "side",
      get: function() {
        return this.widget.type.side;
      }
    }]), l;
  }(Oe), We = function(s) {
    o(l, s);
    var h = m(l);
    function l(d, g, w, E) {
      var L;
      return M(this, l), L = h.call(this, d, [], g, null), L.textDOM = w, L.text = E, L;
    }
    return q(l, [{
      key: "size",
      get: function() {
        return this.text.length;
      }
    }, {
      key: "localPosFromDOM",
      value: function(g, w) {
        return g != this.textDOM ? this.posAtStart + (w ? this.size : 0) : this.posAtStart + w;
      }
    }, {
      key: "domFromPos",
      value: function(g) {
        return {
          node: this.textDOM,
          offset: g
        };
      }
    }, {
      key: "ignoreMutation",
      value: function(g) {
        return g.type === "characterData" && g.target.nodeValue == g.oldValue;
      }
    }]), l;
  }(Oe), ut = function(s) {
    o(l, s);
    var h = m(l);
    function l(d, g, w, E) {
      var L;
      return M(this, l), L = h.call(this, d, [], w, E), L.mark = g, L;
    }
    return q(l, [{
      key: "parseRule",
      value: function() {
        return this.dirty & be || this.mark.type.spec.reparseInView ? null : {
          mark: this.mark.type.name,
          attrs: this.mark.attrs,
          contentElement: this.contentDOM
        };
      }
    }, {
      key: "matchesMark",
      value: function(g) {
        return this.dirty != be && this.mark.eq(g);
      }
    }, {
      key: "markDirty",
      value: function(g, w) {
        if (a(x(l.prototype), "markDirty", this).call(this, g, w), this.dirty != J) {
          for (var E = this.parent; !E.node; )
            E = E.parent;
          E.dirty < this.dirty && (E.dirty = this.dirty), this.dirty = J;
        }
      }
    }, {
      key: "slice",
      value: function(g, w, E) {
        var L = l.create(this.parent, this.mark, !0, E), F = this.children, $ = this.size;
        w < $ && (F = Ur(F, w, $, E)), g > 0 && (F = Ur(F, 0, g, E));
        for (var Y = 0; Y < F.length; Y++)
          F[Y].parent = L;
        return L.children = F, L;
      }
    }], [{
      key: "create",
      value: function(g, w, E, L) {
        var F = L.nodeViews[w.type.name], $ = F && F(w, L, E);
        return (!$ || !$.dom) && ($ = K.DOMSerializer.renderSpec(document, w.type.spec.toDOM(w, E))), new l(g, w, $.dom, $.contentDOM || $.dom);
      }
    }]), l;
  }(Oe), ct = function(s) {
    o(l, s);
    var h = m(l);
    function l(d, g, w, E, L, F, $, Y, ce) {
      var re;
      return M(this, l), re = h.call(this, d, [], L, F), re.node = g, re.outerDeco = w, re.innerDeco = E, re.nodeDOM = $, re;
    }
    return q(l, [{
      key: "parseRule",
      value: function() {
        var g = this;
        if (this.node.type.spec.reparseInView)
          return null;
        var w = {
          node: this.node.type.name,
          attrs: this.node.attrs
        };
        if (this.node.type.whitespace == "pre" && (w.preserveWhitespace = "full"), !this.contentDOM)
          w.getContent = function() {
            return g.node.content;
          };
        else if (!this.contentLost)
          w.contentElement = this.contentDOM;
        else {
          for (var E = this.children.length - 1; E >= 0; E--) {
            var L = this.children[E];
            if (this.dom.contains(L.dom.parentNode)) {
              w.contentElement = L.dom.parentNode;
              break;
            }
          }
          w.contentElement || (w.getContent = function() {
            return K.Fragment.empty;
          });
        }
        return w;
      }
    }, {
      key: "matchesNode",
      value: function(g, w, E) {
        return this.dirty == J && g.eq(this.node) && fe(w, this.outerDeco) && E.eq(this.innerDeco);
      }
    }, {
      key: "size",
      get: function() {
        return this.node.nodeSize;
      }
    }, {
      key: "border",
      get: function() {
        return this.node.isLeaf ? 0 : 1;
      }
    }, {
      key: "updateChildren",
      value: function(g, w) {
        var E = this, L = this.node.inlineContent, F = w, $ = g.composing ? this.localCompositionInfo(g, w) : null, Y = $ && $.pos > -1 ? $ : null, ce = $ && $.pos < 0, re = new Ie(this, Y && Y.node, g);
        it(this.node, this.innerDeco, function(ye, we, qe) {
          ye.spec.marks ? re.syncToMarks(ye.spec.marks, L, g) : ye.type.side >= 0 && !qe && re.syncToMarks(we == E.node.childCount ? K.Mark.none : E.node.child(we).marks, L, g), re.placeWidget(ye, g, F);
        }, function(ye, we, qe, ot) {
          re.syncToMarks(ye.marks, L, g);
          var De;
          re.findNodeMatch(ye, we, qe, ot) || ce && g.state.selection.from > F && g.state.selection.to < F + ye.nodeSize && (De = re.findIndexWithChild($.node)) > -1 && re.updateNodeAt(ye, we, qe, De, g) || re.updateNextNode(ye, we, qe, g, ot, F) || re.addNode(ye, we, qe, g, F), F += ye.nodeSize;
        }), re.syncToMarks([], L, g), this.node.isTextblock && re.addTextblockHacks(), re.destroyRest(), (re.changed || this.dirty == me) && (Y && this.protectLocalComposition(g, Y), S(this.contentDOM, this.children, g), Z && Ht(this.dom));
      }
    }, {
      key: "localCompositionInfo",
      value: function(g, w) {
        var E = g.state.selection, L = E.from, F = E.to;
        if (!(g.state.selection instanceof _.TextSelection) || L < w || F > w + this.node.content.size)
          return null;
        var $ = g.domSelectionRange(), Y = nr($.focusNode, $.focusOffset);
        if (!Y || !this.dom.contains(Y.parentNode))
          return null;
        if (this.node.inlineContent) {
          var ce = Y.nodeValue, re = Mr(this.node.content, ce, L - w, F - w);
          return re < 0 ? null : {
            node: Y,
            pos: re,
            text: ce
          };
        } else
          return {
            node: Y,
            pos: -1,
            text: ""
          };
      }
    }, {
      key: "protectLocalComposition",
      value: function(g, w) {
        var E = w.node, L = w.pos, F = w.text;
        if (!this.getDesc(E)) {
          for (var $ = E; $.parentNode != this.contentDOM; $ = $.parentNode) {
            for (; $.previousSibling; )
              $.parentNode.removeChild($.previousSibling);
            for (; $.nextSibling; )
              $.parentNode.removeChild($.nextSibling);
            $.pmViewDesc && ($.pmViewDesc = void 0);
          }
          var Y = new We(this, $, E, F);
          g.input.compositionNodes.push(Y), this.children = Ur(this.children, L, L + F.length, g, Y);
        }
      }
    }, {
      key: "update",
      value: function(g, w, E, L) {
        return this.dirty == be || !g.sameMarkup(this.node) ? !1 : (this.updateInner(g, w, E, L), !0);
      }
    }, {
      key: "updateInner",
      value: function(g, w, E, L) {
        this.updateOuterDeco(w), this.node = g, this.innerDeco = E, this.contentDOM && this.updateChildren(L, this.posAtStart), this.dirty = J;
      }
    }, {
      key: "updateOuterDeco",
      value: function(g) {
        if (!fe(g, this.outerDeco)) {
          var w = this.nodeDOM.nodeType != 1, E = this.dom;
          this.dom = B(this.dom, this.nodeDOM, A(this.outerDeco, this.node, w), A(g, this.node, w)), this.dom != E && (E.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = g;
        }
      }
    }, {
      key: "selectNode",
      value: function() {
        this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
      }
    }, {
      key: "deselectNode",
      value: function() {
        this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable");
      }
    }, {
      key: "domAtom",
      get: function() {
        return this.node.isAtom;
      }
    }], [{
      key: "create",
      value: function(g, w, E, L, F, $) {
        var Y = F.nodeViews[w.type.name], ce, re = Y && Y(w, F, function() {
          if (!ce)
            return $;
          if (ce.parent)
            return ce.parent.posBeforeChild(ce);
        }, E, L), ye = re && re.dom, we = re && re.contentDOM;
        if (w.isText) {
          if (!ye)
            ye = document.createTextNode(w.text);
          else if (ye.nodeType != 3)
            throw new RangeError("Text must be rendered as a DOM text node");
        } else if (!ye) {
          var qe = K.DOMSerializer.renderSpec(document, w.type.spec.toDOM(w));
          ye = qe.dom, we = qe.contentDOM;
        }
        !we && !w.isText && ye.nodeName != "BR" && (ye.hasAttribute("contenteditable") || (ye.contentEditable = "false"), w.type.spec.draggable && (ye.draggable = !0));
        var ot = ye;
        return ye = G(ye, E, w), re ? ce = new N(g, w, E, L, ye, we || null, ot, re, F, $ + 1) : w.isText ? new ne(g, w, E, L, ye, ot, F) : new l(g, w, E, L, ye, we || null, ot);
      }
    }]), l;
  }(Oe);
  function Ae(s, h, l, d, g) {
    G(d, h, s);
    var w = new ct(void 0, s, h, l, d, d, d, g, 0);
    return w.contentDOM && w.updateChildren(g, 0), w;
  }
  var ne = function(s) {
    o(l, s);
    var h = m(l);
    function l(d, g, w, E, L, F, $) {
      return M(this, l), h.call(this, d, g, w, E, L, null, F, $, 0);
    }
    return q(l, [{
      key: "parseRule",
      value: function() {
        for (var g = this.nodeDOM.parentNode; g && g != this.dom && !g.pmIsDeco; )
          g = g.parentNode;
        return {
          skip: g || !0
        };
      }
    }, {
      key: "update",
      value: function(g, w, E, L) {
        return this.dirty == be || this.dirty != J && !this.inParent() || !g.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(w), (this.dirty != J || g.text != this.node.text) && g.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = g.text, L.trackWrites == this.nodeDOM && (L.trackWrites = null)), this.node = g, this.dirty = J, !0);
      }
    }, {
      key: "inParent",
      value: function() {
        for (var g = this.parent.contentDOM, w = this.nodeDOM; w; w = w.parentNode)
          if (w == g)
            return !0;
        return !1;
      }
    }, {
      key: "domFromPos",
      value: function(g) {
        return {
          node: this.nodeDOM,
          offset: g
        };
      }
    }, {
      key: "localPosFromDOM",
      value: function(g, w, E) {
        return g == this.nodeDOM ? this.posAtStart + Math.min(w, this.node.text.length) : a(x(l.prototype), "localPosFromDOM", this).call(this, g, w, E);
      }
    }, {
      key: "ignoreMutation",
      value: function(g) {
        return g.type != "characterData" && g.type != "selection";
      }
    }, {
      key: "slice",
      value: function(g, w, E) {
        var L = this.node.cut(g, w), F = document.createTextNode(L.text);
        return new l(this.parent, L, this.outerDeco, this.innerDeco, F, F, E);
      }
    }, {
      key: "markDirty",
      value: function(g, w) {
        a(x(l.prototype), "markDirty", this).call(this, g, w), this.dom != this.nodeDOM && (g == 0 || w == this.nodeDOM.nodeValue.length) && (this.dirty = be);
      }
    }, {
      key: "domAtom",
      get: function() {
        return !1;
      }
    }]), l;
  }(ct), Ee = function(s) {
    o(l, s);
    var h = m(l);
    function l() {
      return M(this, l), h.apply(this, arguments);
    }
    return q(l, [{
      key: "parseRule",
      value: function() {
        return {
          ignore: !0
        };
      }
    }, {
      key: "matchesHack",
      value: function(g) {
        return this.dirty == J && this.dom.nodeName == g;
      }
    }, {
      key: "domAtom",
      get: function() {
        return !0;
      }
    }, {
      key: "ignoreForCoords",
      get: function() {
        return this.dom.nodeName == "IMG";
      }
    }]), l;
  }(Oe), N = function(s) {
    o(l, s);
    var h = m(l);
    function l(d, g, w, E, L, F, $, Y, ce, re) {
      var ye;
      return M(this, l), ye = h.call(this, d, g, w, E, L, F, $, ce, re), ye.spec = Y, ye;
    }
    return q(l, [{
      key: "update",
      value: function(g, w, E, L) {
        if (this.dirty == be)
          return !1;
        if (this.spec.update) {
          var F = this.spec.update(g, w, E);
          return F && this.updateInner(g, w, E, L), F;
        } else
          return !this.contentDOM && !g.isLeaf ? !1 : a(x(l.prototype), "update", this).call(this, g, w, E, L);
      }
    }, {
      key: "selectNode",
      value: function() {
        this.spec.selectNode ? this.spec.selectNode() : a(x(l.prototype), "selectNode", this).call(this);
      }
    }, {
      key: "deselectNode",
      value: function() {
        this.spec.deselectNode ? this.spec.deselectNode() : a(x(l.prototype), "deselectNode", this).call(this);
      }
    }, {
      key: "setSelection",
      value: function(g, w, E, L) {
        this.spec.setSelection ? this.spec.setSelection(g, w, E) : a(x(l.prototype), "setSelection", this).call(this, g, w, E, L);
      }
    }, {
      key: "destroy",
      value: function() {
        this.spec.destroy && this.spec.destroy(), a(x(l.prototype), "destroy", this).call(this);
      }
    }, {
      key: "stopEvent",
      value: function(g) {
        return this.spec.stopEvent ? this.spec.stopEvent(g) : !1;
      }
    }, {
      key: "ignoreMutation",
      value: function(g) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(g) : a(x(l.prototype), "ignoreMutation", this).call(this, g);
      }
    }]), l;
  }(ct);
  function S(s, h, l) {
    for (var d = s.firstChild, g = !1, w = 0; w < h.length; w++) {
      var E = h[w], L = E.dom;
      if (L.parentNode == s) {
        for (; L != d; )
          d = Ce(d), g = !0;
        d = d.nextSibling;
      } else
        g = !0, s.insertBefore(L, d);
      if (E instanceof ut) {
        var F = d ? d.previousSibling : s.lastChild;
        S(E.contentDOM, E.children, l), d = F ? F.nextSibling : s.firstChild;
      }
    }
    for (; d; )
      d = Ce(d), g = !0;
    g && l.trackWrites == s && (l.trackWrites = null);
  }
  var v = function(h) {
    h && (this.nodeName = h);
  };
  v.prototype = /* @__PURE__ */ Object.create(null);
  var b = [new v()];
  function A(s, h, l) {
    if (s.length == 0)
      return b;
    for (var d = l ? b[0] : new v(), g = [d], w = 0; w < s.length; w++) {
      var E = s[w].type.attrs;
      if (E) {
        E.nodeName && g.push(d = new v(E.nodeName));
        for (var L in E) {
          var F = E[L];
          F != null && (l && g.length == 1 && g.push(d = new v(h.isInline ? "span" : "div")), L == "class" ? d.class = (d.class ? d.class + " " : "") + F : L == "style" ? d.style = (d.style ? d.style + ";" : "") + F : L != "nodeName" && (d[L] = F));
        }
      }
    }
    return g;
  }
  function B(s, h, l, d) {
    if (l == b && d == b)
      return h;
    for (var g = h, w = 0; w < d.length; w++) {
      var E = d[w], L = l[w];
      if (w) {
        var F = void 0;
        L && L.nodeName == E.nodeName && g != s && (F = g.parentNode) && F.nodeName.toLowerCase() == E.nodeName || (F = document.createElement(E.nodeName), F.pmIsDeco = !0, F.appendChild(g), L = b[0]), g = F;
      }
      z(g, L || b[0], E);
    }
    return g;
  }
  function z(s, h, l) {
    for (var d in h)
      d != "class" && d != "style" && d != "nodeName" && !(d in l) && s.removeAttribute(d);
    for (var g in l)
      g != "class" && g != "style" && g != "nodeName" && l[g] != h[g] && s.setAttribute(g, l[g]);
    if (h.class != l.class) {
      for (var w = h.class ? h.class.split(" ").filter(Boolean) : [], E = l.class ? l.class.split(" ").filter(Boolean) : [], L = 0; L < w.length; L++)
        E.indexOf(w[L]) == -1 && s.classList.remove(w[L]);
      for (var F = 0; F < E.length; F++)
        w.indexOf(E[F]) == -1 && s.classList.add(E[F]);
      s.classList.length == 0 && s.removeAttribute("class");
    }
    if (h.style != l.style) {
      if (h.style)
        for (var $ = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, Y; Y = $.exec(h.style); )
          s.style.removeProperty(Y[1]);
      l.style && (s.style.cssText += l.style);
    }
  }
  function G(s, h, l) {
    return B(s, s, b, A(h, l, s.nodeType != 1));
  }
  function fe(s, h) {
    if (s.length != h.length)
      return !1;
    for (var l = 0; l < s.length; l++)
      if (!s[l].type.eq(h[l].type))
        return !1;
    return !0;
  }
  function Ce(s) {
    var h = s.nextSibling;
    return s.parentNode.removeChild(s), h;
  }
  var Ie = function() {
    function s(h, l, d) {
      M(this, s), this.lock = l, this.view = d, this.index = 0, this.stack = [], this.changed = !1, this.top = h, this.preMatch = Le(h.node.content, h);
    }
    return q(s, [{
      key: "destroyBetween",
      value: function(l, d) {
        if (l != d) {
          for (var g = l; g < d; g++)
            this.top.children[g].destroy();
          this.top.children.splice(l, d - l), this.changed = !0;
        }
      }
    }, {
      key: "destroyRest",
      value: function() {
        this.destroyBetween(this.index, this.top.children.length);
      }
    }, {
      key: "syncToMarks",
      value: function(l, d, g) {
        for (var w = 0, E = this.stack.length >> 1, L = Math.min(E, l.length); w < L && (w == E - 1 ? this.top : this.stack[w + 1 << 1]).matchesMark(l[w]) && l[w].type.spec.spanning !== !1; )
          w++;
        for (; w < E; )
          this.destroyRest(), this.top.dirty = J, this.index = this.stack.pop(), this.top = this.stack.pop(), E--;
        for (; E < l.length; ) {
          this.stack.push(this.top, this.index + 1);
          for (var F = -1, $ = this.index; $ < Math.min(this.index + 3, this.top.children.length); $++) {
            var Y = this.top.children[$];
            if (Y.matchesMark(l[E]) && !this.isLocked(Y.dom)) {
              F = $;
              break;
            }
          }
          if (F > -1)
            F > this.index && (this.changed = !0, this.destroyBetween(this.index, F)), this.top = this.top.children[this.index];
          else {
            var ce = ut.create(this.top, l[E], d, g);
            this.top.children.splice(this.index, 0, ce), this.top = ce, this.changed = !0;
          }
          this.index = 0, E++;
        }
      }
    }, {
      key: "findNodeMatch",
      value: function(l, d, g, w) {
        var E = -1, L;
        if (w >= this.preMatch.index && (L = this.preMatch.matches[w - this.preMatch.index]).parent == this.top && L.matchesNode(l, d, g))
          E = this.top.children.indexOf(L, this.index);
        else
          for (var F = this.index, $ = Math.min(this.top.children.length, F + 5); F < $; F++) {
            var Y = this.top.children[F];
            if (Y.matchesNode(l, d, g) && !this.preMatch.matched.has(Y)) {
              E = F;
              break;
            }
          }
        return E < 0 ? !1 : (this.destroyBetween(this.index, E), this.index++, !0);
      }
    }, {
      key: "updateNodeAt",
      value: function(l, d, g, w, E) {
        var L = this.top.children[w];
        return L.dirty == be && L.dom == L.contentDOM && (L.dirty = me), L.update(l, d, g, E) ? (this.destroyBetween(this.index, w), this.index++, !0) : !1;
      }
    }, {
      key: "findIndexWithChild",
      value: function(l) {
        for (; ; ) {
          var d = l.parentNode;
          if (!d)
            return -1;
          if (d == this.top.contentDOM) {
            var g = l.pmViewDesc;
            if (g) {
              for (var w = this.index; w < this.top.children.length; w++)
                if (this.top.children[w] == g)
                  return w;
            }
            return -1;
          }
          l = d;
        }
      }
    }, {
      key: "updateNextNode",
      value: function(l, d, g, w, E, L) {
        for (var F = this.index; F < this.top.children.length; F++) {
          var $ = this.top.children[F];
          if ($ instanceof ct) {
            var Y = this.preMatch.matched.get($);
            if (Y != null && Y != E)
              return !1;
            var ce = $.dom, re = void 0, ye = this.isLocked(ce) && !(l.isText && $.node && $.node.isText && $.nodeDOM.nodeValue == l.text && $.dirty != be && fe(d, $.outerDeco));
            if (!ye && $.update(l, d, g, w))
              return this.destroyBetween(this.index, F), $.dom != ce && (this.changed = !0), this.index++, !0;
            if (!ye && (re = this.recreateWrapper($, l, d, g, w, L)))
              return this.top.children[this.index] = re, re.dirty = me, re.updateChildren(w, L + 1), re.dirty = J, this.changed = !0, this.index++, !0;
            break;
          }
        }
        return !1;
      }
    }, {
      key: "recreateWrapper",
      value: function(l, d, g, w, E, L) {
        if (l.dirty || d.isAtom || !l.children.length || !l.node.content.eq(d.content))
          return null;
        var F = ct.create(this.top, d, g, w, E, L);
        if (!F.contentDOM)
          return null;
        F.children = l.children, l.children = [], l.destroy();
        var $ = e(F.children), Y;
        try {
          for ($.s(); !(Y = $.n()).done; ) {
            var ce = Y.value;
            ce.parent = F;
          }
        } catch (re) {
          $.e(re);
        } finally {
          $.f();
        }
        return F;
      }
    }, {
      key: "addNode",
      value: function(l, d, g, w, E) {
        var L = ct.create(this.top, l, d, g, w, E);
        L.contentDOM && L.updateChildren(w, E + 1), this.top.children.splice(this.index++, 0, L), this.changed = !0;
      }
    }, {
      key: "placeWidget",
      value: function(l, d, g) {
        var w = this.index < this.top.children.length ? this.top.children[this.index] : null;
        if (w && w.matchesWidget(l) && (l == w.widget || !w.widget.type.toDOM.parentNode))
          this.index++;
        else {
          var E = new Ye(this.top, l, d, g);
          this.top.children.splice(this.index++, 0, E), this.changed = !0;
        }
      }
    }, {
      key: "addTextblockHacks",
      value: function() {
        for (var l = this.top.children[this.index - 1], d = this.top; l instanceof ut; )
          d = l, l = d.children[d.children.length - 1];
        (!l || !(l instanceof ne) || /\n$/.test(l.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(l.node.text)) && ((ae || le) && l && l.dom.contentEditable == "false" && this.addHackNode("IMG", d), this.addHackNode("BR", this.top));
      }
    }, {
      key: "addHackNode",
      value: function(l, d) {
        if (d == this.top && this.index < d.children.length && d.children[this.index].matchesHack(l))
          this.index++;
        else {
          var g = document.createElement(l);
          l == "IMG" && (g.className = "ProseMirror-separator", g.alt = ""), l == "BR" && (g.className = "ProseMirror-trailingBreak");
          var w = new Ee(this.top, [], g, null);
          d != this.top ? d.children.push(w) : d.children.splice(this.index++, 0, w), this.changed = !0;
        }
      }
    }, {
      key: "isLocked",
      value: function(l) {
        return this.lock && (l == this.lock || l.nodeType == 1 && l.contains(this.lock.parentNode));
      }
    }]), s;
  }();
  function Le(s, h) {
    var l = h, d = l.children.length, g = s.childCount, w = /* @__PURE__ */ new Map(), E = [];
    e:
      for (; g > 0; ) {
        for (var L = void 0; ; )
          if (d) {
            var F = l.children[d - 1];
            if (F instanceof ut)
              l = F, d = F.children.length;
            else {
              L = F, d--;
              break;
            }
          } else {
            if (l == h)
              break e;
            d = l.parent.children.indexOf(l), l = l.parent;
          }
        var $ = L.node;
        if ($) {
          if ($ != s.child(g - 1))
            break;
          --g, w.set(L, g), E.push(L);
        }
      }
    return {
      index: g,
      matched: w,
      matches: E.reverse()
    };
  }
  function Fe(s, h) {
    return s.type.side - h.type.side;
  }
  function it(s, h, l, d) {
    var g = h.locals(s), w = 0;
    if (g.length == 0) {
      for (var E = 0; E < s.childCount; E++) {
        var L = s.child(E);
        d(L, g, h.forChild(w, L), E), w += L.nodeSize;
      }
      return;
    }
    for (var F = 0, $ = [], Y = null, ce = 0; ; ) {
      if (F < g.length && g[F].to == w) {
        for (var re = g[F++], ye = void 0; F < g.length && g[F].to == w; )
          (ye || (ye = [re])).push(g[F++]);
        if (ye) {
          ye.sort(Fe);
          for (var we = 0; we < ye.length; we++)
            l(ye[we], ce, !!Y);
        } else
          l(re, ce, !!Y);
      }
      var qe = void 0, ot = void 0;
      if (Y)
        ot = -1, qe = Y, Y = null;
      else if (ce < s.childCount)
        ot = ce, qe = s.child(ce++);
      else
        break;
      for (var De = 0; De < $.length; De++)
        $[De].to <= w && $.splice(De--, 1);
      for (; F < g.length && g[F].from <= w && g[F].to > w; )
        $.push(g[F++]);
      var Dt = w + qe.nodeSize;
      if (qe.isText) {
        var mt = Dt;
        F < g.length && g[F].from < mt && (mt = g[F].from);
        for (var Bt = 0; Bt < $.length; Bt++)
          $[Bt].to < mt && (mt = $[Bt].to);
        mt < Dt && (Y = qe.cut(mt - w), qe = qe.cut(0, mt - w), Dt = mt, ot = -1);
      }
      var bt = qe.isInline && !qe.isLeaf ? $.filter(function(kt) {
        return !kt.inline;
      }) : $.slice();
      d(qe, bt, h.forChild(w, qe), ot), w = Dt;
    }
  }
  function Ht(s) {
    if (s.nodeName == "UL" || s.nodeName == "OL") {
      var h = s.style.cssText;
      s.style.cssText = h + "; list-style: square !important", window.getComputedStyle(s).listStyle, s.style.cssText = h;
    }
  }
  function nr(s, h) {
    for (; ; ) {
      if (s.nodeType == 3)
        return s;
      if (s.nodeType == 1 && h > 0) {
        if (s.childNodes.length > h && s.childNodes[h].nodeType == 3)
          return s.childNodes[h];
        s = s.childNodes[h - 1], h = Me(s);
      } else if (s.nodeType == 1 && h < s.childNodes.length)
        s = s.childNodes[h], h = 0;
      else
        return null;
    }
  }
  function Mr(s, h, l, d) {
    for (var g = 0, w = 0; g < s.childCount && w <= d; ) {
      var E = s.child(g++), L = w;
      if (w += E.nodeSize, !!E.isText) {
        for (var F = E.text; g < s.childCount; ) {
          var $ = s.child(g++);
          if (w += $.nodeSize, !$.isText)
            break;
          F += $.text;
        }
        if (w >= l) {
          var Y = L < d ? F.lastIndexOf(h, d - L - 1) : -1;
          if (Y >= 0 && Y + h.length + L >= l)
            return L + Y;
          if (l == d && F.length >= d + h.length - L && F.slice(d - L, d - L + h.length) == h)
            return d;
        }
      }
    }
    return -1;
  }
  function Ur(s, h, l, d, g) {
    for (var w = [], E = 0, L = 0; E < s.length; E++) {
      var F = s[E], $ = L, Y = L += F.size;
      $ >= l || Y <= h ? w.push(F) : ($ < h && w.push(F.slice(0, h - $, d)), g && (w.push(g), g = void 0), Y > l && w.push(F.slice(l - $, F.size, d)));
    }
    return w;
  }
  function zr(s) {
    var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, l = s.domSelectionRange(), d = s.state.doc;
    if (!l.focusNode)
      return null;
    var g = s.docView.nearestDesc(l.focusNode), w = g && g.size == 0, E = s.docView.posFromDOM(l.focusNode, l.focusOffset, 1);
    if (E < 0)
      return null;
    var L = d.resolve(E), F, $;
    if (je(l)) {
      for (F = L; g && !g.node; )
        g = g.parent;
      var Y = g.node;
      if (g && Y.isAtom && _.NodeSelection.isSelectable(Y) && g.parent && !(Y.isInline && ze(l.focusNode, l.focusOffset, g.dom))) {
        var ce = g.posBefore;
        $ = new _.NodeSelection(E == ce ? L : d.resolve(ce));
      }
    } else {
      var re = s.docView.posFromDOM(l.anchorNode, l.anchorOffset, 1);
      if (re < 0)
        return null;
      F = d.resolve(re);
    }
    if (!$) {
      var ye = h == "pointer" || s.state.selection.head < L.pos && !w ? 1 : -1;
      $ = ua(s, F, L, ye);
    }
    return $;
  }
  function Rn(s) {
    return s.editable ? s.hasFocus() : Ma(s) && document.activeElement && document.activeElement.contains(s.dom);
  }
  function $r(s) {
    var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, l = s.state.selection;
    if (xa(s, l), !!Rn(s)) {
      if (!h && s.input.mouseDown && s.input.mouseDown.allowDefault && le) {
        var d = s.domSelectionRange(), g = s.domObserver.currentSelection;
        if (d.anchorNode && g.anchorNode && pe(d.anchorNode, d.anchorOffset, g.anchorNode, g.anchorOffset)) {
          s.input.mouseDown.delayedSelectionSync = !0, s.domObserver.setCurSelection();
          return;
        }
      }
      if (s.domObserver.disconnectSelection(), s.cursorWrapper)
        Sn(s);
      else {
        var w = l.anchor, E = l.head, L, F;
        In && !(l instanceof _.TextSelection) && (l.$from.parent.inlineContent || (L = Ea(s, l.from)), !l.empty && !l.$from.parent.inlineContent && (F = Ea(s, l.to))), s.docView.setSelection(w, E, s.root, h), In && (L && Cn(L), F && Cn(F)), l.visible ? s.dom.classList.remove("ProseMirror-hideselection") : (s.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && Tn(s));
      }
      s.domObserver.setCurSelection(), s.domObserver.connectSelection();
    }
  }
  var In = ae || le && te < 63;
  function Ea(s, h) {
    var l = s.docView.domFromPos(h, 0), d = l.node, g = l.offset, w = g < d.childNodes.length ? d.childNodes[g] : null, E = g ? d.childNodes[g - 1] : null;
    if (ae && w && w.contentEditable == "false")
      return Pn(w);
    if ((!w || w.contentEditable == "false") && (!E || E.contentEditable == "false")) {
      if (w)
        return Pn(w);
      if (E)
        return Pn(E);
    }
  }
  function Pn(s) {
    return s.contentEditable = "true", ae && s.draggable && (s.draggable = !1, s.wasDraggable = !0), s;
  }
  function Cn(s) {
    s.contentEditable = "false", s.wasDraggable && (s.draggable = !0, s.wasDraggable = null);
  }
  function Tn(s) {
    var h = s.dom.ownerDocument;
    h.removeEventListener("selectionchange", s.input.hideSelectionGuard);
    var l = s.domSelectionRange(), d = l.anchorNode, g = l.anchorOffset;
    h.addEventListener("selectionchange", s.input.hideSelectionGuard = function() {
      (l.anchorNode != d || l.anchorOffset != g) && (h.removeEventListener("selectionchange", s.input.hideSelectionGuard), setTimeout(function() {
        (!Rn(s) || s.state.selection.visible) && s.dom.classList.remove("ProseMirror-hideselection");
      }, 20));
    });
  }
  function Sn(s) {
    var h = s.domSelection(), l = document.createRange(), d = s.cursorWrapper.dom, g = d.nodeName == "IMG";
    g ? l.setEnd(d.parentNode, ie(d) + 1) : l.setEnd(d, 0), l.collapse(!1), h.removeAllRanges(), h.addRange(l), !g && !s.state.selection.visible && At && lt <= 11 && (d.disabled = !0, d.disabled = !1);
  }
  function xa(s, h) {
    if (h instanceof _.NodeSelection) {
      var l = s.docView.descAt(h.from);
      l != s.lastSelectedViewDesc && (Aa(s), l && l.selectNode(), s.lastSelectedViewDesc = l);
    } else
      Aa(s);
  }
  function Aa(s) {
    s.lastSelectedViewDesc && (s.lastSelectedViewDesc.parent && s.lastSelectedViewDesc.deselectNode(), s.lastSelectedViewDesc = void 0);
  }
  function ua(s, h, l, d) {
    return s.someProp("createSelectionBetween", function(g) {
      return g(s, h, l);
    }) || _.TextSelection.between(h, l, d);
  }
  function ca(s) {
    return s.editable && !s.hasFocus() ? !1 : Ma(s);
  }
  function Ma(s) {
    var h = s.domSelectionRange();
    if (!h.anchorNode)
      return !1;
    try {
      return s.dom.contains(h.anchorNode.nodeType == 3 ? h.anchorNode.parentNode : h.anchorNode) && (s.editable || s.dom.contains(h.focusNode.nodeType == 3 ? h.focusNode.parentNode : h.focusNode));
    } catch {
      return !1;
    }
  }
  function La(s) {
    var h = s.docView.domFromPos(s.state.selection.anchor, 0), l = s.domSelectionRange();
    return pe(h.node, h.offset, l.anchorNode, l.anchorOffset);
  }
  function Bn(s, h) {
    var l = s.selection, d = l.$anchor, g = l.$head, w = h > 0 ? d.max(g) : d.min(g), E = w.parent.inlineContent ? w.depth ? s.doc.resolve(h > 0 ? w.after() : w.before()) : null : w;
    return E && _.Selection.findFrom(E, h);
  }
  function mr(s, h) {
    return s.dispatch(s.state.tr.setSelection(h).scrollIntoView()), !0;
  }
  function qn(s, h, l) {
    var d = s.state.selection;
    if (d instanceof _.TextSelection) {
      if (!d.empty || l.indexOf("s") > -1)
        return !1;
      if (s.endOfTextblock(h > 0 ? "forward" : "backward")) {
        var g = Bn(s.state, h);
        return g && g instanceof _.NodeSelection ? mr(s, g) : !1;
      } else if (!(de && l.indexOf("m") > -1)) {
        var w = d.$head, E = w.textOffset ? null : h < 0 ? w.nodeBefore : w.nodeAfter, L;
        if (!E || E.isText)
          return !1;
        var F = h < 0 ? w.pos - E.nodeSize : w.pos;
        return E.isAtom || (L = s.docView.descAt(F)) && !L.contentDOM ? _.NodeSelection.isSelectable(E) ? mr(s, new _.NodeSelection(h < 0 ? s.state.doc.resolve(w.pos - E.nodeSize) : w)) : ft ? mr(s, new _.TextSelection(s.state.doc.resolve(h < 0 ? F : F + E.nodeSize))) : !1 : !1;
      }
    } else {
      if (d instanceof _.NodeSelection && d.node.isInline)
        return mr(s, new _.TextSelection(h > 0 ? d.$to : d.$from));
      var $ = Bn(s.state, h);
      return $ ? mr(s, $) : !1;
    }
  }
  function En(s) {
    return s.nodeType == 3 ? s.nodeValue.length : s.childNodes.length;
  }
  function Vr(s) {
    if (s.contentEditable == "false")
      return !0;
    var h = s.pmViewDesc;
    return h && h.size == 0 && (s.nextSibling || s.nodeName != "BR");
  }
  function Fn(s, h) {
    return h < 0 ? Ri(s) : fn(s);
  }
  function Ri(s) {
    var h = s.domSelectionRange(), l = h.focusNode, d = h.focusOffset;
    if (l) {
      var g, w, E = !1;
      for (Rt && l.nodeType == 1 && d < En(l) && Vr(l.childNodes[d]) && (E = !0); ; )
        if (d > 0) {
          if (l.nodeType != 1)
            break;
          var L = l.childNodes[d - 1];
          if (Vr(L))
            g = l, w = --d;
          else if (L.nodeType == 3)
            l = L, d = l.nodeValue.length;
          else
            break;
        } else {
          if (vn(l))
            break;
          for (var F = l.previousSibling; F && Vr(F); )
            g = l.parentNode, w = ie(F), F = F.previousSibling;
          if (F)
            l = F, d = En(l);
          else {
            if (l = l.parentNode, l == s.dom)
              break;
            d = 0;
          }
        }
      E ? fa(s, l, d) : g && fa(s, g, w);
    }
  }
  function fn(s) {
    var h = s.domSelectionRange(), l = h.focusNode, d = h.focusOffset;
    if (l) {
      for (var g = En(l), w, E; ; )
        if (d < g) {
          if (l.nodeType != 1)
            break;
          var L = l.childNodes[d];
          if (Vr(L))
            w = l, E = ++d;
          else
            break;
        } else {
          if (vn(l))
            break;
          for (var F = l.nextSibling; F && Vr(F); )
            w = F.parentNode, E = ie(F) + 1, F = F.nextSibling;
          if (F)
            l = F, d = 0, g = En(l);
          else {
            if (l = l.parentNode, l == s.dom)
              break;
            d = g = 0;
          }
        }
      w && fa(s, w, E);
    }
  }
  function vn(s) {
    var h = s.pmViewDesc;
    return h && h.node && h.node.isBlock;
  }
  function Ii(s, h) {
    for (; s && h == s.childNodes.length && !vt(s); )
      h = ie(s) + 1, s = s.parentNode;
    for (; s && h < s.childNodes.length; ) {
      if (s = s.childNodes[h], s.nodeType == 3)
        return s;
      h = 0;
    }
  }
  function Oa(s, h) {
    for (; s && !h && !vt(s); )
      h = ie(s), s = s.parentNode;
    for (; s && h; ) {
      if (s = s.childNodes[h - 1], s.nodeType == 3)
        return s;
      h = s.childNodes.length;
    }
  }
  function fa(s, h, l) {
    if (h.nodeType != 3) {
      var d, g;
      (g = Ii(h, l)) ? (h = g, l = 0) : (d = Oa(h, l)) && (h = d, l = d.nodeValue.length);
    }
    var w = s.domSelection();
    if (je(w)) {
      var E = document.createRange();
      E.setEnd(h, l), E.setStart(h, l), w.removeAllRanges(), w.addRange(E);
    } else
      w.extend && w.extend(h, l);
    s.domObserver.setCurSelection();
    var L = s.state;
    setTimeout(function() {
      s.state == L && $r(s);
    }, 50);
  }
  function Da(s, h) {
    var l = s.state.doc.resolve(h);
    if (!(le || Te) && l.parent.inlineContent) {
      var d = s.coordsAtPos(h);
      if (h > l.start()) {
        var g = s.coordsAtPos(h - 1), w = (g.top + g.bottom) / 2;
        if (w > d.top && w < d.bottom && Math.abs(g.left - d.left) > 1)
          return g.left < d.left ? "ltr" : "rtl";
      }
      if (h < l.end()) {
        var E = s.coordsAtPos(h + 1), L = (E.top + E.bottom) / 2;
        if (L > d.top && L < d.bottom && Math.abs(E.left - d.left) > 1)
          return E.left > d.left ? "ltr" : "rtl";
      }
    }
    var F = getComputedStyle(s.dom).direction;
    return F == "rtl" ? "rtl" : "ltr";
  }
  function _n(s, h, l) {
    var d = s.state.selection;
    if (d instanceof _.TextSelection && !d.empty || l.indexOf("s") > -1 || de && l.indexOf("m") > -1)
      return !1;
    var g = d.$from, w = d.$to;
    if (!g.parent.inlineContent || s.endOfTextblock(h < 0 ? "up" : "down")) {
      var E = Bn(s.state, h);
      if (E && E instanceof _.NodeSelection)
        return mr(s, E);
    }
    if (!g.parent.inlineContent) {
      var L = h < 0 ? g : w, F = d instanceof _.AllSelection ? _.Selection.near(L, h) : _.Selection.findFrom(L, h);
      return F ? mr(s, F) : !1;
    }
    return !1;
  }
  function va(s, h) {
    if (!(s.state.selection instanceof _.TextSelection))
      return !0;
    var l = s.state.selection, d = l.$head, g = l.$anchor, w = l.empty;
    if (!d.sameParent(g))
      return !0;
    if (!w)
      return !1;
    if (s.endOfTextblock(h > 0 ? "forward" : "backward"))
      return !0;
    var E = !d.textOffset && (h < 0 ? d.nodeBefore : d.nodeAfter);
    if (E && !E.isText) {
      var L = s.state.tr;
      return h < 0 ? L.delete(d.pos - E.nodeSize, d.pos) : L.delete(d.pos, d.pos + E.nodeSize), s.dispatch(L), !0;
    }
    return !1;
  }
  function ri(s, h, l) {
    s.domObserver.stop(), h.contentEditable = l, s.domObserver.start();
  }
  function jr(s) {
    if (!ae || s.state.selection.$head.parentOffset > 0)
      return !1;
    var h = s.domSelectionRange(), l = h.focusNode, d = h.focusOffset;
    if (l && l.nodeType == 1 && d == 0 && l.firstChild && l.firstChild.contentEditable == "false") {
      var g = l.firstChild;
      ri(s, g, "true"), setTimeout(function() {
        return ri(s, g, "false");
      }, 20);
    }
    return !1;
  }
  function ni(s) {
    var h = "";
    return s.ctrlKey && (h += "c"), s.metaKey && (h += "m"), s.altKey && (h += "a"), s.shiftKey && (h += "s"), h;
  }
  function ai(s, h) {
    var l = h.keyCode, d = ni(h);
    if (l == 8 || de && l == 72 && d == "c")
      return va(s, -1) || Fn(s, -1);
    if (l == 46 && !h.shiftKey || de && l == 68 && d == "c")
      return va(s, 1) || Fn(s, 1);
    if (l == 13 || l == 27)
      return !0;
    if (l == 37 || de && l == 66 && d == "c") {
      var g = l == 37 ? Da(s, s.state.selection.from) == "ltr" ? -1 : 1 : -1;
      return qn(s, g, d) || Fn(s, g);
    } else if (l == 39 || de && l == 70 && d == "c") {
      var w = l == 39 ? Da(s, s.state.selection.from) == "ltr" ? 1 : -1 : 1;
      return qn(s, w, d) || Fn(s, w);
    } else {
      if (l == 38 || de && l == 80 && d == "c")
        return _n(s, -1, d) || Fn(s, -1);
      if (l == 40 || de && l == 78 && d == "c")
        return jr(s) || _n(s, 1, d) || fn(s);
      if (d == (de ? "m" : "c") && (l == 66 || l == 73 || l == 89 || l == 90))
        return !0;
    }
    return !1;
  }
  function da(s, h) {
    s.someProp("transformCopied", function(De) {
      h = De(h, s);
    });
    for (var l = [], d = h, g = d.content, w = d.openStart, E = d.openEnd; w > 1 && E > 1 && g.childCount == 1 && g.firstChild.childCount == 1; ) {
      w--, E--;
      var L = g.firstChild;
      l.push(L.type.name, L.attrs != L.type.defaultAttrs ? L.attrs : null), g = L.content;
    }
    var F = s.someProp("clipboardSerializer") || K.DOMSerializer.fromSchema(s.state.schema), $ = Ge(), Y = $.createElement("div");
    Y.appendChild(F.serializeFragment(g, {
      document: $
    }));
    for (var ce = Y.firstChild, re, ye = 0; ce && ce.nodeType == 1 && (re = se[ce.nodeName.toLowerCase()]); ) {
      for (var we = re.length - 1; we >= 0; we--) {
        for (var qe = $.createElement(re[we]); Y.firstChild; )
          qe.appendChild(Y.firstChild);
        Y.appendChild(qe), ye++;
      }
      ce = Y.firstChild;
    }
    ce && ce.nodeType == 1 && ce.setAttribute("data-pm-slice", "".concat(w, " ").concat(E).concat(ye ? " -".concat(ye) : "", " ").concat(JSON.stringify(l)));
    var ot = s.someProp("clipboardTextSerializer", function(De) {
      return De(h, s);
    }) || h.content.textBetween(0, h.content.size, `

`);
    return {
      dom: Y,
      text: ot
    };
  }
  function Na(s, h, l, d, g) {
    var w = g.parent.type.spec.code, E, L;
    if (!l && !h)
      return null;
    var F = h && (d || w || !l);
    if (F) {
      if (s.someProp("transformPastedText", function(kt) {
        h = kt(h, w || d, s);
      }), w)
        return h ? new K.Slice(K.Fragment.from(s.state.schema.text(h.replace(/\r\n?/g, `
`))), 0, 0) : K.Slice.empty;
      var $ = s.someProp("clipboardTextParser", function(kt) {
        return kt(h, g, d, s);
      });
      if ($)
        L = $;
      else {
        var Y = g.marks(), ce = s.state.schema, re = K.DOMSerializer.fromSchema(ce);
        E = document.createElement("div"), h.split(/(?:\r\n?|\n)+/).forEach(function(kt) {
          var Vt = E.appendChild(document.createElement("p"));
          kt && Vt.appendChild(re.serializeNode(ce.text(kt, Y)));
        });
      }
    } else
      s.someProp("transformPastedHTML", function(kt) {
        l = kt(l, s);
      }), E = Mt(l), ft && ar(E);
    var ye = E && E.querySelector("[data-pm-slice]"), we = ye && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(ye.getAttribute("data-pm-slice") || "");
    if (we && we[3])
      for (var qe = +we[3]; qe > 0; qe--) {
        for (var ot = E.firstChild; ot && ot.nodeType != 1; )
          ot = ot.nextSibling;
        if (!ot)
          break;
        E = ot;
      }
    if (!L) {
      var De = s.someProp("clipboardParser") || s.someProp("domParser") || K.DOMParser.fromSchema(s.state.schema);
      L = De.parseSlice(E, {
        preserveWhitespace: !!(F || we),
        context: g,
        ruleFromNode: function(Vt) {
          return Vt.nodeName == "BR" && !Vt.nextSibling && Vt.parentNode && !Hn.test(Vt.parentNode.nodeName) ? {
            ignore: !0
          } : null;
        }
      });
    }
    if (we)
      L = ir(Ze(L, +we[1], +we[2]), we[4]);
    else if (L = K.Slice.maxOpen(Gr(L.content, g), !0), L.openStart || L.openEnd) {
      for (var Dt = 0, mt = 0, Bt = L.content.firstChild; Dt < L.openStart && !Bt.type.spec.isolating; Dt++, Bt = Bt.firstChild)
        ;
      for (var bt = L.content.lastChild; mt < L.openEnd && !bt.type.spec.isolating; mt++, bt = bt.lastChild)
        ;
      L = Ze(L, Dt, mt);
    }
    return s.someProp("transformPasted", function(kt) {
      L = kt(L, s);
    }), L;
  }
  var Hn = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
  function Gr(s, h) {
    if (s.childCount < 2)
      return s;
    for (var l = function(E) {
      var L = h.node(E), F = L.contentMatchAt(h.index(E)), $ = void 0, Y = [];
      if (s.forEach(function(ce) {
        if (Y) {
          var re = F.findWrapping(ce.type), ye;
          if (!re)
            return Y = null;
          if (ye = Y.length && $.length && Ia(re, $, ce, Y[Y.length - 1], 0))
            Y[Y.length - 1] = ye;
          else {
            Y.length && (Y[Y.length - 1] = Pa(Y[Y.length - 1], $.length));
            var we = Ra(ce, re);
            Y.push(we), F = F.matchType(we.type), $ = re;
          }
        }
      }), Y)
        return {
          v: K.Fragment.from(Y)
        };
    }, d = h.depth; d >= 0; d--) {
      var g = l(d);
      if (t(g) === "object")
        return g.v;
    }
    return s;
  }
  function Ra(s, h) {
    for (var l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, d = h.length - 1; d >= l; d--)
      s = h[d].create(null, K.Fragment.from(s));
    return s;
  }
  function Ia(s, h, l, d, g) {
    if (g < s.length && g < h.length && s[g] == h[g]) {
      var w = Ia(s, h, l, d.lastChild, g + 1);
      if (w)
        return d.copy(d.content.replaceChild(d.childCount - 1, w));
      var E = d.contentMatchAt(d.childCount);
      if (E.matchType(g == s.length - 1 ? l.type : s[g + 1]))
        return d.copy(d.content.append(K.Fragment.from(Ra(l, s, g + 1))));
    }
  }
  function Pa(s, h) {
    if (h == 0)
      return s;
    var l = s.content.replaceChild(s.childCount - 1, Pa(s.lastChild, h - 1)), d = s.contentMatchAt(s.childCount).fillBefore(K.Fragment.empty, !0);
    return s.copy(l.append(d));
  }
  function Ba(s, h, l, d, g, w) {
    var E = h < 0 ? s.firstChild : s.lastChild, L = E.content;
    return s.childCount > 1 && (w = 0), g < d - 1 && (L = Ba(L, h, l, d, g + 1, w)), g >= l && (L = h < 0 ? E.contentMatchAt(0).fillBefore(L, w <= g).append(L) : L.append(E.contentMatchAt(E.childCount).fillBefore(K.Fragment.empty, !0))), s.replaceChild(h < 0 ? 0 : s.childCount - 1, E.copy(L));
  }
  function Ze(s, h, l) {
    return h < s.openStart && (s = new K.Slice(Ba(s.content, -1, h, s.openStart, 0, s.openEnd), h, s.openEnd)), l < s.openEnd && (s = new K.Slice(Ba(s.content, 1, l, s.openEnd, 0, 0), s.openStart, l)), s;
  }
  var se = {
    thead: ["table"],
    tbody: ["table"],
    tfoot: ["table"],
    caption: ["table"],
    colgroup: ["table"],
    col: ["table", "colgroup"],
    tr: ["table", "tbody"],
    td: ["table", "tbody", "tr"],
    th: ["table", "tbody", "tr"]
  }, Ne = null;
  function Ge() {
    return Ne || (Ne = document.implementation.createHTMLDocument("title"));
  }
  function Mt(s) {
    var h = /^(\s*<meta [^>]*>)*/.exec(s);
    h && (s = s.slice(h[0].length));
    var l = Ge().createElement("div"), d = /<([a-z][^>\s]+)/i.exec(s), g;
    if ((g = d && se[d[1].toLowerCase()]) && (s = g.map(function(E) {
      return "<" + E + ">";
    }).join("") + s + g.map(function(E) {
      return "</" + E + ">";
    }).reverse().join("")), l.innerHTML = s, g)
      for (var w = 0; w < g.length; w++)
        l = l.querySelector(g[w]) || l;
    return l;
  }
  function ar(s) {
    for (var h = s.querySelectorAll(le ? "span:not([class]):not([style])" : "span.Apple-converted-space"), l = 0; l < h.length; l++) {
      var d = h[l];
      d.childNodes.length == 1 && d.textContent == " " && d.parentNode && d.parentNode.replaceChild(s.ownerDocument.createTextNode(" "), d);
    }
  }
  function ir(s, h) {
    if (!s.size)
      return s;
    var l = s.content.firstChild.type.schema, d;
    try {
      d = JSON.parse(h);
    } catch {
      return s;
    }
    for (var g = s.content, w = s.openStart, E = s.openEnd, L = d.length - 2; L >= 0; L -= 2) {
      var F = l.nodes[d[L]];
      if (!F || F.hasRequiredAttrs())
        break;
      g = K.Fragment.from(F.create(d[L + 1], g)), w++, E++;
    }
    return new K.Slice(g, w, E);
  }
  var Tt = {}, qt = {}, Un = {
    touchstart: !0,
    touchmove: !0
  }, ii = q(function s() {
    M(this, s), this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = {
      time: 0,
      x: 0,
      y: 0,
      type: ""
    }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastAndroidDelete = 0, this.composing = !1, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  });
  function Pi(s) {
    var h = function(g) {
      var w = Tt[g];
      s.dom.addEventListener(g, s.input.eventHandlers[g] = function(E) {
        Js(s, E) && !qi(s, E) && (s.editable || !(E.type in qt)) && w(s, E);
      }, Un[g] ? {
        passive: !0
      } : void 0);
    };
    for (var l in Tt)
      h(l);
    ae && s.dom.addEventListener("input", function() {
      return null;
    }), Bi(s);
  }
  function dn(s, h) {
    s.input.lastSelectionOrigin = h, s.input.lastSelectionTime = Date.now();
  }
  function Ks(s) {
    s.domObserver.stop();
    for (var h in s.input.eventHandlers)
      s.dom.removeEventListener(h, s.input.eventHandlers[h]);
    clearTimeout(s.input.composingTimeout), clearTimeout(s.input.lastIOSEnterFallbackTimeout);
  }
  function Bi(s) {
    s.someProp("handleDOMEvents", function(h) {
      for (var l in h)
        s.input.eventHandlers[l] || s.dom.addEventListener(l, s.input.eventHandlers[l] = function(d) {
          return qi(s, d);
        });
    });
  }
  function qi(s, h) {
    return s.someProp("handleDOMEvents", function(l) {
      var d = l[h.type];
      return d ? d(s, h) || h.defaultPrevented : !1;
    });
  }
  function Js(s, h) {
    if (!h.bubbles)
      return !0;
    if (h.defaultPrevented)
      return !1;
    for (var l = h.target; l != s.dom; l = l.parentNode)
      if (!l || l.nodeType == 11 || l.pmViewDesc && l.pmViewDesc.stopEvent(h))
        return !1;
    return !0;
  }
  function Ys(s, h) {
    !qi(s, h) && Tt[h.type] && (s.editable || !(h.type in qt)) && Tt[h.type](s, h);
  }
  qt.keydown = function(s, h) {
    var l = h;
    if (s.input.shiftKey = l.keyCode == 16 || l.shiftKey, !fo(s, l) && (s.input.lastKeyCode = l.keyCode, s.input.lastKeyCodeTime = Date.now(), !(Pe && le && l.keyCode == 13)))
      if (l.keyCode != 229 && s.domObserver.forceFlush(), Z && l.keyCode == 13 && !l.ctrlKey && !l.altKey && !l.metaKey) {
        var d = Date.now();
        s.input.lastIOSEnter = d, s.input.lastIOSEnterFallbackTimeout = setTimeout(function() {
          s.input.lastIOSEnter == d && (s.someProp("handleKeyDown", function(g) {
            return g(s, rt(13, "Enter"));
          }), s.input.lastIOSEnter = 0);
        }, 200);
      } else
        s.someProp("handleKeyDown", function(g) {
          return g(s, l);
        }) || ai(s, l) ? l.preventDefault() : dn(s, "key");
  }, qt.keyup = function(s, h) {
    h.keyCode == 16 && (s.input.shiftKey = !1);
  }, qt.keypress = function(s, h) {
    var l = h;
    if (!(fo(s, l) || !l.charCode || l.ctrlKey && !l.altKey || de && l.metaKey)) {
      if (s.someProp("handleKeyPress", function(w) {
        return w(s, l);
      })) {
        l.preventDefault();
        return;
      }
      var d = s.state.selection;
      if (!(d instanceof _.TextSelection) || !d.$from.sameParent(d.$to)) {
        var g = String.fromCharCode(l.charCode);
        !/[\r\n]/.test(g) && !s.someProp("handleTextInput", function(w) {
          return w(s, d.$from.pos, d.$to.pos, g);
        }) && s.dispatch(s.state.tr.insertText(g).scrollIntoView()), l.preventDefault();
      }
    }
  };
  function oi(s) {
    return {
      left: s.clientX,
      top: s.clientY
    };
  }
  function Zs(s, h) {
    var l = h.x - s.clientX, d = h.y - s.clientY;
    return l * l + d * d < 100;
  }
  function Fi(s, h, l, d, g) {
    if (d == -1)
      return !1;
    for (var w = s.state.doc.resolve(d), E = function(Y) {
      if (s.someProp(h, function(ce) {
        return Y > w.depth ? ce(s, l, w.nodeAfter, w.before(Y), g, !0) : ce(s, l, w.node(Y), w.before(Y), g, !1);
      }))
        return {
          v: !0
        };
    }, L = w.depth + 1; L > 0; L--) {
      var F = E(L);
      if (t(F) === "object")
        return F.v;
    }
    return !1;
  }
  function pa(s, h, l) {
    s.focused || s.focus();
    var d = s.state.tr.setSelection(h);
    l == "pointer" && d.setMeta("pointer", !0), s.dispatch(d);
  }
  function Qs(s, h) {
    if (h == -1)
      return !1;
    var l = s.state.doc.resolve(h), d = l.nodeAfter;
    return d && d.isAtom && _.NodeSelection.isSelectable(d) ? (pa(s, new _.NodeSelection(l), "pointer"), !0) : !1;
  }
  function Xs(s, h) {
    if (h == -1)
      return !1;
    var l = s.state.selection, d, g;
    l instanceof _.NodeSelection && (d = l.node);
    for (var w = s.state.doc.resolve(h), E = w.depth + 1; E > 0; E--) {
      var L = E > w.depth ? w.nodeAfter : w.node(E);
      if (_.NodeSelection.isSelectable(L)) {
        d && l.$from.depth > 0 && E >= l.$from.depth && w.before(l.$from.depth + 1) == l.$from.pos ? g = w.before(l.$from.depth) : g = w.before(E);
        break;
      }
    }
    return g != null ? (pa(s, _.NodeSelection.create(s.state.doc, g), "pointer"), !0) : !1;
  }
  function el(s, h, l, d, g) {
    return Fi(s, "handleClickOn", h, l, d) || s.someProp("handleClick", function(w) {
      return w(s, h, d);
    }) || (g ? Xs(s, l) : Qs(s, l));
  }
  function tl(s, h, l, d) {
    return Fi(s, "handleDoubleClickOn", h, l, d) || s.someProp("handleDoubleClick", function(g) {
      return g(s, h, d);
    });
  }
  function rl(s, h, l, d) {
    return Fi(s, "handleTripleClickOn", h, l, d) || s.someProp("handleTripleClick", function(g) {
      return g(s, h, d);
    }) || nl(s, l, d);
  }
  function nl(s, h, l) {
    if (l.button != 0)
      return !1;
    var d = s.state.doc;
    if (h == -1)
      return d.inlineContent ? (pa(s, _.TextSelection.create(d, 0, d.content.size), "pointer"), !0) : !1;
    for (var g = d.resolve(h), w = g.depth + 1; w > 0; w--) {
      var E = w > g.depth ? g.nodeAfter : g.node(w), L = g.before(w);
      if (E.inlineContent)
        pa(s, _.TextSelection.create(d, L + 1, L + 1 + E.content.size), "pointer");
      else if (_.NodeSelection.isSelectable(E))
        pa(s, _.NodeSelection.create(d, L), "pointer");
      else
        continue;
      return !0;
    }
  }
  function _i(s) {
    return qa(s);
  }
  var co = de ? "metaKey" : "ctrlKey";
  Tt.mousedown = function(s, h) {
    var l = h;
    s.input.shiftKey = l.shiftKey;
    var d = _i(s), g = Date.now(), w = "singleClick";
    g - s.input.lastClick.time < 500 && Zs(l, s.input.lastClick) && !l[co] && (s.input.lastClick.type == "singleClick" ? w = "doubleClick" : s.input.lastClick.type == "doubleClick" && (w = "tripleClick")), s.input.lastClick = {
      time: g,
      x: l.clientX,
      y: l.clientY,
      type: w
    };
    var E = s.posAtCoords(oi(l));
    E && (w == "singleClick" ? (s.input.mouseDown && s.input.mouseDown.done(), s.input.mouseDown = new al(s, E, l, !!d)) : (w == "doubleClick" ? tl : rl)(s, E.pos, E.inside, l) ? l.preventDefault() : dn(s, "pointer"));
  };
  var al = function() {
    function s(h, l, d, g) {
      var w = this;
      M(this, s), this.view = h, this.pos = l, this.event = d, this.flushed = g, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = h.state.doc, this.selectNode = !!d[co], this.allowDefault = d.shiftKey;
      var E, L;
      if (l.inside > -1)
        E = h.state.doc.nodeAt(l.inside), L = l.inside;
      else {
        var F = h.state.doc.resolve(l.pos);
        E = F.parent, L = F.depth ? F.before() : 0;
      }
      var $ = g ? null : d.target, Y = $ ? h.docView.nearestDesc($, !0) : null;
      this.target = Y ? Y.dom : null;
      var ce = h.state.selection;
      (d.button == 0 && E.type.spec.draggable && E.type.spec.selectable !== !1 || ce instanceof _.NodeSelection && ce.from <= L && ce.to > L) && (this.mightDrag = {
        node: E,
        pos: L,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && Rt && !this.target.hasAttribute("contentEditable"))
      }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(function() {
        w.view.input.mouseDown == w && w.target.setAttribute("contentEditable", "false");
      }, 20), this.view.domObserver.start()), h.root.addEventListener("mouseup", this.up = this.up.bind(this)), h.root.addEventListener("mousemove", this.move = this.move.bind(this)), dn(h, "pointer");
    }
    return q(s, [{
      key: "done",
      value: function() {
        var l = this;
        this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(function() {
          return $r(l.view);
        }), this.view.input.mouseDown = null;
      }
    }, {
      key: "up",
      value: function(l) {
        if (this.done(), !!this.view.dom.contains(l.target)) {
          var d = this.pos;
          this.view.state.doc != this.startDoc && (d = this.view.posAtCoords(oi(l))), this.updateAllowDefault(l), this.allowDefault || !d ? dn(this.view, "pointer") : el(this.view, d.pos, d.inside, l, this.selectNode) ? l.preventDefault() : l.button == 0 && (this.flushed || ae && this.mightDrag && !this.mightDrag.node.isAtom || le && !this.view.state.selection.visible && Math.min(Math.abs(d.pos - this.view.state.selection.from), Math.abs(d.pos - this.view.state.selection.to)) <= 2) ? (pa(this.view, _.Selection.near(this.view.state.doc.resolve(d.pos)), "pointer"), l.preventDefault()) : dn(this.view, "pointer");
        }
      }
    }, {
      key: "move",
      value: function(l) {
        this.updateAllowDefault(l), dn(this.view, "pointer"), l.buttons == 0 && this.done();
      }
    }, {
      key: "updateAllowDefault",
      value: function(l) {
        !this.allowDefault && (Math.abs(this.event.x - l.clientX) > 4 || Math.abs(this.event.y - l.clientY) > 4) && (this.allowDefault = !0);
      }
    }]), s;
  }();
  Tt.touchstart = function(s) {
    s.input.lastTouch = Date.now(), _i(s), dn(s, "pointer");
  }, Tt.touchmove = function(s) {
    s.input.lastTouch = Date.now(), dn(s, "pointer");
  }, Tt.contextmenu = function(s) {
    return _i(s);
  };
  function fo(s, h) {
    return s.composing ? !0 : ae && Math.abs(h.timeStamp - s.input.compositionEndedAt) < 500 ? (s.input.compositionEndedAt = -2e8, !0) : !1;
  }
  var il = Pe ? 5e3 : -1;
  qt.compositionstart = qt.compositionupdate = function(s) {
    if (!s.composing) {
      s.domObserver.flush();
      var h = s.state, l = h.selection.$from;
      if (h.selection.empty && (h.storedMarks || !l.textOffset && l.parentOffset && l.nodeBefore.marks.some(function(L) {
        return L.type.spec.inclusive === !1;
      })))
        s.markCursor = s.state.storedMarks || l.marks(), qa(s, !0), s.markCursor = null;
      else if (qa(s), Rt && h.selection.empty && l.parentOffset && !l.textOffset && l.nodeBefore.marks.length)
        for (var d = s.domSelectionRange(), g = d.focusNode, w = d.focusOffset; g && g.nodeType == 1 && w != 0; ) {
          var E = w < 0 ? g.lastChild : g.childNodes[w - 1];
          if (!E)
            break;
          if (E.nodeType == 3) {
            s.domSelection().collapse(E, E.nodeValue.length);
            break;
          } else
            g = E, w = -1;
        }
      s.input.composing = !0;
    }
    vo(s, il);
  }, qt.compositionend = function(s, h) {
    s.composing && (s.input.composing = !1, s.input.compositionEndedAt = h.timeStamp, s.input.compositionPendingChanges = s.domObserver.pendingRecords().length ? s.input.compositionID : 0, s.input.compositionPendingChanges && Promise.resolve().then(function() {
      return s.domObserver.flush();
    }), s.input.compositionID++, vo(s, 20));
  };
  function vo(s, h) {
    clearTimeout(s.input.composingTimeout), h > -1 && (s.input.composingTimeout = setTimeout(function() {
      return qa(s);
    }, h));
  }
  function po(s) {
    for (s.composing && (s.input.composing = !1, s.input.compositionEndedAt = ol()); s.input.compositionNodes.length > 0; )
      s.input.compositionNodes.pop().markParentsDirty();
  }
  function ol() {
    var s = document.createEvent("Event");
    return s.initEvent("event", !0, !0), s.timeStamp;
  }
  function qa(s) {
    var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (!(Pe && s.domObserver.flushingSoon >= 0)) {
      if (s.domObserver.forceFlush(), po(s), h || s.docView && s.docView.dirty) {
        var l = zr(s);
        return l && !l.eq(s.state.selection) ? s.dispatch(s.state.tr.setSelection(l)) : s.updateState(s.state), !0;
      }
      return !1;
    }
  }
  function sl(s, h) {
    if (s.dom.parentNode) {
      var l = s.dom.parentNode.appendChild(document.createElement("div"));
      l.appendChild(h), l.style.cssText = "position: fixed; left: -10000px; top: 10px";
      var d = getSelection(), g = document.createRange();
      g.selectNodeContents(h), s.dom.blur(), d.removeAllRanges(), d.addRange(g), setTimeout(function() {
        l.parentNode && l.parentNode.removeChild(l), s.focus();
      }, 50);
    }
  }
  var ha = At && lt < 15 || Z && ht < 604;
  Tt.copy = qt.cut = function(s, h) {
    var l = h, d = s.state.selection, g = l.type == "cut";
    if (!d.empty) {
      var w = ha ? null : l.clipboardData, E = d.content(), L = da(s, E), F = L.dom, $ = L.text;
      w ? (l.preventDefault(), w.clearData(), w.setData("text/html", F.innerHTML), w.setData("text/plain", $)) : sl(s, F), g && s.dispatch(s.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
    }
  };
  function ll(s) {
    return s.openStart == 0 && s.openEnd == 0 && s.content.childCount == 1 ? s.content.firstChild : null;
  }
  function ul(s, h) {
    if (s.dom.parentNode) {
      var l = s.input.shiftKey || s.state.selection.$from.parent.type.spec.code, d = s.dom.parentNode.appendChild(document.createElement(l ? "textarea" : "div"));
      l || (d.contentEditable = "true"), d.style.cssText = "position: fixed; left: -10000px; top: 10px", d.focus();
      var g = s.input.shiftKey && s.input.lastKeyCode != 45;
      setTimeout(function() {
        s.focus(), d.parentNode && d.parentNode.removeChild(d), l ? Fa(s, d.value, null, g, h) : Fa(s, d.textContent, d.innerHTML, g, h);
      }, 50);
    }
  }
  function Fa(s, h, l, d, g) {
    var w = Na(s, h, l, d, s.state.selection.$from);
    if (s.someProp("handlePaste", function(F) {
      return F(s, g, w || K.Slice.empty);
    }))
      return !0;
    if (!w)
      return !1;
    var E = ll(w), L = E ? s.state.tr.replaceSelectionWith(E, d) : s.state.tr.replaceSelection(w);
    return s.dispatch(L.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
  }
  qt.paste = function(s, h) {
    var l = h;
    if (!(s.composing && !Pe)) {
      var d = ha ? null : l.clipboardData, g = s.input.shiftKey && s.input.lastKeyCode != 45;
      d && Fa(s, d.getData("text/plain"), d.getData("text/html"), g, l) ? l.preventDefault() : ul(s, l);
    }
  };
  var cl = q(function s(h, l) {
    M(this, s), this.slice = h, this.move = l;
  }), ho = de ? "altKey" : "ctrlKey";
  Tt.dragstart = function(s, h) {
    var l = h, d = s.input.mouseDown;
    if (d && d.done(), !!l.dataTransfer) {
      var g = s.state.selection, w = g.empty ? null : s.posAtCoords(oi(l));
      if (!(w && w.pos >= g.from && w.pos <= (g instanceof _.NodeSelection ? g.to - 1 : g.to))) {
        if (d && d.mightDrag)
          s.dispatch(s.state.tr.setSelection(_.NodeSelection.create(s.state.doc, d.mightDrag.pos)));
        else if (l.target && l.target.nodeType == 1) {
          var E = s.docView.nearestDesc(l.target, !0);
          E && E.node.type.spec.draggable && E != s.docView && s.dispatch(s.state.tr.setSelection(_.NodeSelection.create(s.state.doc, E.posBefore)));
        }
      }
      var L = s.state.selection.content(), F = da(s, L), $ = F.dom, Y = F.text;
      l.dataTransfer.clearData(), l.dataTransfer.setData(ha ? "Text" : "text/html", $.innerHTML), l.dataTransfer.effectAllowed = "copyMove", ha || l.dataTransfer.setData("text/plain", Y), s.dragging = new cl(L, !l[ho]);
    }
  }, Tt.dragend = function(s) {
    var h = s.dragging;
    window.setTimeout(function() {
      s.dragging == h && (s.dragging = null);
    }, 50);
  }, qt.dragover = qt.dragenter = function(s, h) {
    return h.preventDefault();
  }, qt.drop = function(s, h) {
    var l = h, d = s.dragging;
    if (s.dragging = null, !!l.dataTransfer) {
      var g = s.posAtCoords(oi(l));
      if (g) {
        var w = s.state.doc.resolve(g.pos), E = d && d.slice;
        E ? s.someProp("transformPasted", function(qe) {
          E = qe(E, s);
        }) : E = Na(s, l.dataTransfer.getData(ha ? "Text" : "text/plain"), ha ? null : l.dataTransfer.getData("text/html"), !1, w);
        var L = !!(d && !l[ho]);
        if (s.someProp("handleDrop", function(qe) {
          return qe(s, l, E || K.Slice.empty, L);
        })) {
          l.preventDefault();
          return;
        }
        if (E) {
          l.preventDefault();
          var F = E ? X.dropPoint(s.state.doc, w.pos, E) : w.pos;
          F == null && (F = w.pos);
          var $ = s.state.tr;
          L && $.deleteSelection();
          var Y = $.mapping.map(F), ce = E.openStart == 0 && E.openEnd == 0 && E.content.childCount == 1, re = $.doc;
          if (ce ? $.replaceRangeWith(Y, Y, E.content.firstChild) : $.replaceRange(Y, Y, E), !$.doc.eq(re)) {
            var ye = $.doc.resolve(Y);
            if (ce && _.NodeSelection.isSelectable(E.content.firstChild) && ye.nodeAfter && ye.nodeAfter.sameMarkup(E.content.firstChild))
              $.setSelection(new _.NodeSelection(ye));
            else {
              var we = $.mapping.map(F);
              $.mapping.maps[$.mapping.maps.length - 1].forEach(function(qe, ot, De, Dt) {
                return we = Dt;
              }), $.setSelection(ua(s, ye, $.doc.resolve(we)));
            }
            s.focus(), s.dispatch($.setMeta("uiEvent", "drop"));
          }
        }
      }
    }
  }, Tt.focus = function(s) {
    s.input.lastFocus = Date.now(), s.focused || (s.domObserver.stop(), s.dom.classList.add("ProseMirror-focused"), s.domObserver.start(), s.focused = !0, setTimeout(function() {
      s.docView && s.hasFocus() && !s.domObserver.currentSelection.eq(s.domSelectionRange()) && $r(s);
    }, 20));
  }, Tt.blur = function(s, h) {
    var l = h;
    s.focused && (s.domObserver.stop(), s.dom.classList.remove("ProseMirror-focused"), s.domObserver.start(), l.relatedTarget && s.dom.contains(l.relatedTarget) && s.domObserver.currentSelection.clear(), s.focused = !1);
  }, Tt.beforeinput = function(s, h) {
    var l = h;
    if (le && Pe && l.inputType == "deleteContentBackward") {
      s.domObserver.flushSoon();
      var d = s.input.domChangeCount;
      setTimeout(function() {
        if (s.input.domChangeCount == d && (s.dom.blur(), s.focus(), !s.someProp("handleKeyDown", function(w) {
          return w(s, rt(8, "Backspace"));
        }))) {
          var g = s.state.selection.$cursor;
          g && g.pos > 0 && s.dispatch(s.state.tr.delete(g.pos - 1, g.pos).scrollIntoView());
        }
      }, 50);
    }
  };
  for (var mo in qt)
    Tt[mo] = qt[mo];
  function _a(s, h) {
    if (s == h)
      return !0;
    for (var l in s)
      if (s[l] !== h[l])
        return !1;
    for (var d in h)
      if (!(d in s))
        return !1;
    return !0;
  }
  var fl = function() {
    function s(h, l) {
      M(this, s), this.toDOM = h, this.spec = l || $n, this.side = this.spec.side || 0;
    }
    return q(s, [{
      key: "map",
      value: function(l, d, g, w) {
        var E = l.mapResult(d.from + w, this.side < 0 ? -1 : 1), L = E.pos, F = E.deleted;
        return F ? null : new zn(L - g, L - g, this);
      }
    }, {
      key: "valid",
      value: function() {
        return !0;
      }
    }, {
      key: "eq",
      value: function(l) {
        return this == l || l instanceof s && (this.spec.key && this.spec.key == l.spec.key || this.toDOM == l.toDOM && _a(this.spec, l.spec));
      }
    }, {
      key: "destroy",
      value: function(l) {
        this.spec.destroy && this.spec.destroy(l);
      }
    }]), s;
  }(), Ha = function() {
    function s(h, l) {
      M(this, s), this.attrs = h, this.spec = l || $n;
    }
    return q(s, [{
      key: "map",
      value: function(l, d, g, w) {
        var E = l.map(d.from + w, this.spec.inclusiveStart ? -1 : 1) - g, L = l.map(d.to + w, this.spec.inclusiveEnd ? 1 : -1) - g;
        return E >= L ? null : new zn(E, L, this);
      }
    }, {
      key: "valid",
      value: function(l, d) {
        return d.from < d.to;
      }
    }, {
      key: "eq",
      value: function(l) {
        return this == l || l instanceof s && _a(this.attrs, l.attrs) && _a(this.spec, l.spec);
      }
    }, {
      key: "destroy",
      value: function() {
      }
    }], [{
      key: "is",
      value: function(l) {
        return l.type instanceof s;
      }
    }]), s;
  }(), vl = function() {
    function s(h, l) {
      M(this, s), this.attrs = h, this.spec = l || $n;
    }
    return q(s, [{
      key: "map",
      value: function(l, d, g, w) {
        var E = l.mapResult(d.from + w, 1);
        if (E.deleted)
          return null;
        var L = l.mapResult(d.to + w, -1);
        return L.deleted || L.pos <= E.pos ? null : new zn(E.pos - g, L.pos - g, this);
      }
    }, {
      key: "valid",
      value: function(l, d) {
        var g = l.content.findIndex(d.from), w = g.index, E = g.offset, L;
        return E == d.from && !(L = l.child(w)).isText && E + L.nodeSize == d.to;
      }
    }, {
      key: "eq",
      value: function(l) {
        return this == l || l instanceof s && _a(this.attrs, l.attrs) && _a(this.spec, l.spec);
      }
    }, {
      key: "destroy",
      value: function() {
      }
    }]), s;
  }(), zn = function() {
    function s(h, l, d) {
      M(this, s), this.from = h, this.to = l, this.type = d;
    }
    return q(s, [{
      key: "copy",
      value: function(l, d) {
        return new s(l, d, this.type);
      }
    }, {
      key: "eq",
      value: function(l) {
        var d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        return this.type.eq(l.type) && this.from + d == l.from && this.to + d == l.to;
      }
    }, {
      key: "map",
      value: function(l, d, g) {
        return this.type.map(l, this, d, g);
      }
    }, {
      key: "spec",
      get: function() {
        return this.type.spec;
      }
    }, {
      key: "inline",
      get: function() {
        return this.type instanceof Ha;
      }
    }], [{
      key: "widget",
      value: function(l, d, g) {
        return new s(l, l, new fl(d, g));
      }
    }, {
      key: "inline",
      value: function(l, d, g, w) {
        return new s(l, d, new Ha(g, w));
      }
    }, {
      key: "node",
      value: function(l, d, g, w) {
        return new s(l, d, new vl(g, w));
      }
    }]), s;
  }(), ma = [], $n = {}, Kr = function() {
    function s(h, l) {
      M(this, s), this.local = h.length ? h : ma, this.children = l.length ? l : ma;
    }
    return q(s, [{
      key: "find",
      value: function(l, d, g) {
        var w = [];
        return this.findInner(l ?? 0, d ?? 1e9, w, 0, g), w;
      }
    }, {
      key: "findInner",
      value: function(l, d, g, w, E) {
        for (var L = 0; L < this.local.length; L++) {
          var F = this.local[L];
          F.from <= d && F.to >= l && (!E || E(F.spec)) && g.push(F.copy(F.from + w, F.to + w));
        }
        for (var $ = 0; $ < this.children.length; $ += 3)
          if (this.children[$] < d && this.children[$ + 1] > l) {
            var Y = this.children[$] + 1;
            this.children[$ + 2].findInner(l - Y, d - Y, g, w + Y, E);
          }
      }
    }, {
      key: "map",
      value: function(l, d, g) {
        return this == gr || l.maps.length == 0 ? this : this.mapInner(l, d, 0, 0, g || $n);
      }
    }, {
      key: "mapInner",
      value: function(l, d, g, w, E) {
        for (var L, F = 0; F < this.local.length; F++) {
          var $ = this.local[F].map(l, g, w);
          $ && $.type.valid(d, $) ? (L || (L = [])).push($) : E.onRemove && E.onRemove(this.local[F].spec);
        }
        return this.children.length ? dl(this.children, L || [], l, d, g, w, E) : L ? new s(L.sort(Vn), ma) : gr;
      }
    }, {
      key: "add",
      value: function(l, d) {
        return d.length ? this == gr ? s.create(l, d) : this.addInner(l, d, 0) : this;
      }
    }, {
      key: "addInner",
      value: function(l, d, g) {
        var w = this, E, L = 0;
        l.forEach(function(Y, ce) {
          var re = ce + g, ye;
          if (ye = bo(d, Y, re)) {
            for (E || (E = w.children.slice()); L < E.length && E[L] < ce; )
              L += 3;
            E[L] == ce ? E[L + 2] = E[L + 2].addInner(Y, ye, re + 1) : E.splice(L, 0, ce, ce + Y.nodeSize, si(ye, Y, re + 1, $n)), L += 3;
          }
        });
        for (var F = yo(L ? ko(d) : d, -g), $ = 0; $ < F.length; $++)
          F[$].type.valid(l, F[$]) || F.splice($--, 1);
        return new s(F.length ? this.local.concat(F).sort(Vn) : this.local, E || this.children);
      }
    }, {
      key: "remove",
      value: function(l) {
        return l.length == 0 || this == gr ? this : this.removeInner(l, 0);
      }
    }, {
      key: "removeInner",
      value: function(l, d) {
        for (var g = this.children, w = this.local, E = 0; E < g.length; E += 3) {
          for (var L = void 0, F = g[E] + d, $ = g[E + 1] + d, Y = 0, ce; Y < l.length; Y++)
            (ce = l[Y]) && ce.from > F && ce.to < $ && (l[Y] = null, (L || (L = [])).push(ce));
          if (L) {
            g == this.children && (g = this.children.slice());
            var re = g[E + 2].removeInner(L, F + 1);
            re != gr ? g[E + 2] = re : (g.splice(E, 3), E -= 3);
          }
        }
        if (w.length) {
          for (var ye = 0, we; ye < l.length; ye++)
            if (we = l[ye])
              for (var qe = 0; qe < w.length; qe++)
                w[qe].eq(we, d) && (w == this.local && (w = this.local.slice()), w.splice(qe--, 1));
        }
        return g == this.children && w == this.local ? this : w.length || g.length ? new s(w, g) : gr;
      }
    }, {
      key: "forChild",
      value: function(l, d) {
        if (this == gr)
          return this;
        if (d.isLeaf)
          return s.empty;
        for (var g, w, E = 0; E < this.children.length; E += 3)
          if (this.children[E] >= l) {
            this.children[E] == l && (g = this.children[E + 2]);
            break;
          }
        for (var L = l + 1, F = L + d.content.size, $ = 0; $ < this.local.length; $++) {
          var Y = this.local[$];
          if (Y.from < F && Y.to > L && Y.type instanceof Ha) {
            var ce = Math.max(L, Y.from) - L, re = Math.min(F, Y.to) - L;
            ce < re && (w || (w = [])).push(Y.copy(ce, re));
          }
        }
        if (w) {
          var ye = new s(w.sort(Vn), ma);
          return g ? new go([ye, g]) : ye;
        }
        return g || gr;
      }
    }, {
      key: "eq",
      value: function(l) {
        if (this == l)
          return !0;
        if (!(l instanceof s) || this.local.length != l.local.length || this.children.length != l.children.length)
          return !1;
        for (var d = 0; d < this.local.length; d++)
          if (!this.local[d].eq(l.local[d]))
            return !1;
        for (var g = 0; g < this.children.length; g += 3)
          if (this.children[g] != l.children[g] || this.children[g + 1] != l.children[g + 1] || !this.children[g + 2].eq(l.children[g + 2]))
            return !1;
        return !0;
      }
    }, {
      key: "locals",
      value: function(l) {
        return Hi(this.localsInner(l));
      }
    }, {
      key: "localsInner",
      value: function(l) {
        if (this == gr)
          return ma;
        if (l.inlineContent || !this.local.some(Ha.is))
          return this.local;
        for (var d = [], g = 0; g < this.local.length; g++)
          this.local[g].type instanceof Ha || d.push(this.local[g]);
        return d;
      }
    }], [{
      key: "create",
      value: function(l, d) {
        return d.length ? si(d, l, 0, $n) : gr;
      }
    }]), s;
  }();
  Kr.empty = new Kr([], []), Kr.removeOverlap = Hi;
  var gr = Kr.empty, go = function() {
    function s(h) {
      M(this, s), this.members = h;
    }
    return q(s, [{
      key: "map",
      value: function(l, d) {
        var g = this.members.map(function(w) {
          return w.map(l, d, $n);
        });
        return s.from(g);
      }
    }, {
      key: "forChild",
      value: function(l, d) {
        if (d.isLeaf)
          return Kr.empty;
        for (var g = [], w = 0; w < this.members.length; w++) {
          var E = this.members[w].forChild(l, d);
          E != gr && (E instanceof s ? g = g.concat(E.members) : g.push(E));
        }
        return s.from(g);
      }
    }, {
      key: "eq",
      value: function(l) {
        if (!(l instanceof s) || l.members.length != this.members.length)
          return !1;
        for (var d = 0; d < this.members.length; d++)
          if (!this.members[d].eq(l.members[d]))
            return !1;
        return !0;
      }
    }, {
      key: "locals",
      value: function(l) {
        for (var d, g = !0, w = 0; w < this.members.length; w++) {
          var E = this.members[w].localsInner(l);
          if (E.length)
            if (!d)
              d = E;
            else {
              g && (d = d.slice(), g = !1);
              for (var L = 0; L < E.length; L++)
                d.push(E[L]);
            }
        }
        return d ? Hi(g ? d : d.sort(Vn)) : ma;
      }
    }], [{
      key: "from",
      value: function(l) {
        switch (l.length) {
          case 0:
            return gr;
          case 1:
            return l[0];
          default:
            return new s(l.every(function(d) {
              return d instanceof Kr;
            }) ? l : l.reduce(function(d, g) {
              return d.concat(g instanceof Kr ? g : g.members);
            }, []));
        }
      }
    }]), s;
  }();
  function dl(s, h, l, d, g, w, E) {
    for (var L = s.slice(), F = function(ga, on) {
      var ya = 0;
      l.maps[ga].forEach(function(Yr, Gt, Oo, Il) {
        for (var li = Il - Oo - (Gt - Yr), Wn = 0; Wn < L.length; Wn += 3) {
          var Do = L[Wn + 1];
          if (!(Do < 0 || Yr > Do + on - ya)) {
            var No = L[Wn] + on - ya;
            Gt >= No ? L[Wn + 1] = Yr <= No ? -2 : -1 : Oo >= g && li && (L[Wn] += li, L[Wn + 1] += li);
          }
        }
        ya += li;
      }), on = l.maps[ga].map(on, -1), Y = on;
    }, $ = 0, Y = w; $ < l.maps.length; $++)
      F($, Y);
    for (var ce = !1, re = 0; re < L.length; re += 3)
      if (L[re + 1] < 0) {
        if (L[re + 1] == -2) {
          ce = !0, L[re + 1] = -1;
          continue;
        }
        var ye = l.map(s[re] + w), we = ye - g;
        if (we < 0 || we >= d.content.size) {
          ce = !0;
          continue;
        }
        var qe = l.map(s[re + 1] + w, -1), ot = qe - g, De = d.content.findIndex(we), Dt = De.index, mt = De.offset, Bt = d.maybeChild(Dt);
        if (Bt && mt == we && mt + Bt.nodeSize == ot) {
          var bt = L[re + 2].mapInner(l, Bt, ye + 1, s[re] + w + 1, E);
          bt != gr ? (L[re] = we, L[re + 1] = ot, L[re + 2] = bt) : (L[re + 1] = -2, ce = !0);
        } else
          ce = !0;
      }
    if (ce) {
      var kt = pl(L, s, h, l, g, w, E), Vt = si(kt, d, 0, E);
      h = Vt.local;
      for (var Ir = 0; Ir < L.length; Ir += 3)
        L[Ir + 1] < 0 && (L.splice(Ir, 3), Ir -= 3);
      for (var Jr = 0, ur = 0; Jr < Vt.children.length; Jr += 3) {
        for (var an = Vt.children[Jr]; ur < L.length && L[ur] < an; )
          ur += 3;
        L.splice(ur, 0, Vt.children[Jr], Vt.children[Jr + 1], Vt.children[Jr + 2]);
      }
    }
    return new Kr(h.sort(Vn), L);
  }
  function yo(s, h) {
    if (!h || !s.length)
      return s;
    for (var l = [], d = 0; d < s.length; d++) {
      var g = s[d];
      l.push(new zn(g.from + h, g.to + h, g.type));
    }
    return l;
  }
  function pl(s, h, l, d, g, w, E) {
    function L($, Y) {
      for (var ce = 0; ce < $.local.length; ce++) {
        var re = $.local[ce].map(d, g, Y);
        re ? l.push(re) : E.onRemove && E.onRemove($.local[ce].spec);
      }
      for (var ye = 0; ye < $.children.length; ye += 3)
        L($.children[ye + 2], $.children[ye] + Y + 1);
    }
    for (var F = 0; F < s.length; F += 3)
      s[F + 1] == -1 && L(s[F + 2], h[F] + w + 1);
    return l;
  }
  function bo(s, h, l) {
    if (h.isLeaf)
      return null;
    for (var d = l + h.nodeSize, g = null, w = 0, E; w < s.length; w++)
      (E = s[w]) && E.from > l && E.to < d && ((g || (g = [])).push(E), s[w] = null);
    return g;
  }
  function ko(s) {
    for (var h = [], l = 0; l < s.length; l++)
      s[l] != null && h.push(s[l]);
    return h;
  }
  function si(s, h, l, d) {
    var g = [], w = !1;
    h.forEach(function(F, $) {
      var Y = bo(s, F, $ + l);
      if (Y) {
        w = !0;
        var ce = si(Y, F, l + $ + 1, d);
        ce != gr && g.push($, $ + F.nodeSize, ce);
      }
    });
    for (var E = yo(w ? ko(s) : s, -l).sort(Vn), L = 0; L < E.length; L++)
      E[L].type.valid(h, E[L]) || (d.onRemove && d.onRemove(E[L].spec), E.splice(L--, 1));
    return E.length || g.length ? new Kr(E, g) : gr;
  }
  function Vn(s, h) {
    return s.from - h.from || s.to - h.to;
  }
  function Hi(s) {
    for (var h = s, l = 0; l < h.length - 1; l++) {
      var d = h[l];
      if (d.from != d.to)
        for (var g = l + 1; g < h.length; g++) {
          var w = h[g];
          if (w.from == d.from) {
            w.to != d.to && (h == s && (h = s.slice()), h[g] = w.copy(w.from, d.to), wo(h, g + 1, w.copy(d.to, w.to)));
            continue;
          } else {
            w.from < d.to && (h == s && (h = s.slice()), h[l] = d.copy(d.from, w.from), wo(h, g, d.copy(w.from, d.to)));
            break;
          }
        }
    }
    return h;
  }
  function wo(s, h, l) {
    for (; h < s.length && Vn(l, s[h]) > 0; )
      h++;
    s.splice(h, 0, l);
  }
  function Ui(s) {
    var h = [];
    return s.someProp("decorations", function(l) {
      var d = l(s.state);
      d && d != gr && h.push(d);
    }), s.cursorWrapper && h.push(Kr.create(s.state.doc, [s.cursorWrapper.deco])), go.from(h);
  }
  var hl = {
    childList: !0,
    characterData: !0,
    characterDataOldValue: !0,
    attributes: !0,
    attributeOldValue: !0,
    subtree: !0
  }, ml = At && lt <= 11, gl = function() {
    function s() {
      M(this, s), this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
    }
    return q(s, [{
      key: "set",
      value: function(l) {
        this.anchorNode = l.anchorNode, this.anchorOffset = l.anchorOffset, this.focusNode = l.focusNode, this.focusOffset = l.focusOffset;
      }
    }, {
      key: "clear",
      value: function() {
        this.anchorNode = this.focusNode = null;
      }
    }, {
      key: "eq",
      value: function(l) {
        return l.anchorNode == this.anchorNode && l.anchorOffset == this.anchorOffset && l.focusNode == this.focusNode && l.focusOffset == this.focusOffset;
      }
    }]), s;
  }(), yl = function() {
    function s(h, l) {
      var d = this;
      M(this, s), this.view = h, this.handleDOMChange = l, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new gl(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.observer = window.MutationObserver && new window.MutationObserver(function(g) {
        for (var w = 0; w < g.length; w++)
          d.queue.push(g[w]);
        At && lt <= 11 && g.some(function(E) {
          return E.type == "childList" && E.removedNodes.length || E.type == "characterData" && E.oldValue.length > E.target.nodeValue.length;
        }) ? d.flushSoon() : d.flush();
      }), ml && (this.onCharData = function(g) {
        d.queue.push({
          target: g.target,
          type: "characterData",
          oldValue: g.prevValue
        }), d.flushSoon();
      }), this.onSelectionChange = this.onSelectionChange.bind(this);
    }
    return q(s, [{
      key: "flushSoon",
      value: function() {
        var l = this;
        this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(function() {
          l.flushingSoon = -1, l.flush();
        }, 20));
      }
    }, {
      key: "forceFlush",
      value: function() {
        this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
      }
    }, {
      key: "start",
      value: function() {
        this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, hl)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
      }
    }, {
      key: "stop",
      value: function() {
        var l = this;
        if (this.observer) {
          var d = this.observer.takeRecords();
          if (d.length) {
            for (var g = 0; g < d.length; g++)
              this.queue.push(d[g]);
            window.setTimeout(function() {
              return l.flush();
            }, 20);
          }
          this.observer.disconnect();
        }
        this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
      }
    }, {
      key: "connectSelection",
      value: function() {
        this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
      }
    }, {
      key: "disconnectSelection",
      value: function() {
        this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
      }
    }, {
      key: "suppressSelectionUpdates",
      value: function() {
        var l = this;
        this.suppressingSelectionUpdates = !0, setTimeout(function() {
          return l.suppressingSelectionUpdates = !1;
        }, 50);
      }
    }, {
      key: "onSelectionChange",
      value: function() {
        if (ca(this.view)) {
          if (this.suppressingSelectionUpdates)
            return $r(this.view);
          if (At && lt <= 11 && !this.view.state.selection.empty) {
            var l = this.view.domSelectionRange();
            if (l.focusNode && pe(l.focusNode, l.focusOffset, l.anchorNode, l.anchorOffset))
              return this.flushSoon();
          }
          this.flush();
        }
      }
    }, {
      key: "setCurSelection",
      value: function() {
        this.currentSelection.set(this.view.domSelectionRange());
      }
    }, {
      key: "ignoreSelectionChange",
      value: function(l) {
        if (!l.focusNode)
          return !0;
        for (var d = /* @__PURE__ */ new Set(), g, w = l.focusNode; w; w = ee(w))
          d.add(w);
        for (var E = l.anchorNode; E; E = ee(E))
          if (d.has(E)) {
            g = E;
            break;
          }
        var L = g && this.view.docView.nearestDesc(g);
        if (L && L.ignoreMutation({
          type: "selection",
          target: g.nodeType == 3 ? g.parentNode : g
        }))
          return this.setCurSelection(), !0;
      }
    }, {
      key: "pendingRecords",
      value: function() {
        if (this.observer) {
          var l = e(this.observer.takeRecords()), d;
          try {
            for (l.s(); !(d = l.n()).done; ) {
              var g = d.value;
              this.queue.push(g);
            }
          } catch (w) {
            l.e(w);
          } finally {
            l.f();
          }
        }
        return this.queue;
      }
    }, {
      key: "flush",
      value: function() {
        var l = this.view;
        if (!(!l.docView || this.flushingSoon > -1)) {
          var d = this.pendingRecords();
          d.length && (this.queue = []);
          var g = l.domSelectionRange(), w = !this.suppressingSelectionUpdates && !this.currentSelection.eq(g) && ca(l) && !this.ignoreSelectionChange(g), E = -1, L = -1, F = !1, $ = [];
          if (l.editable)
            for (var Y = 0; Y < d.length; Y++) {
              var ce = this.registerMutation(d[Y], $);
              ce && (E = E < 0 ? ce.from : Math.min(ce.from, E), L = L < 0 ? ce.to : Math.max(ce.to, L), ce.typeOver && (F = !0));
            }
          if (Rt && $.length > 1) {
            var re = $.filter(function(ot) {
              return ot.nodeName == "BR";
            });
            if (re.length == 2) {
              var ye = re[0], we = re[1];
              ye.parentNode && ye.parentNode.parentNode == we.parentNode ? we.remove() : ye.remove();
            }
          }
          var qe = null;
          E < 0 && w && l.input.lastFocus > Date.now() - 200 && Math.max(l.input.lastTouch, l.input.lastClick.time) < Date.now() - 300 && je(g) && (qe = zr(l)) && qe.eq(_.Selection.near(l.state.doc.resolve(0), 1)) ? (l.input.lastFocus = 0, $r(l), this.currentSelection.set(g), l.scrollToSelection()) : (E > -1 || w) && (E > -1 && (l.docView.markDirty(E, L), bl(l)), this.handleDOMChange(E, L, F, $), l.docView && l.docView.dirty ? l.updateState(l.state) : this.currentSelection.eq(g) || $r(l), this.currentSelection.set(g));
        }
      }
    }, {
      key: "registerMutation",
      value: function(l, d) {
        if (d.indexOf(l.target) > -1)
          return null;
        var g = this.view.docView.nearestDesc(l.target);
        if (l.type == "attributes" && (g == this.view.docView || l.attributeName == "contenteditable" || l.attributeName == "style" && !l.oldValue && !l.target.getAttribute("style")) || !g || g.ignoreMutation(l))
          return null;
        if (l.type == "childList") {
          for (var w = 0; w < l.addedNodes.length; w++)
            d.push(l.addedNodes[w]);
          if (g.contentDOM && g.contentDOM != g.dom && !g.contentDOM.contains(l.target))
            return {
              from: g.posBefore,
              to: g.posAfter
            };
          var E = l.previousSibling, L = l.nextSibling;
          if (At && lt <= 11 && l.addedNodes.length)
            for (var F = 0; F < l.addedNodes.length; F++) {
              var $ = l.addedNodes[F], Y = $.previousSibling, ce = $.nextSibling;
              (!Y || Array.prototype.indexOf.call(l.addedNodes, Y) < 0) && (E = Y), (!ce || Array.prototype.indexOf.call(l.addedNodes, ce) < 0) && (L = ce);
            }
          var re = E && E.parentNode == l.target ? ie(E) + 1 : 0, ye = g.localPosFromDOM(l.target, re, -1), we = L && L.parentNode == l.target ? ie(L) : l.target.childNodes.length, qe = g.localPosFromDOM(l.target, we, 1);
          return {
            from: ye,
            to: qe
          };
        } else
          return l.type == "attributes" ? {
            from: g.posAtStart - g.border,
            to: g.posAtEnd + g.border
          } : {
            from: g.posAtStart,
            to: g.posAtEnd,
            typeOver: l.target.nodeValue == l.oldValue
          };
      }
    }]), s;
  }(), Co = /* @__PURE__ */ new WeakMap(), To = !1;
  function bl(s) {
    if (!Co.has(s) && (Co.set(s, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(s.dom).whiteSpace) !== -1)) {
      if (s.requiresGeckoHackNode = Rt, To)
        return;
      console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), To = !0;
    }
  }
  function kl(s) {
    var h;
    function l($) {
      $.preventDefault(), $.stopImmediatePropagation(), h = $.getTargetRanges()[0];
    }
    s.dom.addEventListener("beforeinput", l, !0), document.execCommand("indent"), s.dom.removeEventListener("beforeinput", l, !0);
    var d = h.startContainer, g = h.startOffset, w = h.endContainer, E = h.endOffset, L = s.domAtPos(s.state.selection.anchor);
    if (pe(L.node, L.offset, w, E)) {
      var F = [w, E, d, g];
      d = F[0], g = F[1], w = F[2], E = F[3];
    }
    return {
      anchorNode: d,
      anchorOffset: g,
      focusNode: w,
      focusOffset: E
    };
  }
  function wl(s, h, l) {
    var d = s.docView.parseRange(h, l), g = d.node, w = d.fromOffset, E = d.toOffset, L = d.from, F = d.to, $ = s.domSelectionRange(), Y, ce = $.anchorNode;
    if (ce && s.dom.contains(ce.nodeType == 1 ? ce : ce.parentNode) && (Y = [{
      node: ce,
      offset: $.anchorOffset
    }], je($) || Y.push({
      node: $.focusNode,
      offset: $.focusOffset
    })), le && s.input.lastKeyCode === 8)
      for (var re = E; re > w; re--) {
        var ye = g.childNodes[re - 1], we = ye.pmViewDesc;
        if (ye.nodeName == "BR" && !we) {
          E = re;
          break;
        }
        if (!we || we.size)
          break;
      }
    var qe = s.state.doc, ot = s.someProp("domParser") || K.DOMParser.fromSchema(s.state.schema), De = qe.resolve(L), Dt = null, mt = ot.parse(g, {
      topNode: De.parent,
      topMatch: De.parent.contentMatchAt(De.index()),
      topOpen: !0,
      from: w,
      to: E,
      preserveWhitespace: De.parent.type.whitespace == "pre" ? "full" : !0,
      findPositions: Y,
      ruleFromNode: Cl,
      context: De
    });
    if (Y && Y[0].pos != null) {
      var Bt = Y[0].pos, bt = Y[1] && Y[1].pos;
      bt == null && (bt = Bt), Dt = {
        anchor: Bt + L,
        head: bt + L
      };
    }
    return {
      doc: mt,
      sel: Dt,
      from: L,
      to: F
    };
  }
  function Cl(s) {
    var h = s.pmViewDesc;
    if (h)
      return h.parseRule();
    if (s.nodeName == "BR" && s.parentNode) {
      if (ae && /^(ul|ol)$/i.test(s.parentNode.nodeName)) {
        var l = document.createElement("div");
        return l.appendChild(document.createElement("li")), {
          skip: l
        };
      } else if (s.parentNode.lastChild == s || ae && /^(tr|table)$/i.test(s.parentNode.nodeName))
        return {
          ignore: !0
        };
    } else if (s.nodeName == "IMG" && s.getAttribute("mark-placeholder"))
      return {
        ignore: !0
      };
    return null;
  }
  var Tl = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
  function Sl(s, h, l, d, g) {
    var w = s.input.compositionPendingChanges || (s.composing ? s.input.compositionID : 0);
    if (s.input.compositionPendingChanges = 0, h < 0) {
      var E = s.input.lastSelectionTime > Date.now() - 50 ? s.input.lastSelectionOrigin : null, L = zr(s, E);
      if (L && !s.state.selection.eq(L)) {
        if (le && Pe && s.input.lastKeyCode === 13 && Date.now() - 100 < s.input.lastKeyCodeTime && s.someProp("handleKeyDown", function(Gt) {
          return Gt(s, rt(13, "Enter"));
        }))
          return;
        var F = s.state.tr.setSelection(L);
        E == "pointer" ? F.setMeta("pointer", !0) : E == "key" && F.scrollIntoView(), w && F.setMeta("composition", w), s.dispatch(F);
      }
      return;
    }
    var $ = s.state.doc.resolve(h), Y = $.sharedDepth(l);
    h = $.before(Y + 1), l = s.state.doc.resolve(l).after(Y + 1);
    var ce = s.state.selection, re = wl(s, h, l), ye = s.state.doc, we = ye.slice(re.from, re.to), qe, ot;
    s.input.lastKeyCode === 8 && Date.now() - 100 < s.input.lastKeyCodeTime ? (qe = s.state.selection.to, ot = "end") : (qe = s.state.selection.from, ot = "start"), s.input.lastKeyCode = null;
    var De = Al(we.content, re.doc.content, re.from, qe, ot);
    if ((Z && s.input.lastIOSEnter > Date.now() - 225 || Pe) && g.some(function(Gt) {
      return Gt.nodeType == 1 && !Tl.test(Gt.nodeName);
    }) && (!De || De.endA >= De.endB) && s.someProp("handleKeyDown", function(Gt) {
      return Gt(s, rt(13, "Enter"));
    })) {
      s.input.lastIOSEnter = 0;
      return;
    }
    if (!De)
      if (d && ce instanceof _.TextSelection && !ce.empty && ce.$head.sameParent(ce.$anchor) && !s.composing && !(re.sel && re.sel.anchor != re.sel.head))
        De = {
          start: ce.from,
          endA: ce.to,
          endB: ce.to
        };
      else {
        if (re.sel) {
          var Dt = So(s, s.state.doc, re.sel);
          if (Dt && !Dt.eq(s.state.selection)) {
            var mt = s.state.tr.setSelection(Dt);
            w && mt.setMeta("composition", w), s.dispatch(mt);
          }
        }
        return;
      }
    if (le && s.cursorWrapper && re.sel && re.sel.anchor == s.cursorWrapper.deco.from && re.sel.head == re.sel.anchor) {
      var Bt = De.endB - De.start;
      re.sel = {
        anchor: re.sel.anchor + Bt,
        head: re.sel.anchor + Bt
      };
    }
    s.input.domChangeCount++, s.state.selection.from < s.state.selection.to && De.start == De.endB && s.state.selection instanceof _.TextSelection && (De.start > s.state.selection.from && De.start <= s.state.selection.from + 2 && s.state.selection.from >= re.from ? De.start = s.state.selection.from : De.endA < s.state.selection.to && De.endA >= s.state.selection.to - 2 && s.state.selection.to <= re.to && (De.endB += s.state.selection.to - De.endA, De.endA = s.state.selection.to)), At && lt <= 11 && De.endB == De.start + 1 && De.endA == De.start && De.start > re.from && re.doc.textBetween(De.start - re.from - 1, De.start - re.from + 1) == "  " && (De.start--, De.endA--, De.endB--);
    var bt = re.doc.resolveNoCache(De.start - re.from), kt = re.doc.resolveNoCache(De.endB - re.from), Vt = ye.resolve(De.start), Ir = bt.sameParent(kt) && bt.parent.inlineContent && Vt.end() >= De.endA, Jr;
    if ((Z && s.input.lastIOSEnter > Date.now() - 225 && (!Ir || g.some(function(Gt) {
      return Gt.nodeName == "DIV" || Gt.nodeName == "P";
    })) || !Ir && bt.pos < re.doc.content.size && !bt.sameParent(kt) && (Jr = _.Selection.findFrom(re.doc.resolve(bt.pos + 1), 1, !0)) && Jr.head == kt.pos) && s.someProp("handleKeyDown", function(Gt) {
      return Gt(s, rt(13, "Enter"));
    })) {
      s.input.lastIOSEnter = 0;
      return;
    }
    if (s.state.selection.anchor > De.start && xl(ye, De.start, De.endA, bt, kt) && s.someProp("handleKeyDown", function(Gt) {
      return Gt(s, rt(8, "Backspace"));
    })) {
      Pe && le && s.domObserver.suppressSelectionUpdates();
      return;
    }
    le && Pe && De.endB == De.start && (s.input.lastAndroidDelete = Date.now()), Pe && !Ir && bt.start() != kt.start() && kt.parentOffset == 0 && bt.depth == kt.depth && re.sel && re.sel.anchor == re.sel.head && re.sel.head == De.endA && (De.endB -= 2, kt = re.doc.resolveNoCache(De.endB - re.from), setTimeout(function() {
      s.someProp("handleKeyDown", function(Gt) {
        return Gt(s, rt(13, "Enter"));
      });
    }, 20));
    var ur = De.start, an = De.endA, Lr, ga, on;
    if (Ir) {
      if (bt.pos == kt.pos)
        At && lt <= 11 && bt.parentOffset == 0 && (s.domObserver.suppressSelectionUpdates(), setTimeout(function() {
          return $r(s);
        }, 20)), Lr = s.state.tr.delete(ur, an), ga = ye.resolve(De.start).marksAcross(ye.resolve(De.endA));
      else if (De.endA == De.endB && (on = El(bt.parent.content.cut(bt.parentOffset, kt.parentOffset), Vt.parent.content.cut(Vt.parentOffset, De.endA - Vt.start()))))
        Lr = s.state.tr, on.type == "add" ? Lr.addMark(ur, an, on.mark) : Lr.removeMark(ur, an, on.mark);
      else if (bt.parent.child(bt.index()).isText && bt.index() == kt.index() - (kt.textOffset ? 0 : 1)) {
        var ya = bt.parent.textBetween(bt.parentOffset, kt.parentOffset);
        if (s.someProp("handleTextInput", function(Gt) {
          return Gt(s, ur, an, ya);
        }))
          return;
        Lr = s.state.tr.insertText(ya, ur, an);
      }
    }
    if (Lr || (Lr = s.state.tr.replace(ur, an, re.doc.slice(De.start - re.from, De.endB - re.from))), re.sel) {
      var Yr = So(s, Lr.doc, re.sel);
      Yr && !(le && Pe && s.composing && Yr.empty && (De.start != De.endB || s.input.lastAndroidDelete < Date.now() - 100) && (Yr.head == ur || Yr.head == Lr.mapping.map(an) - 1) || At && Yr.empty && Yr.head == ur) && Lr.setSelection(Yr);
    }
    ga && Lr.ensureMarks(ga), w && Lr.setMeta("composition", w), s.dispatch(Lr.scrollIntoView());
  }
  function So(s, h, l) {
    return Math.max(l.anchor, l.head) > h.content.size ? null : ua(s, h.resolve(l.anchor), h.resolve(l.head));
  }
  function El(s, h) {
    for (var l = s.firstChild.marks, d = h.firstChild.marks, g = l, w = d, E, L, F, $ = 0; $ < d.length; $++)
      g = d[$].removeFromSet(g);
    for (var Y = 0; Y < l.length; Y++)
      w = l[Y].removeFromSet(w);
    if (g.length == 1 && w.length == 0)
      L = g[0], E = "add", F = function(we) {
        return we.mark(L.addToSet(we.marks));
      };
    else if (g.length == 0 && w.length == 1)
      L = w[0], E = "remove", F = function(we) {
        return we.mark(L.removeFromSet(we.marks));
      };
    else
      return null;
    for (var ce = [], re = 0; re < h.childCount; re++)
      ce.push(F(h.child(re)));
    if (K.Fragment.from(ce).eq(s))
      return {
        mark: L,
        type: E
      };
  }
  function xl(s, h, l, d, g) {
    if (!d.parent.isTextblock || l - h <= g.pos - d.pos || zi(d, !0, !1) < g.pos)
      return !1;
    var w = s.resolve(h);
    if (w.parentOffset < w.parent.content.size || !w.parent.isTextblock)
      return !1;
    var E = s.resolve(zi(w, !0, !0));
    return !E.parent.isTextblock || E.pos > l || zi(E, !0, !1) < l ? !1 : d.parent.content.cut(d.parentOffset).eq(E.parent.content);
  }
  function zi(s, h, l) {
    for (var d = s.depth, g = h ? s.end() : s.pos; d > 0 && (h || s.indexAfter(d) == s.node(d).childCount); )
      d--, g++, h = !1;
    if (l)
      for (var w = s.node(d).maybeChild(s.indexAfter(d)); w && !w.isLeaf; )
        w = w.firstChild, g++;
    return g;
  }
  function Al(s, h, l, d, g) {
    var w = s.findDiffStart(h, l);
    if (w == null)
      return null;
    var E = s.findDiffEnd(h, l + s.size, l + h.size), L = E.a, F = E.b;
    if (g == "end") {
      var $ = Math.max(0, w - Math.min(L, F));
      d -= L + $ - w;
    }
    if (L < w && s.size < h.size) {
      var Y = d <= w && d >= L ? w - d : 0;
      w -= Y, F = w + (F - L), L = w;
    } else if (F < w) {
      var ce = d <= w && d >= F ? w - d : 0;
      w -= ce, L = w + (L - F), F = w;
    }
    return {
      start: w,
      endA: L,
      endB: F
    };
  }
  var Ml = da, Ll = Na, Ol = qa, Dl = function() {
    function s(h, l) {
      var d = this;
      M(this, s), this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new ii(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = l, this.state = l.state, this.directPlugins = l.plugins || [], this.directPlugins.forEach(Lo), this.dispatch = this.dispatch.bind(this), this.dom = h && h.mount || document.createElement("div"), h && (h.appendChild ? h.appendChild(this.dom) : typeof h == "function" ? h(this.dom) : h.mount && (this.mounted = !0)), this.editable = Ao(this), xo(this), this.nodeViews = Mo(this), this.docView = Ae(this.state.doc, Eo(this), Ui(this), this.dom, this), this.domObserver = new yl(this, function(g, w, E, L) {
        return Sl(d, g, w, E, L);
      }), this.domObserver.start(), Pi(this), this.updatePluginViews();
    }
    return q(s, [{
      key: "composing",
      get: function() {
        return this.input.composing;
      }
    }, {
      key: "props",
      get: function() {
        if (this._props.state != this.state) {
          var l = this._props;
          this._props = {};
          for (var d in l)
            this._props[d] = l[d];
          this._props.state = this.state;
        }
        return this._props;
      }
    }, {
      key: "update",
      value: function(l) {
        l.handleDOMEvents != this._props.handleDOMEvents && Bi(this);
        var d = this._props;
        this._props = l, l.plugins && (l.plugins.forEach(Lo), this.directPlugins = l.plugins), this.updateStateInner(l.state, d);
      }
    }, {
      key: "setProps",
      value: function(l) {
        var d = {};
        for (var g in this._props)
          d[g] = this._props[g];
        d.state = this.state;
        for (var w in l)
          d[w] = l[w];
        this.update(d);
      }
    }, {
      key: "updateState",
      value: function(l) {
        this.updateStateInner(l, this._props);
      }
    }, {
      key: "updateStateInner",
      value: function(l, d) {
        var g = this.state, w = !1, E = !1;
        l.storedMarks && this.composing && (po(this), E = !0), this.state = l;
        var L = g.plugins != l.plugins || this._props.plugins != d.plugins;
        if (L || this._props.plugins != d.plugins || this._props.nodeViews != d.nodeViews) {
          var F = Mo(this);
          Rl(F, this.nodeViews) && (this.nodeViews = F, w = !0);
        }
        (L || d.handleDOMEvents != this._props.handleDOMEvents) && Bi(this), this.editable = Ao(this), xo(this);
        var $ = Ui(this), Y = Eo(this), ce = g.plugins != l.plugins && !g.doc.eq(l.doc) ? "reset" : l.scrollToSelection > g.scrollToSelection ? "to selection" : "preserve", re = w || !this.docView.matchesNode(l.doc, Y, $);
        (re || !l.selection.eq(g.selection)) && (E = !0);
        var ye = ce == "preserve" && E && this.dom.style.overflowAnchor == null && qr(this);
        if (E) {
          this.domObserver.stop();
          var we = re && (At || le) && !this.composing && !g.selection.empty && !l.selection.empty && Nl(g.selection, l.selection);
          if (re) {
            var qe = le ? this.trackWrites = this.domSelectionRange().focusNode : null;
            (w || !this.docView.update(l.doc, Y, $, this)) && (this.docView.updateOuterDeco([]), this.docView.destroy(), this.docView = Ae(l.doc, Y, $, this.dom, this)), qe && !this.trackWrites && (we = !0);
          }
          we || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && La(this)) ? $r(this, we) : (xa(this, l.selection), this.domObserver.setCurSelection()), this.domObserver.start();
        }
        this.updatePluginViews(g), ce == "reset" ? this.dom.scrollTop = 0 : ce == "to selection" ? this.scrollToSelection() : ye && _t(ye);
      }
    }, {
      key: "scrollToSelection",
      value: function() {
        var l = this, d = this.domSelectionRange().focusNode;
        if (!this.someProp("handleScrollToSelection", function(w) {
          return w(l);
        }))
          if (this.state.selection instanceof _.NodeSelection) {
            var g = this.docView.domAfterPos(this.state.selection.from);
            g.nodeType == 1 && Kt(this, g.getBoundingClientRect(), d);
          } else
            Kt(this, this.coordsAtPos(this.state.selection.head, 1), d);
      }
    }, {
      key: "destroyPluginViews",
      value: function() {
        for (var l; l = this.pluginViews.pop(); )
          l.destroy && l.destroy();
      }
    }, {
      key: "updatePluginViews",
      value: function(l) {
        if (!l || l.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
          this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
          for (var d = 0; d < this.directPlugins.length; d++) {
            var g = this.directPlugins[d];
            g.spec.view && this.pluginViews.push(g.spec.view(this));
          }
          for (var w = 0; w < this.state.plugins.length; w++) {
            var E = this.state.plugins[w];
            E.spec.view && this.pluginViews.push(E.spec.view(this));
          }
        } else
          for (var L = 0; L < this.pluginViews.length; L++) {
            var F = this.pluginViews[L];
            F.update && F.update(this, l);
          }
      }
    }, {
      key: "someProp",
      value: function(l, d) {
        var g = this._props && this._props[l], w;
        if (g != null && (w = d ? d(g) : g))
          return w;
        for (var E = 0; E < this.directPlugins.length; E++) {
          var L = this.directPlugins[E].props[l];
          if (L != null && (w = d ? d(L) : L))
            return w;
        }
        var F = this.state.plugins;
        if (F)
          for (var $ = 0; $ < F.length; $++) {
            var Y = F[$].props[l];
            if (Y != null && (w = d ? d(Y) : Y))
              return w;
          }
      }
    }, {
      key: "hasFocus",
      value: function() {
        if (At) {
          var l = this.root.activeElement;
          if (l == this.dom)
            return !0;
          if (!l || !this.dom.contains(l))
            return !1;
          for (; l && this.dom != l && this.dom.contains(l); ) {
            if (l.contentEditable == "false")
              return !1;
            l = l.parentElement;
          }
          return !0;
        }
        return this.root.activeElement == this.dom;
      }
    }, {
      key: "focus",
      value: function() {
        this.domObserver.stop(), this.editable && Fr(this.dom), $r(this), this.domObserver.start();
      }
    }, {
      key: "root",
      get: function() {
        var l = this, d = this._root;
        if (d == null)
          for (var g = function(F) {
            if (F.nodeType == 9 || F.nodeType == 11 && F.host)
              return F.getSelection || (Object.getPrototypeOf(F).getSelection = function() {
                return F.ownerDocument.getSelection();
              }), {
                v: l._root = F
              };
          }, w = this.dom.parentNode; w; w = w.parentNode) {
            var E = g(w);
            if (t(E) === "object")
              return E.v;
          }
        return d || document;
      }
    }, {
      key: "posAtCoords",
      value: function(l) {
        return lr(this, l);
      }
    }, {
      key: "coordsAtPos",
      value: function(l) {
        var d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        return Cr(this, l, d);
      }
    }, {
      key: "domAtPos",
      value: function(l) {
        var d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        return this.docView.domFromPos(l, d);
      }
    }, {
      key: "nodeDOM",
      value: function(l) {
        var d = this.docView.descAt(l);
        return d ? d.nodeDOM : null;
      }
    }, {
      key: "posAtDOM",
      value: function(l, d) {
        var g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1, w = this.docView.posFromDOM(l, d, g);
        if (w == null)
          throw new RangeError("DOM position not inside the editor");
        return w;
      }
    }, {
      key: "endOfTextblock",
      value: function(l, d) {
        return H(this, d || this.state, l);
      }
    }, {
      key: "pasteHTML",
      value: function(l, d) {
        return Fa(this, "", l, !1, d || new ClipboardEvent("paste"));
      }
    }, {
      key: "pasteText",
      value: function(l, d) {
        return Fa(this, l, null, !0, d || new ClipboardEvent("paste"));
      }
    }, {
      key: "destroy",
      value: function() {
        this.docView && (Ks(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], Ui(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null);
      }
    }, {
      key: "isDestroyed",
      get: function() {
        return this.docView == null;
      }
    }, {
      key: "dispatchEvent",
      value: function(l) {
        return Ys(this, l);
      }
    }, {
      key: "dispatch",
      value: function(l) {
        var d = this._props.dispatchTransaction;
        d ? d.call(this, l) : this.updateState(this.state.apply(l));
      }
    }, {
      key: "domSelectionRange",
      value: function() {
        return ae && this.root.nodeType === 11 && at(this.dom.ownerDocument) == this.dom ? kl(this) : this.domSelection();
      }
    }, {
      key: "domSelection",
      value: function() {
        return this.root.getSelection();
      }
    }]), s;
  }();
  function Eo(s) {
    var h = /* @__PURE__ */ Object.create(null);
    return h.class = "ProseMirror", h.contenteditable = String(s.editable), s.someProp("attributes", function(l) {
      if (typeof l == "function" && (l = l(s.state)), l)
        for (var d in l)
          d == "class" ? h.class += " " + l[d] : d == "style" ? h.style = (h.style ? h.style + ";" : "") + l[d] : !h[d] && d != "contenteditable" && d != "nodeName" && (h[d] = String(l[d]));
    }), h.translate || (h.translate = "no"), [zn.node(0, s.state.doc.content.size, h)];
  }
  function xo(s) {
    if (s.markCursor) {
      var h = document.createElement("img");
      h.className = "ProseMirror-separator", h.setAttribute("mark-placeholder", "true"), h.setAttribute("alt", ""), s.cursorWrapper = {
        dom: h,
        deco: zn.widget(s.state.selection.head, h, {
          raw: !0,
          marks: s.markCursor
        })
      };
    } else
      s.cursorWrapper = null;
  }
  function Ao(s) {
    return !s.someProp("editable", function(h) {
      return h(s.state) === !1;
    });
  }
  function Nl(s, h) {
    var l = Math.min(s.$anchor.sharedDepth(s.head), h.$anchor.sharedDepth(h.head));
    return s.$anchor.start(l) != h.$anchor.start(l);
  }
  function Mo(s) {
    var h = /* @__PURE__ */ Object.create(null);
    function l(d) {
      for (var g in d)
        Object.prototype.hasOwnProperty.call(h, g) || (h[g] = d[g]);
    }
    return s.someProp("nodeViews", l), s.someProp("markViews", l), h;
  }
  function Rl(s, h) {
    var l = 0, d = 0;
    for (var g in s) {
      if (s[g] != h[g])
        return !0;
      l++;
    }
    for (var w in h)
      d++;
    return l != d;
  }
  function Lo(s) {
    if (s.spec.state || s.spec.filterTransaction || s.spec.appendTransaction)
      throw new RangeError("Plugins passed directly to the view must not have a state component");
  }
  return Zn.Decoration = zn, Zn.DecorationSet = Kr, Zn.EditorView = Dl, Zn.__endComposition = Ol, Zn.__parseFromClipboard = Ll, Zn.__serializeForClipboard = Ml, Zn;
}
var ia = Gp(), zt = Rs(), nt = oo(), Wi = {}, pi = {}, Sv;
function iJ() {
  if (Sv)
    return pi;
  Sv = 1, Object.defineProperty(pi, "__esModule", { value: !0 });
  for (var t = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  }, e = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  }, r = typeof navigator < "u" && /Mac/.test(navigator.platform), n = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent), a = 0; a < 10; a++)
    t[48 + a] = t[96 + a] = String(a);
  for (var a = 1; a <= 24; a++)
    t[a + 111] = "F" + a;
  for (var a = 65; a <= 90; a++)
    t[a] = String.fromCharCode(a + 32), e[a] = String.fromCharCode(a);
  for (var i in t)
    e.hasOwnProperty(i) || (e[i] = t[i]);
  function o(u) {
    var m = r && u.metaKey && u.shiftKey && !u.ctrlKey && !u.altKey || n && u.shiftKey && u.key && u.key.length == 1 || u.key == "Unidentified", y = !m && u.key || (u.shiftKey ? e : t)[u.keyCode] || u.key || "Unidentified";
    return y == "Esc" && (y = "Escape"), y == "Del" && (y = "Delete"), y == "Left" && (y = "ArrowLeft"), y == "Up" && (y = "ArrowUp"), y == "Right" && (y = "ArrowRight"), y == "Down" && (y = "ArrowDown"), y;
  }
  return pi.base = t, pi.keyName = o, pi.shift = e, pi;
}
var Ev;
function Kp() {
  if (Ev)
    return Wi;
  Ev = 1, Object.defineProperty(Wi, "__esModule", {
    value: !0
  });
  var t = iJ(), e = oo(), r = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
  function n(m) {
    var y = m.split(/-(?!$)/), C = y[y.length - 1];
    C == "Space" && (C = " ");
    for (var T, x, M, P, q = 0; q < y.length - 1; q++) {
      var _ = y[q];
      if (/^(cmd|meta|m)$/i.test(_))
        P = !0;
      else if (/^a(lt)?$/i.test(_))
        T = !0;
      else if (/^(c|ctrl|control)$/i.test(_))
        x = !0;
      else if (/^s(hift)?$/i.test(_))
        M = !0;
      else if (/^mod$/i.test(_))
        r ? P = !0 : x = !0;
      else
        throw new Error("Unrecognized modifier name: " + _);
    }
    return T && (C = "Alt-" + C), x && (C = "Ctrl-" + C), P && (C = "Meta-" + C), M && (C = "Shift-" + C), C;
  }
  function a(m) {
    var y = /* @__PURE__ */ Object.create(null);
    for (var C in m)
      y[n(C)] = m[C];
    return y;
  }
  function i(m, y) {
    var C = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
    return y.altKey && (m = "Alt-" + m), y.ctrlKey && (m = "Ctrl-" + m), y.metaKey && (m = "Meta-" + m), C && y.shiftKey && (m = "Shift-" + m), m;
  }
  function o(m) {
    return new e.Plugin({
      props: {
        handleKeyDown: u(m)
      }
    });
  }
  function u(m) {
    var y = a(m);
    return function(C, T) {
      var x = t.keyName(T), M, P = y[i(x, T)];
      if (P && P(C.state, C.dispatch, C))
        return !0;
      if (x.length == 1 && x != " ") {
        if (T.shiftKey) {
          var q = y[i(x, T, !1)];
          if (q && q(C.state, C.dispatch, C))
            return !0;
        }
        if ((T.shiftKey || T.altKey || T.metaKey || x.charCodeAt(0) > 127) && (M = t.base[T.keyCode]) && M != x) {
          var _ = y[i(M, T)];
          if (_ && _(C.state, C.dispatch, C))
            return !0;
        }
      }
      return !1;
    };
  }
  return Wi.keydownHandler = u, Wi.keymap = o, Wi;
}
var ro = Kp();
const pc = (t, e) => t.selection.empty ? !1 : (e && e(t.tr.deleteSelection().scrollIntoView()), !0);
function oJ(t, e) {
  let { $cursor: r } = t.selection;
  return !r || (e ? !e.endOfTextblock("backward", t) : r.parentOffset > 0) ? null : r;
}
const sJ = (t, e, r) => {
  let n = oJ(t, r);
  if (!n)
    return !1;
  let a = Jp(n);
  if (!a) {
    let o = n.blockRange(), u = o && zt.liftTarget(o);
    return u == null ? !1 : (e && e(t.tr.lift(o, u).scrollIntoView()), !0);
  }
  let i = a.nodeBefore;
  if (!i.type.spec.isolating && eh(t, a, e))
    return !0;
  if (n.parent.content.size == 0 && (wi(i, "end") || nt.NodeSelection.isSelectable(i))) {
    let o = zt.replaceStep(t.doc, n.before(), n.after(), Qe.Slice.empty);
    if (o && o.slice.size < o.to - o.from) {
      if (e) {
        let u = t.tr.step(o);
        u.setSelection(wi(i, "end") ? nt.Selection.findFrom(u.doc.resolve(u.mapping.map(a.pos, -1)), -1) : nt.NodeSelection.create(u.doc, a.pos - i.nodeSize)), e(u.scrollIntoView());
      }
      return !0;
    }
  }
  return i.isAtom && a.depth == n.depth - 1 ? (e && e(t.tr.delete(a.pos - i.nodeSize, a.pos).scrollIntoView()), !0) : !1;
};
function wi(t, e, r = !1) {
  for (let n = t; n; n = e == "start" ? n.firstChild : n.lastChild) {
    if (n.isTextblock)
      return !0;
    if (r && n.childCount != 1)
      return !1;
  }
  return !1;
}
const lJ = (t, e, r) => {
  let { $head: n, empty: a } = t.selection, i = n;
  if (!a)
    return !1;
  if (n.parent.isTextblock) {
    if (r ? !r.endOfTextblock("backward", t) : n.parentOffset > 0)
      return !1;
    i = Jp(n);
  }
  let o = i && i.nodeBefore;
  return !o || !nt.NodeSelection.isSelectable(o) ? !1 : (e && e(t.tr.setSelection(nt.NodeSelection.create(t.doc, i.pos - o.nodeSize)).scrollIntoView()), !0);
};
function Jp(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      if (t.index(e) > 0)
        return t.doc.resolve(t.before(e + 1));
      if (t.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function uJ(t, e) {
  let { $cursor: r } = t.selection;
  return !r || (e ? !e.endOfTextblock("forward", t) : r.parentOffset < r.parent.content.size) ? null : r;
}
const Yp = (t, e, r) => {
  let n = uJ(t, r);
  if (!n)
    return !1;
  let a = Zp(n);
  if (!a)
    return !1;
  let i = a.nodeAfter;
  if (eh(t, a, e))
    return !0;
  if (n.parent.content.size == 0 && (wi(i, "start") || nt.NodeSelection.isSelectable(i))) {
    let o = zt.replaceStep(t.doc, n.before(), n.after(), Qe.Slice.empty);
    if (o && o.slice.size < o.to - o.from) {
      if (e) {
        let u = t.tr.step(o);
        u.setSelection(wi(i, "start") ? nt.Selection.findFrom(u.doc.resolve(u.mapping.map(a.pos)), 1) : nt.NodeSelection.create(u.doc, u.mapping.map(a.pos))), e(u.scrollIntoView());
      }
      return !0;
    }
  }
  return i.isAtom && a.depth == n.depth - 1 ? (e && e(t.tr.delete(a.pos, a.pos + i.nodeSize).scrollIntoView()), !0) : !1;
}, cJ = (t, e, r) => {
  let { $head: n, empty: a } = t.selection, i = n;
  if (!a)
    return !1;
  if (n.parent.isTextblock) {
    if (r ? !r.endOfTextblock("forward", t) : n.parentOffset < n.parent.content.size)
      return !1;
    i = Zp(n);
  }
  let o = i && i.nodeAfter;
  return !o || !nt.NodeSelection.isSelectable(o) ? !1 : (e && e(t.tr.setSelection(nt.NodeSelection.create(t.doc, i.pos)).scrollIntoView()), !0);
};
function Zp(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      let r = t.node(e);
      if (t.index(e) + 1 < r.childCount)
        return t.doc.resolve(t.after(e + 1));
      if (r.type.spec.isolating)
        break;
    }
  return null;
}
const Qp = (t, e) => {
  let { $head: r, $anchor: n } = t.selection;
  return !r.parent.type.spec.code || !r.sameParent(n) ? !1 : (e && e(t.tr.insertText(`
`).scrollIntoView()), !0);
};
function hc(t) {
  for (let e = 0; e < t.edgeCount; e++) {
    let { type: r } = t.edge(e);
    if (r.isTextblock && !r.hasRequiredAttrs())
      return r;
  }
  return null;
}
const mc = (t, e) => {
  let { $head: r, $anchor: n } = t.selection;
  if (!r.parent.type.spec.code || !r.sameParent(n))
    return !1;
  let a = r.node(-1), i = r.indexAfter(-1), o = hc(a.contentMatchAt(i));
  if (!o || !a.canReplaceWith(i, i, o))
    return !1;
  if (e) {
    let u = r.after(), m = t.tr.replaceWith(u, u, o.createAndFill());
    m.setSelection(nt.Selection.near(m.doc.resolve(u), 1)), e(m.scrollIntoView());
  }
  return !0;
}, fJ = (t, e) => {
  let r = t.selection, { $from: n, $to: a } = r;
  if (r instanceof nt.AllSelection || n.parent.inlineContent || a.parent.inlineContent)
    return !1;
  let i = hc(a.parent.contentMatchAt(a.indexAfter()));
  if (!i || !i.isTextblock)
    return !1;
  if (e) {
    let o = (!n.parentOffset && a.index() < a.parent.childCount ? n : a).pos, u = t.tr.insert(o, i.createAndFill());
    u.setSelection(nt.TextSelection.create(u.doc, o + 1)), e(u.scrollIntoView());
  }
  return !0;
}, vJ = (t, e) => {
  let { $cursor: r } = t.selection;
  if (!r || r.parent.content.size)
    return !1;
  if (r.depth > 1 && r.after() != r.end(-1)) {
    let i = r.before();
    if (zt.canSplit(t.doc, i))
      return e && e(t.tr.split(i).scrollIntoView()), !0;
  }
  let n = r.blockRange(), a = n && zt.liftTarget(n);
  return a == null ? !1 : (e && e(t.tr.lift(n, a).scrollIntoView()), !0);
};
function dJ(t) {
  return (e, r) => {
    let { $from: n, $to: a } = e.selection;
    if (e.selection instanceof nt.NodeSelection && e.selection.node.isBlock)
      return !n.parentOffset || !zt.canSplit(e.doc, n.pos) ? !1 : (r && r(e.tr.split(n.pos).scrollIntoView()), !0);
    if (!n.parent.isBlock)
      return !1;
    if (r) {
      let i = a.parentOffset == a.parent.content.size, o = e.tr;
      (e.selection instanceof nt.TextSelection || e.selection instanceof nt.AllSelection) && o.deleteSelection();
      let u = n.depth == 0 ? null : hc(n.node(-1).contentMatchAt(n.indexAfter(-1))), m = t && t(a.parent, i), y = m ? [m] : i && u ? [{ type: u }] : void 0, C = zt.canSplit(o.doc, o.mapping.map(n.pos), 1, y);
      if (!y && !C && zt.canSplit(o.doc, o.mapping.map(n.pos), 1, u ? [{ type: u }] : void 0) && (u && (y = [{ type: u }]), C = !0), C && (o.split(o.mapping.map(n.pos), 1, y), !i && !n.parentOffset && n.parent.type != u)) {
        let T = o.mapping.map(n.before()), x = o.doc.resolve(T);
        u && n.node(-1).canReplaceWith(x.index(), x.index() + 1, u) && o.setNodeMarkup(o.mapping.map(n.before()), u);
      }
      r(o.scrollIntoView());
    }
    return !0;
  };
}
const pJ = dJ(), Xp = (t, e) => (e && e(t.tr.setSelection(new nt.AllSelection(t.doc))), !0);
function hJ(t, e, r) {
  let n = e.nodeBefore, a = e.nodeAfter, i = e.index();
  return !n || !a || !n.type.compatibleContent(a.type) ? !1 : !n.content.size && e.parent.canReplace(i - 1, i) ? (r && r(t.tr.delete(e.pos - n.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(i, i + 1) || !(a.isTextblock || zt.canJoin(t.doc, e.pos)) ? !1 : (r && r(t.tr.clearIncompatible(e.pos, n.type, n.contentMatchAt(n.childCount)).join(e.pos).scrollIntoView()), !0);
}
function eh(t, e, r) {
  let n = e.nodeBefore, a = e.nodeAfter, i, o;
  if (n.type.spec.isolating || a.type.spec.isolating)
    return !1;
  if (hJ(t, e, r))
    return !0;
  let u = e.parent.canReplace(e.index(), e.index() + 1);
  if (u && (i = (o = n.contentMatchAt(n.childCount)).findWrapping(a.type)) && o.matchType(i[0] || a.type).validEnd) {
    if (r) {
      let T = e.pos + a.nodeSize, x = Qe.Fragment.empty;
      for (let q = i.length - 1; q >= 0; q--)
        x = Qe.Fragment.from(i[q].create(null, x));
      x = Qe.Fragment.from(n.copy(x));
      let M = t.tr.step(new zt.ReplaceAroundStep(e.pos - 1, T, e.pos, T, new Qe.Slice(x, 1, 0), i.length, !0)), P = T + 2 * i.length;
      zt.canJoin(M.doc, P) && M.join(P), r(M.scrollIntoView());
    }
    return !0;
  }
  let m = nt.Selection.findFrom(e, 1), y = m && m.$from.blockRange(m.$to), C = y && zt.liftTarget(y);
  if (C != null && C >= e.depth)
    return r && r(t.tr.lift(y, C).scrollIntoView()), !0;
  if (u && wi(a, "start", !0) && wi(n, "end")) {
    let T = n, x = [];
    for (; x.push(T), !T.isTextblock; )
      T = T.lastChild;
    let M = a, P = 1;
    for (; !M.isTextblock; M = M.firstChild)
      P++;
    if (T.canReplace(T.childCount, T.childCount, M.content)) {
      if (r) {
        let q = Qe.Fragment.empty;
        for (let K = x.length - 1; K >= 0; K--)
          q = Qe.Fragment.from(x[K].copy(q));
        let _ = t.tr.step(new zt.ReplaceAroundStep(e.pos - x.length, e.pos + a.nodeSize, e.pos + P, e.pos + a.nodeSize - P, new Qe.Slice(q, x.length, 0), 0, !0));
        r(_.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function th(t) {
  return function(e, r) {
    let n = e.selection, a = t < 0 ? n.$from : n.$to, i = a.depth;
    for (; a.node(i).isInline; ) {
      if (!i)
        return !1;
      i--;
    }
    return a.node(i).isTextblock ? (r && r(e.tr.setSelection(nt.TextSelection.create(e.doc, t < 0 ? a.start(i) : a.end(i)))), !0) : !1;
  };
}
const mJ = th(-1), gJ = th(1);
function yJ(t, e = null) {
  return function(r, n) {
    let { $from: a, $to: i } = r.selection, o = a.blockRange(i), u = o && zt.findWrapping(o, t, e);
    return u ? (n && n(r.tr.wrap(o, u).scrollIntoView()), !0) : !1;
  };
}
function gc(t, e = null) {
  return function(r, n) {
    let a = !1;
    for (let i = 0; i < r.selection.ranges.length && !a; i++) {
      let { $from: { pos: o }, $to: { pos: u } } = r.selection.ranges[i];
      r.doc.nodesBetween(o, u, (m, y) => {
        if (a)
          return !1;
        if (!(!m.isTextblock || m.hasMarkup(t, e)))
          if (m.type == t)
            a = !0;
          else {
            let C = r.doc.resolve(y), T = C.index();
            a = C.parent.canReplaceWith(T, T + 1, t);
          }
      });
    }
    if (!a)
      return !1;
    if (n) {
      let i = r.tr;
      for (let o = 0; o < r.selection.ranges.length; o++) {
        let { $from: { pos: u }, $to: { pos: m } } = r.selection.ranges[o];
        i.setBlockType(u, m, t, e);
      }
      n(i.scrollIntoView());
    }
    return !0;
  };
}
function bJ(t, e, r) {
  for (let n = 0; n < e.length; n++) {
    let { $from: a, $to: i } = e[n], o = a.depth == 0 ? t.inlineContent && t.type.allowsMarkType(r) : !1;
    if (t.nodesBetween(a.pos, i.pos, (u) => {
      if (o)
        return !1;
      o = u.inlineContent && u.type.allowsMarkType(r);
    }), o)
      return !0;
  }
  return !1;
}
function so(t, e = null) {
  return function(r, n) {
    let { empty: a, $cursor: i, ranges: o } = r.selection;
    if (a && !i || !bJ(r.doc, o, t))
      return !1;
    if (n)
      if (i)
        t.isInSet(r.storedMarks || i.marks()) ? n(r.tr.removeStoredMark(t)) : n(r.tr.addStoredMark(t.create(e)));
      else {
        let u = !1, m = r.tr;
        for (let y = 0; !u && y < o.length; y++) {
          let { $from: C, $to: T } = o[y];
          u = r.doc.rangeHasMark(C.pos, T.pos, t);
        }
        for (let y = 0; y < o.length; y++) {
          let { $from: C, $to: T } = o[y];
          if (u)
            m.removeMark(C.pos, T.pos, t);
          else {
            let x = C.pos, M = T.pos, P = C.nodeAfter, q = T.nodeBefore, _ = P && P.isText ? /^\s*/.exec(P.text)[0].length : 0, K = q && q.isText ? /\s*$/.exec(q.text)[0].length : 0;
            x + _ < M && (x += _, M -= K), m.addMark(x, M, t.create(e));
          }
        }
        n(m.scrollIntoView());
      }
    return !0;
  };
}
function Is(...t) {
  return function(e, r, n) {
    for (let a = 0; a < t.length; a++)
      if (t[a](e, r, n))
        return !0;
    return !1;
  };
}
let pu = Is(pc, sJ, lJ), xv = Is(pc, Yp, cJ);
const Xn = {
  Enter: Is(Qp, fJ, vJ, pJ),
  "Mod-Enter": mc,
  Backspace: pu,
  "Mod-Backspace": pu,
  "Shift-Backspace": pu,
  Delete: xv,
  "Mod-Delete": xv,
  "Mod-a": Xp
}, rh = {
  "Ctrl-h": Xn.Backspace,
  "Alt-Backspace": Xn["Mod-Backspace"],
  "Ctrl-d": Xn.Delete,
  "Ctrl-Alt-Backspace": Xn["Mod-Delete"],
  "Alt-Delete": Xn["Mod-Delete"],
  "Alt-d": Xn["Mod-Delete"],
  "Ctrl-a": mJ,
  "Ctrl-e": gJ
};
for (let t in Xn)
  rh[t] = Xn[t];
const kJ = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform ? os.platform() == "darwin" : !1, Av = kJ ? rh : Xn;
var Pr = {}, Mv;
function nh() {
  if (Mv)
    return Pr;
  Mv = 1;
  function t(ee, oe) {
    for (var ue = 0; ue < oe.length; ue++) {
      var pe = oe[ue];
      pe.enumerable = pe.enumerable || !1, pe.configurable = !0, "value" in pe && (pe.writable = !0), Object.defineProperty(ee, pe.key, pe);
    }
  }
  function e(ee, oe, ue) {
    return oe && t(ee.prototype, oe), ue && t(ee, ue), Object.defineProperty(ee, "prototype", { writable: !1 }), ee;
  }
  function r(ee, oe) {
    if (!(ee instanceof oe))
      throw new TypeError("Cannot call a class as a function");
  }
  Object.defineProperty(Pr, "__esModule", {
    value: !0
  });
  var n = oo(), a = Rs(), i = e(function ee(oe, ue) {
    r(this, ee), this.match = oe, this.match = oe, this.handler = typeof ue == "string" ? o(ue) : ue;
  });
  function o(ee) {
    return function(oe, ue, pe, Se) {
      var Re = ee;
      if (ue[1]) {
        var Me = ue[0].lastIndexOf(ue[1]);
        Re += ue[0].slice(Me + ue[1].length), pe += Me;
        var ze = pe - Se;
        ze > 0 && (Re = ue[0].slice(Me - ze, Me) + Re, pe = Se);
      }
      return oe.tr.insertText(Re, pe, Se);
    };
  }
  var u = 500;
  function m(ee) {
    var oe = ee.rules, ue = new n.Plugin({
      state: {
        init: function() {
          return null;
        },
        apply: function(Se, Re) {
          var Me = Se.getMeta(this);
          return Me || (Se.selectionSet || Se.docChanged ? null : Re);
        }
      },
      props: {
        handleTextInput: function(Se, Re, Me, ze) {
          return y(Se, Re, Me, ze, oe, ue);
        },
        handleDOMEvents: {
          compositionend: function(Se) {
            setTimeout(function() {
              var Re = Se.state.selection.$cursor;
              Re && y(Se, Re.pos, Re.pos, "", oe, ue);
            });
          }
        }
      },
      isInputRules: !0
    });
    return ue;
  }
  function y(ee, oe, ue, pe, Se, Re) {
    if (ee.composing)
      return !1;
    var Me = ee.state, ze = Me.doc.resolve(oe);
    if (ze.parent.type.spec.code)
      return !1;
    for (var vt = ze.parent.textBetween(Math.max(0, ze.parentOffset - u), ze.parentOffset, null, "￼") + pe, je = 0; je < Se.length; je++) {
      var rt = Se[je].match.exec(vt), at = rt && Se[je].handler(Me, rt, oe - (rt[0].length - pe.length), ue);
      if (at)
        return ee.dispatch(at.setMeta(Re, {
          transform: at,
          from: oe,
          to: ue,
          text: pe
        })), !0;
    }
    return !1;
  }
  var C = function(oe, ue) {
    for (var pe = oe.plugins, Se = 0; Se < pe.length; Se++) {
      var Re = pe[Se], Me = void 0;
      if (Re.spec.isInputRules && (Me = Re.getState(oe))) {
        if (ue) {
          for (var ze = oe.tr, vt = Me.transform, je = vt.steps.length - 1; je >= 0; je--)
            ze.step(vt.steps[je].invert(vt.docs[je]));
          if (Me.text) {
            var rt = ze.doc.resolve(Me.from).marks();
            ze.replaceWith(Me.from, Me.to, oe.schema.text(Me.text, rt));
          } else
            ze.delete(Me.from, Me.to);
          ue(ze);
        }
        return !0;
      }
    }
    return !1;
  }, T = new i(/--$/, "—"), x = new i(/\.\.\.$/, "…"), M = new i(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "“"), P = new i(/"$/, "”"), q = new i(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "‘"), _ = new i(/'$/, "’"), K = [M, P, q, _];
  function X(ee, oe) {
    var ue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, pe = arguments.length > 3 ? arguments[3] : void 0;
    return new i(ee, function(Se, Re, Me, ze) {
      var vt = ue instanceof Function ? ue(Re) : ue, je = Se.tr.delete(Me, ze), rt = je.doc.resolve(Me), at = rt.blockRange(), St = at && a.findWrapping(at, oe, vt);
      if (!St)
        return null;
      je.wrap(at, St);
      var pt = je.doc.resolve(Me - 1).nodeBefore;
      return pt && pt.type == oe && a.canJoin(je.doc, Me - 1) && (!pe || pe(Re, pt)) && je.join(Me - 1), je;
    });
  }
  function ie(ee, oe) {
    var ue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    return new i(ee, function(pe, Se, Re, Me) {
      var ze = pe.doc.resolve(Re), vt = ue instanceof Function ? ue(Se) : ue;
      return ze.node(-1).canReplaceWith(ze.index(-1), ze.indexAfter(-1), oe) ? pe.tr.delete(Re, Me).setBlockType(Re, Re, oe, vt) : null;
    });
  }
  return Pr.InputRule = i, Pr.closeDoubleQuote = P, Pr.closeSingleQuote = _, Pr.ellipsis = x, Pr.emDash = T, Pr.inputRules = m, Pr.openDoubleQuote = M, Pr.openSingleQuote = q, Pr.smartQuotes = K, Pr.textblockTypeInputRule = ie, Pr.undoInputRule = C, Pr.wrappingInputRule = X, Pr;
}
var Xi = nh(), ps = 200, kr = function() {
};
kr.prototype.append = function(e) {
  return e.length ? (e = kr.from(e), !this.length && e || e.length < ps && this.leafAppend(e) || this.length < ps && e.leafPrepend(this) || this.appendInner(e)) : this;
};
kr.prototype.prepend = function(e) {
  return e.length ? kr.from(e).append(this) : this;
};
kr.prototype.appendInner = function(e) {
  return new wJ(this, e);
};
kr.prototype.slice = function(e, r) {
  return e === void 0 && (e = 0), r === void 0 && (r = this.length), e >= r ? kr.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, r));
};
kr.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
kr.prototype.forEach = function(e, r, n) {
  r === void 0 && (r = 0), n === void 0 && (n = this.length), r <= n ? this.forEachInner(e, r, n, 0) : this.forEachInvertedInner(e, r, n, 0);
};
kr.prototype.map = function(e, r, n) {
  r === void 0 && (r = 0), n === void 0 && (n = this.length);
  var a = [];
  return this.forEach(function(i, o) {
    return a.push(e(i, o));
  }, r, n), a;
};
kr.from = function(e) {
  return e instanceof kr ? e : e && e.length ? new ah(e) : kr.empty;
};
var ah = /* @__PURE__ */ function(t) {
  function e(n) {
    t.call(this), this.values = n;
  }
  t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
  var r = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(a, i) {
    return a == 0 && i == this.length ? this : new e(this.values.slice(a, i));
  }, e.prototype.getInner = function(a) {
    return this.values[a];
  }, e.prototype.forEachInner = function(a, i, o, u) {
    for (var m = i; m < o; m++)
      if (a(this.values[m], u + m) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(a, i, o, u) {
    for (var m = i - 1; m >= o; m--)
      if (a(this.values[m], u + m) === !1)
        return !1;
  }, e.prototype.leafAppend = function(a) {
    if (this.length + a.length <= ps)
      return new e(this.values.concat(a.flatten()));
  }, e.prototype.leafPrepend = function(a) {
    if (this.length + a.length <= ps)
      return new e(a.flatten().concat(this.values));
  }, r.length.get = function() {
    return this.values.length;
  }, r.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, r), e;
}(kr);
kr.empty = new ah([]);
var wJ = /* @__PURE__ */ function(t) {
  function e(r, n) {
    t.call(this), this.left = r, this.right = n, this.length = r.length + n.length, this.depth = Math.max(r.depth, n.depth) + 1;
  }
  return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(n) {
    return n < this.left.length ? this.left.get(n) : this.right.get(n - this.left.length);
  }, e.prototype.forEachInner = function(n, a, i, o) {
    var u = this.left.length;
    if (a < u && this.left.forEachInner(n, a, Math.min(i, u), o) === !1 || i > u && this.right.forEachInner(n, Math.max(a - u, 0), Math.min(this.length, i) - u, o + u) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(n, a, i, o) {
    var u = this.left.length;
    if (a > u && this.right.forEachInvertedInner(n, a - u, Math.max(i, u) - u, o + u) === !1 || i < u && this.left.forEachInvertedInner(n, Math.min(a, u), i, o) === !1)
      return !1;
  }, e.prototype.sliceInner = function(n, a) {
    if (n == 0 && a == this.length)
      return this;
    var i = this.left.length;
    return a <= i ? this.left.slice(n, a) : n >= i ? this.right.slice(n - i, a - i) : this.left.slice(n, i).append(this.right.slice(0, a - i));
  }, e.prototype.leafAppend = function(n) {
    var a = this.right.leafAppend(n);
    if (a)
      return new e(this.left, a);
  }, e.prototype.leafPrepend = function(n) {
    var a = this.left.leafPrepend(n);
    if (a)
      return new e(a, this.right);
  }, e.prototype.appendInner = function(n) {
    return this.left.depth >= Math.max(this.right.depth, n.depth) + 1 ? new e(this.left, new e(this.right, n)) : new e(this, n);
  }, e;
}(kr);
const CJ = 500;
class mn {
  constructor(e, r) {
    this.items = e, this.eventCount = r;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, r) {
    if (this.eventCount == 0)
      return null;
    let n = this.items.length;
    for (; ; n--)
      if (this.items.get(n - 1).selection) {
        --n;
        break;
      }
    let a, i;
    r && (a = this.remapping(n, this.items.length), i = a.maps.length);
    let o = e.tr, u, m, y = [], C = [];
    return this.items.forEach((T, x) => {
      if (!T.step) {
        a || (a = this.remapping(n, x + 1), i = a.maps.length), i--, C.push(T);
        return;
      }
      if (a) {
        C.push(new Mn(T.map));
        let M = T.step.map(a.slice(i)), P;
        M && o.maybeStep(M).doc && (P = o.mapping.maps[o.mapping.maps.length - 1], y.push(new Mn(P, void 0, void 0, y.length + C.length))), i--, P && a.appendMap(P, i);
      } else
        o.maybeStep(T.step);
      if (T.selection)
        return u = a ? T.selection.map(a.slice(i)) : T.selection, m = new mn(this.items.slice(0, n).append(C.reverse().concat(y)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: m, transform: o, selection: u };
  }
  // Create a new branch with the given transform added.
  addTransform(e, r, n, a) {
    let i = [], o = this.eventCount, u = this.items, m = !a && u.length ? u.get(u.length - 1) : null;
    for (let C = 0; C < e.steps.length; C++) {
      let T = e.steps[C].invert(e.docs[C]), x = new Mn(e.mapping.maps[C], T, r), M;
      (M = m && m.merge(x)) && (x = M, C ? i.pop() : u = u.slice(0, u.length - 1)), i.push(x), r && (o++, r = void 0), a || (m = x);
    }
    let y = o - n.depth;
    return y > SJ && (u = TJ(u, y), o -= y), new mn(u.append(i), o);
  }
  remapping(e, r) {
    let n = new zt.Mapping();
    return this.items.forEach((a, i) => {
      let o = a.mirrorOffset != null && i - a.mirrorOffset >= e ? n.maps.length - a.mirrorOffset : void 0;
      n.appendMap(a.map, o);
    }, e, r), n;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new mn(this.items.append(e.map((r) => new Mn(r))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, r) {
    if (!this.eventCount)
      return this;
    let n = [], a = Math.max(0, this.items.length - r), i = e.mapping, o = e.steps.length, u = this.eventCount;
    this.items.forEach((x) => {
      x.selection && u--;
    }, a);
    let m = r;
    this.items.forEach((x) => {
      let M = i.getMirror(--m);
      if (M == null)
        return;
      o = Math.min(o, M);
      let P = i.maps[M];
      if (x.step) {
        let q = e.steps[M].invert(e.docs[M]), _ = x.selection && x.selection.map(i.slice(m + 1, M));
        _ && u++, n.push(new Mn(P, q, _));
      } else
        n.push(new Mn(P));
    }, a);
    let y = [];
    for (let x = r; x < o; x++)
      y.push(new Mn(i.maps[x]));
    let C = this.items.slice(0, a).append(y).append(n), T = new mn(C, u);
    return T.emptyItemCount() > CJ && (T = T.compress(this.items.length - n.length)), T;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((r) => {
      r.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let r = this.remapping(0, e), n = r.maps.length, a = [], i = 0;
    return this.items.forEach((o, u) => {
      if (u >= e)
        a.push(o), o.selection && i++;
      else if (o.step) {
        let m = o.step.map(r.slice(n)), y = m && m.getMap();
        if (n--, y && r.appendMap(y, n), m) {
          let C = o.selection && o.selection.map(r.slice(n));
          C && i++;
          let T = new Mn(y.invert(), m, C), x, M = a.length - 1;
          (x = a.length && a[M].merge(T)) ? a[M] = x : a.push(T);
        }
      } else
        o.map && n--;
    }, this.items.length, 0), new mn(kr.from(a.reverse()), i);
  }
}
mn.empty = new mn(kr.empty, 0);
function TJ(t, e) {
  let r;
  return t.forEach((n, a) => {
    if (n.selection && e-- == 0)
      return r = a, !1;
  }), t.slice(r);
}
class Mn {
  constructor(e, r, n, a) {
    this.map = e, this.step = r, this.selection = n, this.mirrorOffset = a;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let r = e.step.merge(this.step);
      if (r)
        return new Mn(r.getMap().invert(), r, this.selection);
    }
  }
}
class ka {
  constructor(e, r, n, a, i) {
    this.done = e, this.undone = r, this.prevRanges = n, this.prevTime = a, this.prevComposition = i;
  }
}
const SJ = 20;
function EJ(t, e, r, n) {
  let a = r.getMeta(ra), i;
  if (a)
    return a.historyState;
  r.getMeta(AJ) && (t = new ka(t.done, t.undone, null, 0, -1));
  let o = r.getMeta("appendedTransaction");
  if (r.steps.length == 0)
    return t;
  if (o && o.getMeta(ra))
    return o.getMeta(ra).redo ? new ka(t.done.addTransform(r, void 0, n, as(e)), t.undone, Lv(r.mapping.maps[r.steps.length - 1]), t.prevTime, t.prevComposition) : new ka(t.done, t.undone.addTransform(r, void 0, n, as(e)), null, t.prevTime, t.prevComposition);
  if (r.getMeta("addToHistory") !== !1 && !(o && o.getMeta("addToHistory") === !1)) {
    let u = r.getMeta("composition"), m = t.prevTime == 0 || !o && t.prevComposition != u && (t.prevTime < (r.time || 0) - n.newGroupDelay || !xJ(r, t.prevRanges)), y = o ? hu(t.prevRanges, r.mapping) : Lv(r.mapping.maps[r.steps.length - 1]);
    return new ka(t.done.addTransform(r, m ? e.selection.getBookmark() : void 0, n, as(e)), mn.empty, y, r.time, u ?? t.prevComposition);
  } else
    return (i = r.getMeta("rebased")) ? new ka(t.done.rebased(r, i), t.undone.rebased(r, i), hu(t.prevRanges, r.mapping), t.prevTime, t.prevComposition) : new ka(t.done.addMaps(r.mapping.maps), t.undone.addMaps(r.mapping.maps), hu(t.prevRanges, r.mapping), t.prevTime, t.prevComposition);
}
function xJ(t, e) {
  if (!e)
    return !1;
  if (!t.docChanged)
    return !0;
  let r = !1;
  return t.mapping.maps[0].forEach((n, a) => {
    for (let i = 0; i < e.length; i += 2)
      n <= e[i + 1] && a >= e[i] && (r = !0);
  }), r;
}
function Lv(t) {
  let e = [];
  return t.forEach((r, n, a, i) => e.push(a, i)), e;
}
function hu(t, e) {
  if (!t)
    return null;
  let r = [];
  for (let n = 0; n < t.length; n += 2) {
    let a = e.map(t[n], 1), i = e.map(t[n + 1], -1);
    a <= i && r.push(a, i);
  }
  return r;
}
function ih(t, e, r, n) {
  let a = as(e), i = ra.get(e).spec.config, o = (n ? t.undone : t.done).popEvent(e, a);
  if (!o)
    return;
  let u = o.selection.resolve(o.transform.doc), m = (n ? t.done : t.undone).addTransform(o.transform, e.selection.getBookmark(), i, a), y = new ka(n ? m : o.remaining, n ? o.remaining : m, null, 0, -1);
  r(o.transform.setSelection(u).setMeta(ra, { redo: n, historyState: y }).scrollIntoView());
}
let mu = !1, Ov = null;
function as(t) {
  let e = t.plugins;
  if (Ov != e) {
    mu = !1, Ov = e;
    for (let r = 0; r < e.length; r++)
      if (e[r].spec.historyPreserveItems) {
        mu = !0;
        break;
      }
  }
  return mu;
}
const ra = new nt.PluginKey("history"), AJ = new nt.PluginKey("closeHistory");
function oh(t = {}) {
  return t = {
    depth: t.depth || 100,
    newGroupDelay: t.newGroupDelay || 500
  }, new nt.Plugin({
    key: ra,
    state: {
      init() {
        return new ka(mn.empty, mn.empty, null, 0, -1);
      },
      apply(e, r, n) {
        return EJ(r, n, e, t);
      }
    },
    config: t,
    props: {
      handleDOMEvents: {
        beforeinput(e, r) {
          let n = r.inputType, a = n == "historyUndo" ? eo : n == "historyRedo" ? yc : null;
          return a ? (r.preventDefault(), a(e.state, e.dispatch)) : !1;
        }
      }
    }
  });
}
const eo = (t, e) => {
  let r = ra.getState(t);
  return !r || r.done.eventCount == 0 ? !1 : (e && ih(r, t, e, !1), !0);
}, yc = (t, e) => {
  let r = ra.getState(t);
  return !r || r.undone.eventCount == 0 ? !1 : (e && ih(r, t, e, !0), !0);
};
function MJ(t) {
  let e = ra.getState(t);
  return e ? e.done.eventCount : 0;
}
/**
 * @toast-ui/editor
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var zu = function(t, e) {
  return zu = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, n) {
    r.__proto__ = n;
  } || function(r, n) {
    for (var a in n)
      Object.prototype.hasOwnProperty.call(n, a) && (r[a] = n[a]);
  }, zu(t, e);
};
function Ve(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  zu(t, e);
  function r() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r());
}
var ge = function() {
  return ge = Object.assign || function(e) {
    for (var r, n = 1, a = arguments.length; n < a; n++) {
      r = arguments[n];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, ge.apply(this, arguments);
};
function Wr(t, e, r) {
  if (r || arguments.length === 2)
    for (var n = 0, a = e.length, i; n < a; n++)
      (i || !(n in e)) && (i || (i = Array.prototype.slice.call(e, 0, n)), i[n] = e[n]);
  return t.concat(i || Array.prototype.slice.call(e));
}
function Et(t, e) {
  return Object.defineProperty ? Object.defineProperty(t, "raw", { value: e }) : t.raw = e, t;
}
function LJ(t, e, r) {
  var n;
  r = r || null;
  for (n in t)
    if (t.hasOwnProperty(n) && e.call(r, t[n], n, t) === !1)
      break;
}
var Ci = LJ;
function OJ(t, e) {
  var r = Object.prototype.hasOwnProperty, n, a, i, o;
  for (i = 1, o = arguments.length; i < o; i += 1) {
    n = arguments[i];
    for (a in n)
      r.call(n, a) && (t[a] = n[a]);
  }
  return t;
}
var bc = OJ;
function DJ(t) {
  return typeof t == "string" || t instanceof String;
}
var sa = DJ;
function NJ(t) {
  return t instanceof Array;
}
var Ni = NJ;
function RJ(t, e, r) {
  var n = 0, a = t.length;
  for (r = r || null; n < a && e.call(r, t[n], n, t) !== !1; n += 1)
    ;
}
var Ti = RJ, IJ = Ni, PJ = Ti, BJ = Ci;
function qJ(t, e, r) {
  IJ(t) ? PJ(t, e, r) : BJ(t, e, r);
}
var Ps = qJ, FJ = sa, _J = Ps;
function HJ(t, e, r) {
  var n = t.style;
  if (FJ(e)) {
    n[e] = r;
    return;
  }
  _J(e, function(a, i) {
    n[i] = a;
  });
}
var Dn = HJ, UJ = Ni;
function zJ(t, e, r) {
  var n, a;
  if (r = r || 0, !UJ(e))
    return -1;
  if (Array.prototype.indexOf)
    return Array.prototype.indexOf.call(e, t, r);
  for (a = e.length, n = r; r >= 0 && n < a; n += 1)
    if (e[n] === t)
      return n;
  return -1;
}
var Ya = zJ;
function $J(t) {
  return t === void 0;
}
var kn = $J, VJ = kn;
function WJ(t) {
  return !t || !t.className ? "" : VJ(t.className.baseVal) ? t.className : t.className.baseVal;
}
var kc = WJ, jJ = Ni, GJ = kn;
function KJ(t, e) {
  if (e = jJ(e) ? e.join(" ") : e, e = e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), GJ(t.className.baseVal)) {
    t.className = e;
    return;
  }
  t.className.baseVal = e;
}
var sh = KJ, Dv = Ps, JJ = Ya, YJ = kc, ZJ = sh;
function QJ(t) {
  var e = Array.prototype.slice.call(arguments, 1), r = t.classList, n = [], a;
  if (r) {
    Dv(e, function(i) {
      t.classList.add(i);
    });
    return;
  }
  a = YJ(t), a && (e = [].concat(a.split(/\s+/), e)), Dv(e, function(i) {
    JJ(i, n) < 0 && n.push(i);
  }), ZJ(t, n);
}
var Ln = QJ, Nv = Ti, XJ = Ya, eY = kc, tY = sh;
function rY(t) {
  var e = Array.prototype.slice.call(arguments, 1), r = t.classList, n, a;
  if (r) {
    Nv(e, function(i) {
      r.remove(i);
    });
    return;
  }
  n = eY(t).split(/\s+/), a = [], Nv(n, function(i) {
    XJ(i, e) < 0 && a.push(i);
  }), tY(t, a);
}
var gn = rY;
function nY(t) {
  return typeof t == "number" || t instanceof Number;
}
var ea = nY;
function aY(t) {
  return t === null;
}
var hs = aY, iY = Ci;
function oY(t, e) {
  var r = document.createElement("img"), n = "";
  return iY(e, function(a, i) {
    n += "&" + i + "=" + a;
  }), n = n.substring(1), r.src = t + "?" + n, r.style.display = "none", document.body.appendChild(r), document.body.removeChild(r), r;
}
var sY = oY, lY = kn, uY = sY, cY = 7 * 24 * 60 * 60 * 1e3;
function fY(t) {
  var e = (/* @__PURE__ */ new Date()).getTime();
  return e - t > cY;
}
function vY(t, e) {
  var r = "https://www.google-analytics.com/collect", n = location.hostname, a = "event", i = "use", o = "TOAST UI " + t + " for " + n + ": Statistics", u = window.localStorage.getItem(o);
  !lY(window.tui) && window.tui.usageStatistics === !1 || u && !fY(u) || (window.localStorage.setItem(o, (/* @__PURE__ */ new Date()).getTime()), setTimeout(function() {
    (document.readyState === "interactive" || document.readyState === "complete") && uY(r, {
      v: 1,
      t: a,
      tid: e,
      cid: n,
      dp: n,
      dh: t,
      el: t,
      ec: i
    });
  }, 1e3));
}
var dY = vY, pY = /[\u0020]+/g, hY = /[>(){}[\]+-.!#|]/g, Rv = /<([a-zA-Z_][a-zA-Z0-9\-._]*)(\s|[^\\>])*\/?>|<(\/)([a-zA-Z_][a-zA-Z0-9\-._]*)\s*\/?>|<!--[^-]+-->|<([a-zA-Z_][a-zA-Z0-9\-.:/]*)>/g, Iv = /\\[!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~\\]/g, mY = /[*_~`]/g, Pv = /!\[.*\]\(.*\)/g, gY = /[[\]]/g, Bv = /(?:^|[^\\])\\(?!\\)/g, yY = '[&<>"]', qv = new RegExp(yY, "g");
function bY(t) {
  switch (t) {
    case "&":
      return "&amp;";
    case "<":
      return "&lt;";
    case ">":
      return "&gt;";
    case '"':
      return "&quot;";
    default:
      return t;
  }
}
function bi(t) {
  return qv.test(t) ? t.replace(qv, bY) : t;
}
function kY() {
  dY("editor", "UA-129966929-1");
}
function Ar(t, e) {
  return t.indexOf(e) !== -1;
}
var wY = ["rel", "target", "hreflang", "type"], CY = {
  codeblock: /(^ {4}[^\n]+\n*)+/,
  thematicBreak: /^ *((\* *){3,}|(- *){3,} *|(_ *){3,}) */,
  atxHeading: /^(#{1,6}) +[\s\S]+/,
  seTextheading: /^([^\n]+)\n *(=|-){2,} */,
  blockquote: /^( *>[^\n]+.*)+/,
  list: /^ *(\*+|-+|\d+\.) [\s\S]+/,
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? */,
  link: /!?\[.*\]\(.*\)/,
  reflink: /!?\[.*\]\s*\[([^\]]*)\]/,
  verticalBar: /\u007C/,
  fencedCodeblock: /^((`|~){3,})/
};
function lh(t) {
  if (!t)
    return null;
  var e = {};
  return wY.forEach(function(r) {
    kn(t[r]) || (e[r] = t[r]);
  }), e;
}
function ms(t, e) {
  for (var r = "", n = 0; n < e; n += 1)
    r += t;
  return r;
}
function TY(t) {
  var e = !1;
  return Ci(CY, function(r) {
    return r.test(t) && (e = !0), !e;
  }), e;
}
function gs(t) {
  for (var e = [], r = Pv.exec(t); r; )
    e.push([r.index, r.index + r[0].length]), r = Pv.exec(t);
  return t.replace(gY, function(n, a) {
    var i = e.some(function(o) {
      return a > o[0] && a < o[1];
    });
    return i ? n : "\\" + n;
  });
}
function SY(t) {
  var e = function(a) {
    return "\\" + a;
  }, r = function(a) {
    return a + "\\";
  }, n = t.replace(pY, " ");
  return Iv.test(n) && (n = n.replace(Iv, e)), Bv.test(n) && (n = n.replace(Bv, r)), n = n.replace(mY, e), Rv.test(n) && (n = n.replace(Rv, e)), TY(n) && (n = n.replace(hY, e)), n;
}
function EY(t) {
  var e;
  return t.indexOf('"') === -1 ? e = '""' : e = t.indexOf("'") === -1 ? "''" : "()", e[0] + t + e[1];
}
function $u(t) {
  return hs(t) || kn(t);
}
function wc(t, e) {
  if (t === null && t === e)
    return !0;
  if (typeof t != "object" || typeof e != "object" || $u(t) || $u(e))
    return t === e;
  for (var r in t)
    if (t[r] !== e[r])
      return !1;
  for (var r in e)
    if (!(r in t))
      return !1;
  return !0;
}
function Dr(t) {
  return t[t.length - 1];
}
function xY(t, e, r) {
  return t >= e && t <= r;
}
function Cc(t) {
  return typeof t == "object" && t !== null;
}
function ys(t, e) {
  var r = ge({}, t);
  return t && e && Object.keys(e).forEach(function(n) {
    Cc(r[n]) ? Array.isArray(e[n]) ? r[n] = Tc(e[n]) : r.hasOwnProperty(n) ? r[n] = ys(r[n], e[n]) : r[n] = Sc(e[n]) : r[n] = e[n];
  }), r;
}
function Tc(t) {
  return t.map(function(e) {
    return Cc(e) ? Array.isArray(e) ? Tc(e) : Sc(e) : e;
  });
}
function Sc(t) {
  var e = Object.keys(t);
  return e.length ? e.reduce(function(r, n) {
    return Cc(t[n]) ? r[n] = Array.isArray(t[n]) ? Tc(t[n]) : Sc(t[n]) : r[n] = t[n], r;
  }, {}) : t;
}
function Ec(t, e) {
  return e === void 0 && (e = {}), Object.keys(e).forEach(function(r) {
    t.hasOwnProperty(r) && typeof t[r] == "object" ? Array.isArray(e[r]) ? t[r] = e[r] : Ec(t[r], e[r]) : t[r] = e[r];
  }), t;
}
function Fv(t, e) {
  return t > e ? [e, t] : [t, e];
}
var AY = Ti;
function MY(t) {
  var e;
  try {
    e = Array.prototype.slice.call(t);
  } catch {
    e = [], AY(t, function(n) {
      e.push(n);
    });
  }
  return e;
}
var Nn = MY;
function bs(t, e) {
  var r = t.nodes.paragraph;
  return e ? r.create(null, sa(e) ? t.text(e) : e) : r.createAndFill();
}
function xr(t, e, r) {
  return t.text(e, r);
}
function Wt(t, e, r) {
  r === void 0 && (r = e);
  var n = t.doc.content.size, a = n > 0 ? n - 1 : 1;
  return nt.TextSelection.create(t.doc, Math.min(e, a), Math.min(r, a));
}
function xc(t, e, r) {
  var n = e.pos;
  return t.replaceWith(n, n, bs(r)), t.setSelection(Wt(t, n + 1));
}
function ks(t) {
  for (var e = t.state, r = t.from, n = t.startIndex, a = t.endIndex, i = t.createText, o = e.tr, u = e.doc, m = e.schema, y = n; y <= a; y += 1) {
    var C = u.child(y), T = C.nodeSize, x = C.textContent, M = C.content, P = i(x), q = P ? xr(m, P) : Qe.Fragment.empty, _ = o.mapping.map(r), K = _ + M.size;
    o.replaceWith(_, K, q), r += T;
  }
  return o;
}
function Ac(t, e, r, n) {
  var a = r.length;
  t.split(e).delete(e - a, e).insert(t.mapping.map(e), n).setSelection(Wt(t, t.mapping.map(e) - a));
}
function lo(t) {
  return t.sourcepos[0][0];
}
function Bs(t) {
  return t.sourcepos[1][0];
}
function qs(t) {
  return t.sourcepos[0][1];
}
function Ca(t) {
  return t.sourcepos[1][1];
}
function LY(t) {
  var e = t.type;
  return e === "htmlBlock" || e === "htmlInline";
}
function OY(t) {
  var e = t.type;
  return e === "strike" || e === "strong" || e === "emph" || e === "code" || e === "link" || e === "image";
}
function DY(t) {
  return t && t.type === "codeBlock";
}
function Za(t) {
  return t && (t.type === "item" || t.type === "list");
}
function uh(t) {
  return Za(t) && t.listData.type === "ordered";
}
function NY(t) {
  return Za(t) && t.listData.type !== "ordered";
}
function _v(t) {
  return t && (t.type === "tableCell" || t.type === "tableDelimCell");
}
function RY(t) {
  switch (t.type) {
    case "code":
    case "text":
    case "emph":
    case "strong":
    case "strike":
    case "link":
    case "image":
    case "htmlInline":
    case "linebreak":
    case "softbreak":
    case "customInline":
      return !0;
    default:
      return !1;
  }
}
function Si(t, e, r) {
  for (r === void 0 && (r = !0), t = r ? t : t.parent; t && t.type !== "document"; ) {
    if (e(t))
      return t;
    t = t.parent;
  }
  return null;
}
function IY(t, e, r) {
  for (r === void 0 && (r = !0), t = r ? t : t.parent; t && t.type !== "document"; )
    e(t), t = t.parent;
}
function br(t, e) {
  return [t[0], t[1] + e];
}
function Ta(t, e) {
  return [t[0], e];
}
function PY(t) {
  var e = t.firstChild.literal;
  switch (t.type) {
    case "emph":
      return "*" + e + "*";
    case "strong":
      return "**" + e + "**";
    case "strike":
      return "~~" + e + "~~";
    case "code":
      return "`" + e + "`";
    case "link":
    case "image":
      var r = t, n = r.destination, a = r.title, i = t.type === "link" ? "" : "!";
      return i + "[" + e + "](" + n + (a ? ' "' + a + '"' : "") + ")";
    default:
      return null;
  }
}
function BY(t) {
  switch (t.type) {
    case "document":
    case "blockQuote":
    case "list":
    case "item":
    case "paragraph":
    case "heading":
    case "emph":
    case "strong":
    case "strike":
    case "link":
    case "image":
    case "table":
    case "tableHead":
    case "tableBody":
    case "tableRow":
    case "tableCell":
    case "tableDelimRow":
    case "customInline":
      return !0;
    default:
      return !1;
  }
}
function qY(t) {
  for (var e = [], r = t.walker(), n = null; n = r.next(); ) {
    var a = n.node;
    a.type === "text" && e.push(a.literal);
  }
  return e.join("");
}
var no = [], ch = {}, Hv = /\$\$widget\d+\s/;
function Fs(t) {
  var e = t.search(Hv);
  if (e !== -1) {
    var r = t.substring(e), n = r.replace(Hv, "").replace("$$", "");
    t = t.substring(0, e), t += Fs(n);
  }
  return t;
}
function fh(t, e) {
  return "$$" + t + " " + e + "$$";
}
function vh(t, e) {
  var r = ch[t], n = r.rule, a = r.toDOM, i = Fs(e).match(n);
  return i && (e = i[0]), a(e);
}
function FY() {
  return no;
}
function _Y(t) {
  no = t, no.forEach(function(e, r) {
    ch["widget" + r] = e;
  });
}
function gu(t, e, r, n) {
  return t.concat(Ja(e, r, n));
}
function Ja(t, e, r) {
  r === void 0 && (r = 0);
  var n = [], a = (no[r] || {}).rule, i = r + 1;
  if (t = Fs(t), a && a.test(t)) {
    for (var o = void 0; (o = t.search(a)) !== -1; ) {
      var u = t.substring(0, o);
      u && (n = gu(n, u, e, i)), t = t.substring(o);
      var m = t.match(a)[0], y = "widget" + r;
      n.push(e.nodes.widget.create({ info: y }, e.text(fh(y, m)))), t = t.substring(m.length);
    }
    t && (n = gu(n, t, e, i));
  } else
    t && (n = r < no.length - 1 ? gu(n, t, e, i) : [e.text(t)]);
  return n;
}
function dh(t) {
  for (var e, r = "", n = t.walker(); e = n.next(); ) {
    var a = e.node, i = e.entering;
    i && (a !== t && a.type !== "text" ? (r += PY(a), n.resumeAt(t, !1), n.next()) : a.type === "text" && (r += a.literal));
  }
  return r;
}
function ph() {
  return {
    deleteSelection: function() {
      return pc;
    },
    selectAll: function() {
      return Xp;
    },
    undo: function() {
      return eo;
    },
    redo: function() {
      return yc;
    }
  };
}
function HY(t) {
  return new nt.Plugin({
    props: {
      decorations: function(e) {
        var r = e.doc;
        if (t.text && r.childCount === 1 && r.firstChild.isTextblock && r.firstChild.content.size === 0) {
          var n = document.createElement("span");
          return Ln(n, "placeholder"), t.className && Ln(n, t.className), n.textContent = t.text, ia.DecorationSet.create(r, [ia.Decoration.widget(1, n)]);
        }
        return null;
      }
    }
  });
}
var UY = Ya, zY = kc;
function $Y(t, e) {
  var r;
  return t.classList ? t.classList.contains(e) : (r = zY(t).split(/\s+/), UY(e, r) > -1);
}
var hh = $Y, VY = Ya, WY = Nn, jo = Element.prototype, jY = jo.matches || jo.webkitMatchesSelector || jo.mozMatchesSelector || jo.msMatchesSelector || function(t) {
  var e = this.document || this.ownerDocument;
  return VY(this, WY(e.querySelectorAll(t))) > -1;
};
function GY(t, e) {
  return jY.call(t, e);
}
var KY = GY, mh = "[A-Za-z][A-Za-z0-9-]*", JY = "[a-zA-Z_:][a-zA-Z0-9:._-]*", YY = "[^\"'=<>`\\x00-\\x20]+", ZY = "'[^']*'", QY = '"[^"]*"', XY = "(?:" + YY + "|" + ZY + "|" + QY + ")", e7 = "(?:\\s*=\\s*" + XY + ")", gh = "(?:\\s+" + JY + e7 + "?)", yh = "<(" + mh + ")(" + gh + ")*\\s*/?>", t7 = "</(" + mh + ")\\s*[>]", bh = "(?:" + yh + "|" + t7 + ")", Ei = new RegExp("^" + bh, "i"), Vu = /<br\s*\/*>/i, r7 = /<! ---->|<!--(?:-?[^>-])(?:-?[^-])*-->/, kh = "</p><p>";
function Mc(t, e, r) {
  var n = parseInt(t.left, 10), a = parseInt(t.top, 10), i = parseInt(t.width, 10) + parseInt(t.paddingLeft, 10) + parseInt(t.paddingRight, 10), o = parseInt(t.height, 10) + parseInt(t.paddingTop, 10) + parseInt(t.paddingBottom, 10);
  return e >= n && e <= n + i && r >= a && r <= a + o;
}
var wh = "toastui-editor-";
function Ke() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  for (var r = [], n = 0, a = t; n < a.length; n++) {
    var i = a[n], o = void 0;
    Array.isArray(i) ? o = i[0] ? i[1] : null : o = i, o && r.push("" + wh + o);
  }
  return r.join(" ");
}
function dr() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  return t.map(function(r) {
    return wh + "md-" + r;
  }).join(" ");
}
function n7(t) {
  return (t == null ? void 0 : t.nodeType) === Node.TEXT_NODE;
}
function _s(t) {
  return t && t.nodeType === Node.ELEMENT_NODE;
}
function a7(t, e) {
  var r = Nn(t.querySelectorAll(e));
  return r.length ? r : [];
}
function i7(t, e) {
  e = Ni(e) ? Nn(e) : [e], e.forEach(function(r) {
    t.appendChild(r);
  });
}
function o7(t, e) {
  e.parentNode && e.parentNode.insertBefore(t, e);
}
function Qa(t) {
  t.parentNode && t.parentNode.removeChild(t);
}
function s7(t) {
  for (var e = []; t.firstChild; )
    e.push(t.firstChild), t.parentNode && t.parentNode.insertBefore(t.firstChild, t);
  return Qa(t), e;
}
function Lc(t, e, r) {
  kn(r) && (r = !hh(t, e));
  var n = r ? Ln : gn;
  n(t, e);
}
function Ch(t, e) {
  var r = document.createElement("div");
  sa(t) ? r.innerHTML = t : r.appendChild(t);
  var n = r.firstChild;
  return e && e.appendChild(n), n;
}
function Oc(t) {
  var e = window.getComputedStyle(t);
  return ["margin-left", "margin-right"].reduce(function(r, n) {
    return r + parseInt(e.getPropertyValue(n), 10);
  }, 0) + t.offsetWidth;
}
function On(t, e) {
  var r;
  for (sa(e) ? r = function(n) {
    return KY(n, e);
  } : r = function(n) {
    return n === e;
  }; t && t !== document; ) {
    if (_s(t) && r(t))
      return t;
    t = t.parentNode;
  }
  return null;
}
function Th(t, e) {
  for (var r = 0, n = 0; t && t !== e; ) {
    var a = t.offsetTop, i = t.offsetLeft, o = t.offsetParent;
    if (r += a, n += i, o === e.offsetParent)
      break;
    t = t.offsetParent;
  }
  return { offsetTop: r, offsetLeft: n };
}
function Dc(t, e) {
  Object.keys(t).forEach(function(r) {
    $u(t[r]) ? e.removeAttribute(r) : e.setAttribute(r, t[r]);
  });
}
function l7(t) {
  var e = t.replace(/<p><br\s*\/*><\/p>/gi, "<p></p>"), r = new RegExp(bh, "ig"), n = e.match(r);
  return n == null || n.forEach(function(a, i) {
    if (Vu.test(a)) {
      var o = kh;
      if (i) {
        var u = n[i - 1], m = u.match(yh);
        if (m && !/br/i.test(m[1])) {
          var y = m[1];
          o = "</" + y + "><" + y + ">";
        }
      }
      e = e.replace(Vu, o);
    }
  }), e;
}
function Nc(t) {
  var e = /<img class="ProseMirror-separator" alt="">/g, r = / class="ProseMirror-trailingBreak"/g, n = t;
  return n = n.replace(e, ""), n = n.replace(r, ""), n;
}
var Sh = new nt.PluginKey("widget"), Uv = 5, u7 = (
  /** @class */
  function() {
    function t(e, r) {
      var n = this;
      this.popup = null, this.removeWidget = function() {
        n.popup && (n.rootEl.removeChild(n.popup), n.popup = null);
      }, this.rootEl = e.dom.parentElement, this.eventEmitter = r, this.eventEmitter.listen("blur", this.removeWidget), this.eventEmitter.listen("loadUI", function() {
        n.rootEl = On(e.dom.parentElement, "." + Ke("defaultUI"));
      }), this.eventEmitter.listen("removePopupWidget", this.removeWidget);
    }
    return t.prototype.update = function(e) {
      var r = Sh.getState(e.state);
      if (this.removeWidget(), r) {
        var n = r.node, a = r.style, i = e.coordsAtPos(r.pos), o = i.top, u = i.left, m = i.bottom, y = m - o, C = this.rootEl.getBoundingClientRect(), T = o - C.top;
        Dn(n, { opacity: "0" }), this.rootEl.appendChild(n), Dn(n, {
          position: "absolute",
          left: u - C.left + Uv + "px",
          top: (a === "bottom" ? T + y - Uv : T - y) + "px",
          opacity: "1"
        }), this.popup = n, e.focus();
      }
    }, t.prototype.destroy = function() {
      this.eventEmitter.removeEventHandler("blur", this.removeWidget);
    }, t;
  }()
);
function c7(t) {
  return new nt.Plugin({
    key: Sh,
    state: {
      init: function() {
        return null;
      },
      apply: function(e) {
        return e.getMeta("widget");
      }
    },
    view: function(e) {
      return new u7(e, t);
    }
  });
}
function f7(t) {
  t.listen("addImageBlobHook", function(e, r) {
    var n = new FileReader();
    n.onload = function(a) {
      var i = a.target;
      return r(i.result);
    }, n.readAsDataURL(e);
  });
}
function Rc(t, e, r) {
  var n = function(a, i) {
    t.emit("command", "addImage", {
      imageUrl: a,
      altText: i || e.name || "image"
    });
  };
  t.emit("addImageBlobHook", e, n, r);
}
function Eh(t) {
  var e = Nn(t).filter(function(n) {
    var a = n.type;
    return a.indexOf("image") !== -1;
  });
  if (e.length === 1) {
    var r = e[0];
    if (r)
      return r.getAsFile();
  }
  return null;
}
function v7(t) {
  var e = t.eventEmitter;
  return new nt.Plugin({
    props: {
      handleDOMEvents: {
        drop: function(r, n) {
          var a, i = (a = n.dataTransfer) === null || a === void 0 ? void 0 : a.files;
          return i && Ti(i, function(o) {
            return o.type.indexOf("image") !== -1 ? (n.preventDefault(), n.stopPropagation(), Rc(e, o, n.type), !1) : !0;
          }), !0;
        }
      }
    }
  });
}
var $t = (
  /** @class */
  function() {
    function t() {
    }
    return Object.defineProperty(t.prototype, "type", {
      get: function() {
        return "node";
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.setContext = function(e) {
      this.context = e;
    }, t;
  }()
);
function xh(t) {
  var e = document.createElement("span"), r = vh(t.attrs.info, t.textContent);
  return e.className = "tui-widget", e.appendChild(r), { dom: e };
}
function Wu(t) {
  return t.type.name === "widget";
}
var Ah = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "widget";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            info: { default: null }
          },
          group: "inline",
          inline: !0,
          content: "text*",
          selectable: !1,
          atom: !0,
          toDOM: function() {
            return ["span", { class: "tui-widget" }, 0];
          },
          parseDOM: [
            {
              tag: "span.tui-widget",
              getAttrs: function(r) {
                var n = r.textContent, a = n.match(/\$\$(widget\d+)/), i = a[1];
                return { info: i };
              }
            }
          ]
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }($t)
), Mh = (
  /** @class */
  function() {
    function t(e) {
      this.timer = null, this.el = document.createElement("div"), this.el.className = "toastui-editor", this.eventEmitter = e, this.placeholder = { text: "" };
    }
    return t.prototype.createState = function() {
      return nt.EditorState.create({
        schema: this.schema,
        plugins: this.createPlugins()
      });
    }, t.prototype.initEvent = function() {
      var e = this, r = e.eventEmitter, n = e.view, a = e.editorType;
      n.dom.addEventListener("focus", function() {
        return r.emit("focus", a);
      }), n.dom.addEventListener("blur", function() {
        return r.emit("blur", a);
      });
    }, t.prototype.emitChangeEvent = function(e) {
      this.eventEmitter.emit("caretChange", this.editorType), e.docChanged && this.eventEmitter.emit("change", this.editorType);
    }, Object.defineProperty(t.prototype, "defaultPlugins", {
      get: function() {
        var e = this.createInputRules(), r = Wr(Wr([], this.keymaps), [
          ro.keymap(ge({ "Shift-Enter": Av.Enter }, Av)),
          oh(),
          HY(this.placeholder),
          c7(this.eventEmitter),
          v7(this.context)
        ]);
        return e ? r.concat(e) : r;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.createInputRules = function() {
      var e = FY(), r = e.map(function(n) {
        var a = n.rule;
        return new Xi.InputRule(a, function(i, o, u, m) {
          var y = i.schema, C = i.tr, T = i.doc, x = o.input.match(new RegExp(a, "g")), M = T.resolve(u), P = M.parent, q = 0;
          if (Wu(P) && (P = M.node(M.depth - 1)), P.forEach(function(X) {
            return Wu(X) && (q += 1);
          }), x.length > q) {
            var _ = Dr(x), K = Ja(_, y);
            return C.replaceWith(m - _.length + 1, m, K);
          }
          return null;
        });
      });
      return r.length ? Xi.inputRules({ rules: r }) : null;
    }, t.prototype.clearTimer = function() {
      this.timer && (clearTimeout(this.timer), this.timer = null);
    }, t.prototype.createSchema = function() {
      return new Qe.Schema({
        nodes: this.specs.nodes,
        marks: this.specs.marks
      });
    }, t.prototype.createKeymaps = function(e) {
      var r = ph(), n = r.undo, a = r.redo, i = this.specs.keymaps(e), o = {
        "Mod-z": n(),
        "Shift-Mod-z": a()
      };
      return e ? i.concat(ro.keymap(o)) : i;
    }, t.prototype.createCommands = function() {
      return this.specs.commands(this.view);
    }, t.prototype.createPluginProps = function() {
      var e = this;
      return this.extraPlugins.map(function(r) {
        return r(e.eventEmitter);
      });
    }, t.prototype.focus = function() {
      var e = this;
      this.clearTimer(), this.timer = setTimeout(function() {
        e.view.focus(), e.view.dispatch(e.view.state.tr.scrollIntoView());
      });
    }, t.prototype.blur = function() {
      this.view.dom.blur();
    }, t.prototype.destroy = function() {
      var e = this;
      this.clearTimer(), this.view.destroy(), Object.keys(this).forEach(function(r) {
        delete e[r];
      });
    }, t.prototype.moveCursorToStart = function(e) {
      var r = this.view.state.tr;
      this.view.dispatch(r.setSelection(Wt(r, 1)).scrollIntoView()), e && this.focus();
    }, t.prototype.moveCursorToEnd = function(e) {
      var r = this.view.state.tr;
      this.view.dispatch(r.setSelection(Wt(r, r.doc.content.size - 1)).scrollIntoView()), e && this.focus();
    }, t.prototype.setScrollTop = function(e) {
      this.view.dom.scrollTop = e;
    }, t.prototype.getScrollTop = function() {
      return this.view.dom.scrollTop;
    }, t.prototype.setPlaceholder = function(e) {
      this.placeholder.text = e, this.view.dispatch(this.view.state.tr.scrollIntoView());
    }, t.prototype.setHeight = function(e) {
      Dn(this.el, { height: e + "px" });
    }, t.prototype.setMinHeight = function(e) {
      Dn(this.el, { minHeight: e + "px" });
    }, t.prototype.getElement = function() {
      return this.el;
    }, t;
  }()
);
function d7(t) {
  return t instanceof Function;
}
var un = d7, p7 = [
  "Enter",
  "Shift-Enter",
  "Mod-Enter",
  "Tab",
  "Shift-Tab",
  "Delete",
  "Backspace",
  "Mod-Delete",
  "Mod-Backspace",
  "ArrowUp",
  "ArrowDown",
  "ArrowLeft",
  "ArrowRight",
  "Mod-d",
  "Mod-D",
  "Alt-ArrowUp",
  "Alt-ArrowDown"
];
function Go(t, e, r) {
  return t.focus(), e(r)(t.state, t.dispatch, t);
}
var Lh = (
  /** @class */
  function() {
    function t(e) {
      this.specs = e;
    }
    return Object.defineProperty(t.prototype, "nodes", {
      get: function() {
        return this.specs.filter(function(e) {
          return e.type === "node";
        }).reduce(function(e, r) {
          var n, a = r.name, i = r.schema;
          return ge(ge({}, e), (n = {}, n[a] = i, n));
        }, {});
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "marks", {
      get: function() {
        return this.specs.filter(function(e) {
          return e.type === "mark";
        }).reduce(function(e, r) {
          var n, a = r.name, i = r.schema;
          return ge(ge({}, e), (n = {}, n[a] = i, n));
        }, {});
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.commands = function(e, r) {
      var n = this.specs.filter(function(i) {
        var o = i.commands;
        return o;
      }).reduce(function(i, o) {
        var u = {}, m = o.commands();
        return un(m) ? u[o.name] = function(y) {
          return Go(e, m, y);
        } : Object.keys(m).forEach(function(y) {
          u[y] = function(C) {
            return Go(e, m[y], C);
          };
        }), ge(ge({}, i), u);
      }, {}), a = ph();
      return Object.keys(a).forEach(function(i) {
        n[i] = function(o) {
          return Go(e, a[i], o);
        };
      }), r && Object.keys(r).forEach(function(i) {
        n[i] = function(o) {
          return Go(e, r[i], o);
        };
      }), n;
    }, t.prototype.keymaps = function(e) {
      var r = this.specs.filter(function(n) {
        return n.keymaps;
      }).map(function(n) {
        return n.keymaps();
      });
      return r.map(function(n) {
        return e || Object.keys(n).forEach(function(a) {
          Ar(p7, a) || delete n[a];
        }), ro.keymap(n);
      });
    }, t.prototype.setContext = function(e) {
      this.specs.forEach(function(r) {
        r.setContext(e);
      });
    }, t;
  }()
);
function Oh(t) {
  var e = t.from, r = t.to;
  return t instanceof nt.AllSelection ? [e + 1, r - 1] : [e, r];
}
function zv(t) {
  return t.index(0) + 1;
}
function xi(t, e, r) {
  r === void 0 && (r = 1);
  var n = 0;
  return t.forEach(function(a, i) {
    Wu(a) && i + 2 < e && (n += 2 * r);
  }), n;
}
function is(t, e, r) {
  r === void 0 && (r = e);
  var n = e === r, a = t.resolve(e), i = zv(a), o = i, u = a.start(1), m = u;
  if (!n) {
    var y = t.resolve(r === t.content.size ? r - 1 : r);
    m = y.start(1), o = zv(y), y.pos === t.content.size && (r = t.content.size - 2);
  }
  var C = Math.max(e - u + 1, 1), T = Math.max(r - m + 1, 1);
  return [
    [i, C + xi(t.child(i - 1), C, -1)],
    [o, T + xi(t.child(o - 1), T, -1)]
  ];
}
function Dh(t, e) {
  for (var r = [], n = 0, a = 0; n < e; n += 1) {
    var i = t.child(n);
    r[n] = a, a += i.nodeSize;
  }
  return r;
}
function Ka(t, e, r) {
  var n = Dh(t, r[0]), a = e[0] - 1, i = r[0] - 1, o = t.child(a), u = t.child(i), m = n[a], y = n[i];
  return m += e[1] + xi(o, e[1] - 1), y += r[1] + xi(u, r[1] - 1), [m, Math.min(y, t.content.size)];
}
function vr(t) {
  var e = t.$from, r = t.$to, n = t.from, a = t.to, i = e.doc;
  return t instanceof nt.AllSelection && (e = i.resolve(n + 1), r = i.resolve(a - 1)), e.depth === 0 && (e = i.resolve(n - 1), r = e), {
    startFromOffset: e.start(1),
    endFromOffset: r.start(1),
    startToOffset: e.end(1),
    endToOffset: r.end(1),
    startIndex: e.index(0),
    endIndex: r.index(0),
    from: e.pos,
    to: r.pos
  };
}
function ws(t, e) {
  for (var r = 1, n = 1, a = 0, i = 0; a < t.childCount; a += 1) {
    var o = t.child(a).nodeSize;
    if (r = i + 1, n = i + o - 1, a === e)
      break;
    i += o;
  }
  return { startOffset: r, endOffset: n };
}
var $v = "heading", h7 = "blockQuote", m7 = "listItem", g7 = "table", y7 = "tableCell", b7 = "codeBlock", k7 = "thematicBreak", ss = "link", Ko = "code", Hs = "meta", Xa = "delimiter", w7 = "taskDelimiter", Ic = "markedText", C7 = "html", T7 = "customBlock", Vv = {
  strong: 2,
  emph: 1,
  strike: 2
};
function It(t, e, r, n) {
  return { start: t, end: e, spec: { type: r, attrs: n } };
}
function S7(t, e, r) {
  var n = t.level, a = t.headingType, i = [It(e, r, $v, { level: n })];
  return a === "atx" ? i.push(It(e, br(e, n), Xa)) : i.push(It(Ta(r, 0), r, $v, { seText: !0 })), i;
}
function yu(t, e, r) {
  var n = t.type, a = br(e, Vv[n]), i = br(r, -Vv[n]);
  return [
    It(a, i, n),
    It(e, a, Xa),
    It(i, r, Xa)
  ];
}
function Nh(t, e, r, n) {
  return [
    It(t, e, ss),
    It(Ta(t, r[1] + 1), Ta(e, n), ss, {
      desc: !0
    }),
    It(Ta(e, n + 2), br(e, -1), ss, { url: !0 })
  ];
}
function E7(t, e, r) {
  var n = t.lastChild, a = n ? Ca(n) + 1 : 3, i = br(e, 1);
  return Wr([It(e, i, Hs)], Nh(e, r, i, a));
}
function x7(t, e, r) {
  var n = t.lastChild, a = t.extendedAutolink, i = n ? Ca(n) + 1 : 2;
  return a ? [It(e, r, ss, { desc: !0 })] : Nh(e, r, e, i);
}
function A7(t, e, r) {
  var n = t.tickCount, a = br(e, n), i = br(r, -n);
  return [
    It(e, r, Ko),
    It(e, a, Ko, { start: !0 }),
    It(a, i, Ko, { marked: !0 }),
    It(i, r, Ko, { end: !0 })
  ];
}
function Rh(t, e, r, n) {
  var a = {
    start: e,
    end: r,
    spec: {
      attrs: { className: n + "-line-background", codeStart: e[0], codeEnd: r[0] }
    },
    lineBackground: !0
  };
  return t.type !== "item" && t.type !== "blockQuote" ? [
    ge(ge({}, a), { end: e, spec: { attrs: { className: n + "-line-background start" } } }),
    ge(ge({}, a), { start: [Math.min(e[0] + 1, r[0]), e[1]] })
  ] : null;
}
function M7(t, e, r, n) {
  var a = t.fenceOffset, i = t.fenceLength, o = t.fenceChar, u = t.info, m = t.infoPadding, y = t.parent, C = a + i, T = [It(Ta(e, 1), r, b7)];
  o && T.push(It(e, br(e, C), Xa)), u && T.push(It(br(e, i), br(e, i + m + u.length), Hs));
  var x = "^(\\s{0,4})(" + o + "{" + i + ",})", M = new RegExp(x);
  M.test(n) && T.push(It(Ta(r, 1), r, Xa));
  var P = Rh(y, e, r, "code-block");
  return P ? T.concat(P) : T;
}
function L7(t, e, r) {
  var n = t, a = n.offset, i = n.syntaxLength, o = n.info, u = n.parent, m = a + i, y = [It(Ta(e, 1), r, T7)];
  y.push(It(e, br(e, m), Xa)), o && y.push(It(br(e, m), br(e, i + o.length), Hs)), y.push(It(Ta(r, 1), r, Xa));
  var C = Rh(u, e, r, "custom-block");
  return C ? y.concat(C) : y;
}
function Ih(t, e) {
  for (var r = []; t; ) {
    var n = t.type;
    (n === "paragraph" || n === "codeBlock") && r.push(It([lo(t), qs(t) - 1], [Bs(t), Ca(t) + 1], e)), t = t.next;
  }
  return r;
}
function O7(t) {
  for (var e = []; t; )
    e.push(It([lo(t), qs(t)], [Bs(t), Ca(t) + 1], Ic)), t = t.next;
  return e;
}
function D7(t, e, r) {
  var n = t.parent && t.parent.type !== "blockQuote" ? [It(e, r, h7)] : [];
  if (t.firstChild) {
    var a = [];
    t.firstChild.type === "paragraph" ? a = O7(t.firstChild.firstChild) : t.firstChild.type === "list" && (a = Ih(t.firstChild, Ic)), n = Wr(Wr([], n), a);
  }
  return n;
}
function N7(t) {
  for (var e = 0; t.parent.parent && t.parent.parent.type === "item"; )
    t = t.parent.parent, e += 1;
  var r = [{ odd: !0 }, { even: !0 }][e % 2];
  return [m7, ge(ge({}, r), { listStyle: !0 })];
}
function R7(t, e) {
  var r = t.listData, n = r.padding, a = r.task, i = N7(t), o = [It.apply(void 0, Wr([e, br(e, n)], i))];
  return a && (o.push(It(br(e, n), br(e, n + 3), w7)), o.push(It(br(e, n + 1), br(e, n + 2), Hs))), o.concat(Ih(t.firstChild, Ic));
}
var Wv = {
  heading: S7,
  strong: yu,
  emph: yu,
  strike: yu,
  link: x7,
  image: E7,
  code: A7,
  codeBlock: M7,
  blockQuote: D7,
  item: R7,
  customBlock: L7
}, jv = {
  thematicBreak: k7,
  table: g7,
  tableCell: y7,
  htmlInline: C7
};
function I7(t, e, r, n) {
  var a = t.type;
  return un(Wv[a]) ? Wv[a](t, e, r, n) : jv[a] ? [It(e, r, jv[a])] : null;
}
var ao = {};
function P7(t) {
  var e = t.schema, r = t.toastMark;
  return new nt.Plugin({
    appendTransaction: function(n, a, i) {
      var o = n[0], u = i.tr;
      if (o.docChanged) {
        var m = [], y = o.getMeta("editResult");
        y.forEach(function(C) {
          var T = C.nodes, x = C.removedNodeRange;
          if (T.length) {
            m = m.concat(U7(u, T));
            for (var M = 0, P = T; M < P.length; M++)
              for (var q = P[M], _ = q.walker(), K = _.next(); K; ) {
                var X = K.node, ie = K.entering;
                ie && (m = m.concat(z7(X, r))), K = _.next();
              }
          } else if (x)
            for (var ee = u.doc.childCount - 1, oe = x.line, ue = oe[0], pe = oe[1], Se = Math.min(ue, ee), Re = Math.min(pe, ee), Me = Se; Me <= Re; Me += 1)
              ao[Me] = !0;
        }), F7(u, e, m);
      }
      return u.setMeta("widget", o.getMeta("widget"));
    }
  });
}
function B7(t, e, r) {
  return Object.keys(r).some(function(n) {
    return r[n] !== t.child(e).attrs[n];
  });
}
function q7(t, e, r, n, a) {
  a === void 0 && (a = {});
  for (var i = n.startIndex, o = n.endIndex, u = n.from, m = n.to, y = !1, C = i; C <= o; C += 1)
    delete ao[C], y = B7(e, C, a);
  y && t.setBlockType(u, m, r, a);
}
function F7(t, e, r) {
  var n = t.doc, a = e.nodes.paragraph, i = Dh(n, n.childCount);
  r.forEach(function(o) {
    var u = o.start, m = o.end, y = o.spec, C = o.lineBackground, T = Math.min(u[0], n.childCount) - 1, x = Math.min(m[0], n.childCount) - 1, M = n.child(T), P = n.child(x), q = i[T], _ = i[x];
    if (q += u[1] + xi(M, u[1] - 1), _ += m[1] + xi(P, m[1] - 1), y)
      if (C) {
        var K = { from: q, to: _, startIndex: T, endIndex: x };
        q7(t, n, a, K, y.attrs);
      } else
        t.addMark(q, _, e.mark(y.type, y.attrs));
    else
      t.removeMark(q, _);
  }), _7(t, i, a);
}
function _7(t, e, r) {
  Object.keys(ao).forEach(function(n) {
    var a = Number(n), i = Math.min(Number(n) + 1, t.doc.childCount - 1), o = e[a], u = e[i] - 1;
    a === i && (u += 2), t.setBlockType(o, u, r);
  });
}
function H7(t, e, r) {
  var n = [];
  ao = {};
  for (var a = e[0] - 1; a < r[0]; a += 1) {
    var i = t.child(a), o = i.attrs.codeEnd, u = i.attrs.codeStart;
    if (u && o && !Ar(n, u)) {
      n.push(u), o = Math.min(o, t.childCount);
      for (var m = u - 1, y = r[0], C = m; C < y; C += 1)
        ao[C] = !0;
    }
  }
}
function U7(t, e) {
  var r = t.doc, n = e[0].sourcepos[0], a = Dr(e).sourcepos, i = a[1], o = [n[0], n[1]], u = [i[0], i[1] + 1], m = [];
  return H7(r, n, i), m.push({ start: o, end: u }), m;
}
function z7(t, e) {
  var r = e.getLineTexts(), n = [lo(t), qs(t)], a = [Bs(t), Ca(t) + 1], i = I7(t, n, a, r[a[0] - 1]);
  return i ?? [];
}
var $7 = [
  "taskList",
  "orderedList",
  "bulletList",
  "table",
  "strong",
  "emph",
  "strike",
  "heading",
  "thematicBreak",
  "blockQuote",
  "code",
  "codeBlock",
  "indent",
  "outdent"
];
function V7(t) {
  var e = t.type;
  return Za(t) ? t.listData.task ? "taskList" : t.listData.type === "ordered" ? "orderedList" : "bulletList" : e.indexOf("table") !== -1 ? "table" : Ar($7, e) ? e : null;
}
function W7(t) {
  var e = {
    indent: { active: !1, disabled: !0 },
    outdent: { active: !1, disabled: !0 }
  }, r = !0;
  return IY(t, function(n) {
    var a = V7(n);
    a && (a === "bulletList" || a === "orderedList" ? r && (e[a] = { active: !0 }, e.indent.disabled = !1, e.outdent.disabled = !1, r = !1) : e[a] = { active: !0 });
  }), e;
}
function j7(t) {
  var e = t.toastMark, r = t.eventEmitter;
  return new nt.Plugin({
    view: function() {
      return {
        update: function(n, a) {
          var i = n.state, o = i.doc, u = i.selection;
          if (!(a && a.doc.eq(o) && a.selection.eq(u))) {
            var m = u.from, y = i.doc.resolve(m).start(), C = i.doc.content.findIndex(m).index + 1, T = m - y;
            m === y && (T += 1);
            var x = [C, T], M = e.findNodeAtPosition(x), P = W7(M);
            r.emit("changeToolbarState", {
              cursorPos: x,
              mdNode: M,
              toolbarState: P
            }), r.emit("setFocusedNode", M);
          }
        }
      };
    }
  });
}
var G7 = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "doc";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "block+"
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }($t)
), jt = (
  /** @class */
  function() {
    function t() {
    }
    return Object.defineProperty(t.prototype, "type", {
      get: function() {
        return "mark";
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.setContext = function(e) {
      this.context = e;
    }, t;
  }()
);
function en(t, e) {
  return Sa(t, e - 1);
}
function Sa(t, e) {
  return t.child(e).textContent;
}
var Zi = /^\s*> ?/, K7 = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "blockQuote";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: dr("block-quote") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.createBlockQuoteText = function(r, n) {
      return n ? r.replace(Zi, "").trim() : "> " + r.trim();
    }, e.prototype.extendBlockQuote = function() {
      var r = this;
      return function(n, a) {
        var i = n.selection, o = n.doc, u = n.tr, m = n.schema, y = vr(i), C = y.endFromOffset, T = y.endToOffset, x = y.endIndex, M = y.to, P = Sa(o, x), q = Zi.test(P);
        if (q && M > C && i.empty) {
          var _ = !P.replace(Zi, "").trim();
          if (_)
            u.deleteRange(C, T).split(u.mapping.map(T));
          else {
            var K = P.slice(M - C).trim(), X = xr(m, r.createBlockQuoteText(K));
            Ac(u, T, K, X);
          }
          return a(u), !0;
        }
        return !1;
      };
    }, e.prototype.commands = function() {
      var r = this;
      return function() {
        return function(n, a) {
          var i = n.selection, o = n.doc, u = vr(i), m = u.startFromOffset, y = u.endToOffset, C = u.startIndex, T = u.endIndex, x = Zi.test(Sa(o, C)), M = ks({
            state: n,
            startIndex: C,
            endIndex: T,
            from: m,
            createText: function(P) {
              return r.createBlockQuoteText(P, x);
            }
          });
          return a(M.setSelection(Wt(M, M.mapping.map(y)))), !0;
        };
      };
    }, e.prototype.keymaps = function() {
      var r = this.commands()();
      return {
        "alt-q": r,
        "alt-Q": r,
        Enter: this.extendBlockQuote()
      };
    }, e;
  }(jt)
), ei = /(^\s*)([-*+] |[\d]+\. )/, Pc = /(^\s*)([\d])+\.( \[[ xX]])? /, na = /^(\s*)((\d+)([.)]\s(?:\[(?:x|\s)\]\s)?))(.*)/, Cs = /(^\s*)([-*+]|[\d]+\.)( \[[ xX]])? /, J7 = /^(\s*)([-*+]+(\s(?:\[(?:x|\s)\]\s)?))(.*)/, Y7 = /(^\s*)([-*+] |[\d]+\. )(\[[ xX]] )/, Z7 = /(^\s*)([-*+])( \[[ xX]]) /;
function Bc(t) {
  return Pc.test(t) ? "ordered" : "bullet";
}
function qc(t) {
  for (var e = 0; t && t.type !== "document"; )
    t.type === "list" && (e += 1), t = t.parent;
  return e;
}
function ju(t, e, r, n) {
  for (var a = t.getLineTexts(), i = a.length, o = [], u = e; n ? u < i : u > 1; ) {
    u = n ? u + 1 : u - 1;
    var m = t.findFirstNodeAtLine(u), y = qc(m);
    if (y === r)
      o.push({ line: u, depth: r, mdNode: m });
    else if (y < r)
      break;
  }
  return o;
}
function Q7(t) {
  var e = t.toastMark, r = t.mdNode, n = t.line, a = qc(r), i = ju(e, n, a, !1).reverse(), o = ju(e, n, a, !0);
  return i.concat([{ line: n, depth: a, mdNode: r }]).concat(o);
}
function X7(t) {
  if (!ei.test(t))
    return "* " + t;
  var e = Bc(t);
  return e === "bullet" && Cs.test(t) ? t = t.replace(Z7, "$1$2 ") : e === "ordered" && (t = t.replace(Pc, "$1* ")), t;
}
function eZ(t, e) {
  if (!ei.test(t))
    return e + ". " + t;
  var r = Bc(t);
  if (r === "bullet" || r === "ordered" && Cs.test(t))
    t = t.replace(Cs, "$1" + e + ". ");
  else if (r === "ordered") {
    var n = na.exec(t)[3];
    Number(n) !== e && (t = t.replace(Pc, "$1" + e + ". "));
  }
  return t;
}
function Ph(t, e, r, n) {
  n === void 0 && (n = 0);
  var a = Number.MAX_VALUE, i = 0, o = e.map(function(u, m) {
    var y = u.line;
    a = Math.min(y - 1, a), i = Math.max(y - 1, i);
    var C = en(t, y);
    return C = r === "bullet" ? X7(C) : eZ(C, m + 1 + n), { text: C, line: y };
  });
  return { changedResults: o, firstIndex: a, lastIndex: i };
}
function Gv(t, e) {
  var r = Q7(e);
  return Ph(e.doc, r, t);
}
var tZ = {
  bullet: function(t) {
    return Gv("bullet", t);
  },
  ordered: function(t) {
    return Gv("ordered", t);
  },
  task: function(t) {
    var e = t.mdNode, r = t.doc, n = t.line, a = en(r, n);
    return e.listData.task ? a = a.replace(Y7, "$1$2") : Za(e) && (a = a.replace(ei, "$1$2[ ] ")), { changedResults: [{ text: a, line: n }] };
  }
}, rZ = {
  bullet: function(t) {
    var e = t.doc, r = t.line, n = en(e, r), a = [{ text: "* " + n, line: r }];
    return { changedResults: a };
  },
  ordered: function(t) {
    for (var e = t.toastMark, r = t.doc, n = t.line, a = t.startLine, i = en(r, n), o = 1, u = a, m = 0, y = a - 1; y > 0; y -= 1) {
      var C = e.findFirstNodeAtLine(y), T = en(r, y), x = T && !!Si(C, function(ie) {
        return Za(ie);
      }), M = na.exec(en(r, y));
      if (!M && !x)
        break;
      if (!M && x) {
        m += 1;
        continue;
      }
      var P = M, q = P[1], _ = P[3];
      if (!q) {
        o = Number(_), u = y;
        break;
      }
    }
    var K = o + n - u - m, X = [{ text: K + ". " + i, line: n }];
    return { changedResults: X };
  },
  task: function(t) {
    var e = t.doc, r = t.line, n = en(e, r), a = [{ text: "* [ ] " + n, line: r }];
    return { changedResults: a };
  }
}, nZ = {
  bullet: function(t) {
    var e = t.line, r = t.doc, n = en(r, e), a = J7.exec(n), i = a[1], o = a[2];
    return { listSyntax: "" + i + o };
  },
  ordered: function(t) {
    var e = t.toastMark, r = t.line, n = t.mdNode, a = t.doc, i = qc(n), o = en(a, r), u = na.exec(o), m = u[1], y = u[3], C = u[4], T = Number(y) + 1, x = "" + m + T + C, M = ju(e, r, i, !0), P = M.filter(function(q) {
      var _ = na.exec(en(a, q.line));
      return _ && _[1].length === m.length && !!Si(q.mdNode, function(K) {
        return uh(K);
      });
    });
    return ge({ listSyntax: x }, Ph(a, P, "ordered", T));
  }
};
function Bh(t, e, r, n, a) {
  for (var i = [], o = en(t, r), u = na.exec(o); u; ) {
    var m = u[1], y = u[4], C = u[5], T = m.length;
    if (T === a)
      i.push(xr(e, "" + m + n + y + C)), n += 1, r += 1;
    else if (T > a) {
      var x = Bh(t, e, r, 1, T);
      r = x.line, i = i.concat(x.nodes);
    }
    if (T < a || r > t.childCount)
      break;
    o = en(t, r), u = na.exec(o);
  }
  return { nodes: i, line: r };
}
var Kv = /(^\s{1,4})(.*)/;
function Jv(t, e, r) {
  return t < e || ei.test(r) || Zi.test(r);
}
function Yv(t, e, r) {
  var n = r.$from;
  n.depth === 0 && (n = t.resolve(n.pos - 1));
  var a = n.node(1), i = n.start(1), o = a.content.size;
  return a.rangeHasMark(0, o, e.marks.table) && n.pos - i !== o && n.pos !== i;
}
function Zv(t, e) {
  var r = e.from, n = e.to;
  if (e.type === "indent") {
    var a = 4;
    r += a, n += (e.lineLen + 1) * a;
  } else {
    var i = e.spaceLenList;
    r -= i[0];
    for (var o = 0; o < i.length; o += 1)
      n -= i[o];
  }
  return Wt(t, r, n);
}
var aZ = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "paragraph";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "inline*",
          attrs: {
            className: { default: null },
            codeStart: { default: null },
            codeEnd: { default: null }
          },
          selectable: !1,
          group: "block",
          parseDOM: [{ tag: "div" }],
          toDOM: function(r) {
            var n = r.attrs;
            return n.className ? ["div", { class: dr(n.className) }, 0] : ["div", 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.reorderList = function(r, n) {
      for (var a = this.context, i = a.view, o = a.toastMark, u = a.schema, m = i.state, y = m.tr, C = m.selection, T = m.doc, x = o.findFirstNodeAtLine(r), M = x; x && !NY(x) && x.parent.type !== "document"; )
        if (x = x.parent, uh(x)) {
          M = x;
          break;
        }
      M && (r = M.sourcepos[0][0]);
      var P = na.exec(en(T, r)), q = P[1], _ = P[3], K = q.length, X = Bh(T, u, r, Number(_), K), ie = X.line, ee = X.nodes;
      n = Math.max(n, ie - 1);
      for (var oe = ws(T, r - 1).startOffset, ue = r - 1; ue <= n - 1; ue += 1) {
        var pe = T.child(ue), Se = pe.nodeSize, Re = pe.content, Me = y.mapping.map(oe), ze = Me + Re.size;
        y.replaceWith(Me, ze, ee[ue - r + 1]), oe += Se;
      }
      var vt = Wt(y, C.from, C.to);
      i.dispatch(y.setSelection(vt));
    }, e.prototype.indent = function(r) {
      var n = this;
      return r === void 0 && (r = !1), function() {
        return function(a, i) {
          var o = a.schema, u = a.selection, m = a.doc, y = vr(u), C = y.from, T = y.to, x = y.startFromOffset, M = y.startIndex, P = y.endIndex;
          if (r && Yv(m, o, u))
            return !1;
          var q = Sa(m, M);
          if (r && Jv(C, T, q) || !r && ei.test(q)) {
            var _ = ks({
              state: a,
              from: x,
              startIndex: M,
              endIndex: P,
              createText: function(X) {
                return "    " + X;
              }
            }), K = {
              type: "indent",
              from: C,
              to: T,
              lineLen: P - M
            };
            i(_.setSelection(Zv(_, K))), na.test(q) && n.reorderList(M + 1, P + 1);
          } else
            r && i(a.tr.insert(T, xr(o, "    ")));
          return !0;
        };
      };
    }, e.prototype.outdent = function(r) {
      var n = this;
      return r === void 0 && (r = !1), function() {
        return function(a, i) {
          var o = a.selection, u = a.doc, m = a.schema, y = vr(o), C = y.from, T = y.to, x = y.startFromOffset, M = y.startIndex, P = y.endIndex;
          if (r && Yv(u, m, o))
            return !1;
          var q = Sa(u, M);
          if (r && Jv(C, T, q) || !r && ei.test(q)) {
            var _ = [], K = ks({
              state: a,
              from: x,
              startIndex: M,
              endIndex: P,
              createText: function(ue) {
                var pe = Kv.exec(ue);
                return _.push(pe ? pe[1].length : 0), ue.replace(Kv, "$2");
              }
            }), X = { type: "outdent", from: C, to: T, spaceLenList: _ };
            i(K.setSelection(Zv(K, X))), na.test(q) && n.reorderList(M + 1, P + 1);
          } else if (r) {
            var ie = q.slice(0, T - x), ee = ie.replace(/\s{1,4}$/, ""), oe = T - (ie.length - ee.length);
            i(a.tr.delete(oe, T));
          }
          return !0;
        };
      };
    }, e.prototype.deleteLines = function() {
      var r = this;
      return function(n, a) {
        var i = r.context.view, o = vr(n.selection), u = o.startFromOffset, m = o.endToOffset, y = function() {
          return a(n.tr.deleteRange(u, m)), !0;
        };
        return Is(y, Yp)(n, a, i);
      };
    }, e.prototype.moveDown = function() {
      return function(r, n) {
        var a = r.doc, i = r.tr, o = r.selection, u = r.schema, m = vr(o), y = m.startFromOffset, C = m.endToOffset, T = m.endIndex;
        if (T < a.content.childCount - 1) {
          var x = a.child(T + 1), M = x.nodeSize, P = x.textContent;
          return i.delete(C, C + M).split(y).insert(i.mapping.map(y) - 2, xr(u, P)), n(i), !0;
        }
        return !1;
      };
    }, e.prototype.moveUp = function() {
      return function(r, n) {
        var a = r.tr, i = r.doc, o = r.selection, u = r.schema, m = vr(o), y = m.startFromOffset, C = m.endToOffset, T = m.startIndex;
        if (T > 0) {
          var x = i.child(T - 1), M = x.nodeSize, P = x.textContent;
          return a.delete(y - M, y).split(a.mapping.map(C)).insert(a.mapping.map(C), xr(u, P)), n(a), !0;
        }
        return !1;
      };
    }, e.prototype.commands = function() {
      return {
        indent: this.indent(),
        outdent: this.outdent()
      };
    }, e.prototype.keymaps = function() {
      return {
        Tab: this.indent(!0)(),
        "Shift-Tab": this.outdent(!0)(),
        "Mod-d": this.deleteLines(),
        "Mod-D": this.deleteLines(),
        "Alt-ArrowUp": this.moveUp(),
        "Alt-ArrowDown": this.moveDown()
      };
    }, e;
  }($t)
), iZ = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "text";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          group: "inline"
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }($t)
), oZ = /^#{1,6}\s/, sZ = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "heading";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            level: { default: 1 },
            seText: { default: !1 }
          },
          toDOM: function(r) {
            var n = r.attrs, a = n.level, i = n.seText, o = "heading|heading" + a;
            return i && (o += "|delimiter|setext"), ["span", { class: dr.apply(void 0, o.split("|")) }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.createHeadingText = function(r, n, a) {
      for (var i = n.replace(a, "").trim(), o = ""; r > 0; )
        o += "#", r -= 1;
      return o + " " + i;
    }, e.prototype.commands = function() {
      var r = this;
      return function(n) {
        return function(a, i) {
          var o = n.level, u = vr(a.selection), m = u.startFromOffset, y = u.endToOffset, C = u.startIndex, T = u.endIndex, x = ks({
            state: a,
            from: m,
            startIndex: C,
            endIndex: T,
            createText: function(M) {
              var P = M.match(oZ), q = P ? P[0] : "";
              return r.createHeadingText(o, M, q);
            }
          });
          return i(x.setSelection(Wt(x, x.mapping.map(y)))), !0;
        };
      };
    }, e;
  }(jt)
), bu = "```", lZ = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "codeBlock";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: dr("code-block") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return function() {
        return function(r, n) {
          var a = r.selection, i = r.schema, o = r.tr, u = vr(a), m = u.startFromOffset, y = u.endToOffset, C = xr(i, bu);
          return o.insert(m, C).split(m + bu.length), o.split(o.mapping.map(y)).insert(o.mapping.map(y), C), n(o.setSelection(
            // subtract fenced syntax length and open, close tag(2)
            Wt(o, o.mapping.map(y) - (bu.length + 2))
          )), !0;
        };
      };
    }, e.prototype.keepIndentation = function() {
      var r = this;
      return function(n, a) {
        var i = n.selection, o = n.tr, u = n.doc, m = n.schema, y = r.context.toastMark, C = vr(i), T = C.startFromOffset, x = C.endToOffset, M = C.endIndex, P = C.from, q = C.to, _ = Sa(u, M);
        if (P === q && _.trim()) {
          var K = _.match(/^\s+/), X = y.findFirstNodeAtLine(M + 1);
          if (DY(X) && K) {
            var ie = K[0], ee = _.slice(q - T), oe = xr(m, ie + ee);
            return Ac(o, x, ee, oe), a(o), !0;
          }
        }
        return !1;
      };
    }, e.prototype.keymaps = function() {
      var r = this.commands()();
      return {
        "Shift-Mod-p": r,
        "Shift-Mod-P": r,
        Enter: this.keepIndentation()
      };
    }, e;
  }(jt)
), uZ = /\||\s/g;
function cZ(t) {
  return [Ts(t), Ts(t, !0)];
}
function fZ(t, e) {
  for (var r = [], n = 0; n < e; n += 1)
    r.push(Ts(t));
  return r;
}
function Ts(t, e) {
  for (var r = "|", n = 0; n < t; n += 1)
    r += e ? " --- |" : "  |";
  return r;
}
function vZ(t) {
  return t ? { type: "next", parentType: "tableHead", childType: "firstChild" } : { type: "prev", parentType: "tableBody", childType: "lastChild" };
}
var dZ = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "table";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: dr("table") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.extendTable = function() {
      var r = this;
      return function(n, a) {
        var i = n.selection, o = n.doc, u = n.tr, m = n.schema;
        if (!i.empty)
          return !1;
        var y = vr(i), C = y.endFromOffset, T = y.endToOffset, x = y.endIndex, M = y.to, P = Sa(o, x), q = [x + 1, M - C + 1], _ = r.context.toastMark.findNodeAtPosition(q), K = Si(_, function(ue) {
          return _v(ue) && (ue.parent.type === "tableDelimRow" || ue.parent.parent.type === "tableBody");
        });
        if (K) {
          var X = !P.replace(uZ, "").trim(), ie = K.parent, ee = ie.parent.parent.columns.length, oe = Ts(ee);
          return X ? u.deleteRange(C, T).split(u.mapping.map(T)) : u.split(T).insert(u.mapping.map(T), xr(m, oe)).setSelection(Wt(u, u.mapping.map(T) - 2)), a(u), !0;
        }
        return !1;
      };
    }, e.prototype.moveTableCell = function(r) {
      var n = this;
      return function(a, i) {
        var o = a.selection, u = a.tr, m = vr(o), y = m.endFromOffset, C = m.endIndex, T = m.to, x = [C + 1, T - y], M = n.context.toastMark.findNodeAtPosition(x), P = Si(M, function(pe) {
          return _v(pe);
        });
        if (P) {
          var q = P.parent, _ = vZ(r), K = _.type, X = _.parentType, ie = _.childType, ee = Ca(P);
          if (P[K])
            ee = Ca(P[K]) - 1;
          else {
            var oe = !q[K] && q.parent.type === X ? q.parent[K][ie] : q[K];
            if (K === "next") {
              var ue = oe ? Ca(oe[ie]) : 0;
              ee += ue + 2;
            } else
              K === "prev" && (ee = oe ? -4 : 0);
          }
          return i(u.setSelection(Wt(u, y + ee))), !0;
        }
        return !1;
      };
    }, e.prototype.addTable = function() {
      return function(r) {
        return function(n, a) {
          var i = n.selection, o = n.tr, u = n.schema, m = r, y = m.columnCount, C = m.rowCount, T = vr(i).endToOffset, x = cZ(y), M = fZ(y, C - 1), P = Wr(Wr([], x), M);
          return P.forEach(function(q) {
            o.split(o.mapping.map(T)).insert(o.mapping.map(T), xr(u, q));
          }), a(o.setSelection(Wt(o, T + 4))), !0;
        };
      };
    }, e.prototype.commands = function() {
      return { addTable: this.addTable() };
    }, e.prototype.keymaps = function() {
      return {
        Enter: this.extendTable(),
        Tab: this.moveTableCell(!0),
        "Shift-Tab": this.moveTableCell(!1)
      };
    }, e;
  }(jt)
), pZ = "***", hZ = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "thematicBreak";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: dr("thematic-break") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.hr = function() {
      return function() {
        return function(r, n) {
          var a = r.selection, i = r.schema, o = r.tr, u = vr(a), m = u.from, y = u.to, C = u.endToOffset, T = xr(i, pZ);
          return o.split(m).replaceWith(o.mapping.map(m), o.mapping.map(y), T).split(o.mapping.map(y)).setSelection(Wt(o, o.mapping.map(C))), n(o), !0;
        };
      };
    }, e.prototype.commands = function() {
      return { hr: this.hr() };
    }, e.prototype.keymaps = function() {
      var r = this.hr()();
      return { "Mod-l": r, "Mod-L": r };
    }, e;
  }(jt)
);
function mZ(t, e) {
  var r = t.type, n = t.sourcepos, a = n[0][0];
  return e <= a && (r === "codeBlock" || r === "heading" || r.match("table"));
}
var gZ = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "listItem";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            odd: { default: !1 },
            even: { default: !1 },
            listStyle: { default: !1 }
          },
          toDOM: function(r) {
            var n = r.attrs, a = n.odd, i = n.even, o = n.listStyle, u = "list-item";
            return o && (u += "|list-item-style"), a && (u += "|list-item-odd"), i && (u += "|list-item-even"), ["span", { class: dr.apply(void 0, u.split("|")) }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.extendList = function() {
      var r = this;
      return function(n, a) {
        var i = n.selection, o = n.doc, u = n.schema, m = n.tr, y = r.context.toastMark, C = vr(i), T = C.to, x = C.startFromOffset, M = C.endFromOffset, P = C.endIndex, q = C.endToOffset, _ = Sa(o, P), K = ei.test(_);
        if (!K || i.from === x || !i.empty)
          return !1;
        var X = !_.replace(Cs, "").trim();
        if (X)
          m.deleteRange(M, q).split(m.mapping.map(q));
        else {
          var ie = Bc(_), ee = y.findFirstNodeAtLine(P + 1), oe = _.slice(T - M), ue = { toastMark: y, mdNode: ee, doc: o, line: P + 1 }, pe = nZ[ie](ue), Se = pe.listSyntax, Re = pe.changedResults;
          if (Re != null && Re.length) {
            m.split(T), Re.unshift({ text: Se + oe, line: P + 1 }), r.changeToListPerLine(m, Re, {
              from: T,
              // don't subtract 1 because the line has increased through 'split' command.
              startLine: Re[0].line,
              endLine: Dr(Re).line
            });
            var Me = m.mapping.map(q) - oe.length;
            m.setSelection(Wt(m, Me));
          } else {
            var ze = xr(u, Se + oe);
            Ac(m, q, oe, ze);
          }
        }
        return a(m), !0;
      };
    }, e.prototype.toList = function(r) {
      var n = this;
      return function() {
        return function(a, i) {
          for (var o = a.doc, u = a.tr, m = a.selection, y = n.context.toastMark, C = vr(m), T = C.startIndex + 1, x = C.endIndex + 1, M = C.endToOffset, P = [], q = T; q <= x; q += 1) {
            var _ = y.findFirstNodeAtLine(q);
            if (_ && mZ(_, q))
              break;
            if (P.indexOf(q) === -1) {
              var K = { toastMark: y, mdNode: _, doc: o, line: q, startLine: T }, X = (Za(_) ? tZ[r](K) : rZ[r](K)).changedResults, ie = n.changeToListPerLine(u, X, {
                from: ws(o, X[0].line - 1).startOffset,
                startLine: X[0].line,
                endLine: Dr(X).line,
                indexDiff: 1
              });
              M = Math.max(ie, M), X && (P = P.concat(X.map(function(ee) {
                return ee.line;
              })));
            }
          }
          return i(u.setSelection(Wt(u, u.mapping.map(M)))), !0;
        };
      };
    }, e.prototype.changeToListPerLine = function(r, n, a) {
      for (var i = a.from, o = a.startLine, u = a.endLine, m = a.indexDiff, y = m === void 0 ? 0 : m, C = 0, T = function(P) {
        var q = r.doc.child(P), _ = q.nodeSize, K = q.content, X = r.mapping.map(i), ie = X + K.size, ee = n.filter(function(oe) {
          return oe.line - y === P;
        })[0];
        ee && (r.replaceWith(X, ie, xr(x.context.schema, ee.text)), C = Math.max(C, i + K.size)), i += _;
      }, x = this, M = o - y; M <= u - y; M += 1)
        T(M);
      return C;
    }, e.prototype.toggleTask = function() {
      var r = this;
      return function(n, a) {
        for (var i = n.selection, o = n.tr, u = n.doc, m = n.schema, y = r.context.toastMark, C = vr(i), T = C.startIndex, x = C.endIndex, M = null, P = T; P <= x; P += 1) {
          var q = y.findFirstNodeAtLine(P + 1);
          if (Za(q) && q.listData.task) {
            var _ = q.listData, K = _.checked, X = _.padding, ie = K ? " " : "x", ee = q.sourcepos[0], oe = ws(u, ee[0] - 1).startOffset;
            oe += ee[1] + X, M = o.replaceWith(oe, oe + 1, m.text(ie));
          }
        }
        return M ? (a(M), !0) : !1;
      };
    }, e.prototype.commands = function() {
      return {
        bulletList: this.toList("bullet"),
        orderedList: this.toList("ordered"),
        taskList: this.toList("task")
      };
    }, e.prototype.keymaps = function() {
      var r = this.toList("bullet")(), n = this.toList("ordered")(), a = this.toList("task")(), i = this.toggleTask();
      return {
        "Mod-u": r,
        "Mod-U": r,
        "Mod-o": n,
        "Mod-O": n,
        "alt-t": a,
        "alt-T": a,
        "Shift-Ctrl-x": i,
        "Shift-Ctrl-X": i,
        Enter: this.extendList()
      };
    }, e;
  }(jt)
);
function Us(t, e) {
  return function() {
    return function(r, n) {
      var a = r.tr, i = r.selection, o = un(t) ? t : function(ie) {
        return t.test(ie);
      }, u = e.length, m = a.doc, y = Oh(i), C = y[0], T = y[1], x = Math.max(C - u, 1), M = Math.min(T + u, m.content.size - 1), P = i.content(), q = P.content.textBetween(0, P.content.size, `
`), _ = m.textBetween(x, C, `
`), K = m.textBetween(T, M, `
`);
      if (q = "" + _ + q + K, _ && K && o(q))
        a.delete(M - u, M).delete(x, x + u);
      else {
        a.insertText(e, T).insertText(e, C);
        var X = i.empty ? Wt(a, C + u) : Wt(a, C + u, T + u);
        a.setSelection(X);
      }
      return n(a), !0;
    };
  };
}
var yZ = /^(\*{2}|_{2}).*([\s\S]*)\1$/m, bZ = "**", kZ = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "strong";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: dr("strong") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.bold = function() {
      return Us(yZ, bZ);
    }, e.prototype.commands = function() {
      return { bold: this.bold() };
    }, e.prototype.keymaps = function() {
      var r = this.bold()();
      return { "Mod-b": r, "Mod-B": r };
    }, e;
  }(jt)
), wZ = /^(~{2}).*([\s\S]*)\1$/m, CZ = "~~", TZ = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "strike";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: dr("strike") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return Us(wZ, CZ);
    }, e.prototype.keymaps = function() {
      var r = this.commands()();
      return { "Mod-s": r, "Mod-S": r };
    }, e;
  }(jt)
), SZ = /^(\*|_).*([\s\S]*)\1$/m, EZ = "*", xZ = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "emph";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: dr("emph") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.italic = function() {
      return Us(SZ, EZ);
    }, e.prototype.commands = function() {
      return { italic: this.italic() };
    }, e.prototype.keymaps = function() {
      var r = this.italic()();
      return { "Mod-i": r, "Mod-I": r };
    }, e;
  }(jt)
), AZ = /^(`).*([\s\S]*)\1$/m, MZ = "`", LZ = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "code";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            start: { default: !1 },
            end: { default: !1 },
            marked: { default: !1 }
          },
          toDOM: function(r) {
            var n = r.attrs, a = n.start, i = n.end, o = n.marked, u = "code";
            return a && (u += "|delimiter|start"), i && (u += "|delimiter|end"), o && (u += "|marked-text"), ["span", { class: dr.apply(void 0, u.split("|")) }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return Us(AZ, MZ);
    }, e.prototype.keymaps = function() {
      var r = this.commands()();
      return { "Shift-Mod-c": r, "Shift-Mod-C": r };
    }, e;
  }(jt)
), OZ = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "link";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            url: { default: !1 },
            desc: { default: !1 }
          },
          toDOM: function(r) {
            var n = r.attrs, a = n.url, i = n.desc, o = "link";
            return a && (o += "|link-url|marked-text"), i && (o += "|link-desc|marked-text"), ["span", { class: dr.apply(void 0, o.split("|")) }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.addLinkOrImage = function(r) {
      return function(n) {
        return function(a, i) {
          var o = a.selection, u = a.tr, m = a.schema, y = Oh(o), C = y[0], T = y[1], x = n, M = x.linkText, P = x.altText, q = x.linkUrl, _ = x.imageUrl, K = M, X = q, ie = "";
          return r === "image" && (K = P, X = _, ie = "!"), K = gs(K), ie += "[" + K + "](" + X + ")", i(u.replaceWith(C, T, xr(m, ie))), !0;
        };
      };
    }, e.prototype.commands = function() {
      return {
        addImage: this.addLinkOrImage("image"),
        addLink: this.addLinkOrImage("link")
      };
    }, e;
  }(jt)
), DZ = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "taskDelimiter";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: dr("delimiter", "list-item") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(jt)
), NZ = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "delimiter";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: dr("delimiter") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(jt)
), RZ = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "meta";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: dr("meta") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(jt)
), IZ = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "markedText";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: dr("marked-text") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(jt)
), PZ = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "tableCell";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: dr("table-cell") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(jt)
), BZ = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "html";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: dr("html") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(jt)
), ku = "$$", qZ = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "customBlock";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: dr("custom-block") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return function(r) {
        return function(n, a) {
          var i = n.selection, o = n.schema, u = n.tr, m = vr(i), y = m.startFromOffset, C = m.endToOffset;
          if (!(r != null && r.info))
            return !1;
          var T = "" + ku + r.info, x = xr(o, T), M = xr(o, ku);
          return u.insert(y, x).split(y + T.length), u.split(u.mapping.map(C)).insert(u.mapping.map(C), M), a(u.setSelection(Wt(u, u.mapping.map(C) - (ku.length + 2)))), !0;
        };
      };
    }, e;
  }(jt)
), FZ = /x|backspace/i, _Z = /^\[(\s*)(x?)(\s*)\](?:\s+)/i;
function HZ(t) {
  var e = t.schema, r = t.toastMark;
  return new nt.Plugin({
    props: {
      handleDOMEvents: {
        keyup: function(n, a) {
          var i, o = n.state, u = o.doc, m = o.tr, y = o.selection;
          if (y.empty && FZ.test(a.key)) {
            var C = vr(y), T = C.startIndex, x = C.startFromOffset, M = C.from, P = [T + 1, M - x + 1], q = r.findNodeAtPosition(P), _ = Si(q, function(ze) {
              var vt;
              return ze.type === "paragraph" && ((vt = ze.parent) === null || vt === void 0 ? void 0 : vt.type) === "item";
            });
            if (!((i = _ == null ? void 0 : _.firstChild) === null || i === void 0) && i.literal) {
              var K = _.firstChild, X = K.literal.match(_Z);
              if (X) {
                var ie = K.sourcepos[0], ee = X[1], oe = X[2], ue = X[3], pe = ee.length + ue.length, Se = ws(u, ie[0] - 1).startOffset, Re = ie[1] + Se;
                if (oe) {
                  var Me = pe ? pe + 1 : 0;
                  m.replaceWith(Re, Me + Re, e.text(oe)), n.dispatch(m);
                } else
                  pe || (m.insertText(" ", Re), n.dispatch(m));
              }
            }
          }
          return !1;
        }
      }
    }
  });
}
var wu = "cut", Qv = /\r\n|\n|\r/, UZ = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e(r, n) {
      var a = t.call(this, r) || this, i = n.toastMark, o = n.useCommandShortcut, u = o === void 0 ? !0 : o, m = n.mdPlugins, y = m === void 0 ? [] : m;
      return a.editorType = "markdown", a.el.classList.add("md-mode"), a.toastMark = i, a.extraPlugins = y, a.specs = a.createSpecs(), a.schema = a.createSchema(), a.context = a.createContext(), a.keymaps = a.createKeymaps(u), a.view = a.createView(), a.commands = a.createCommands(), a.specs.setContext(ge(ge({}, a.context), { view: a.view })), a.createClipboard(), a.eventEmitter.listen("changePreviewTabWrite", function(C) {
        return a.toggleActive(!0, C);
      }), a.eventEmitter.listen("changePreviewTabPreview", function() {
        return a.toggleActive(!1);
      }), a.initEvent(), a;
    }
    return e.prototype.toggleActive = function(r, n) {
      Lc(this.el, "active", r), r ? n || this.focus() : this.blur();
    }, e.prototype.createClipboard = function() {
      var r = this;
      this.clipboard = document.createElement("textarea"), this.clipboard.className = Ke("pseudo-clipboard"), this.clipboard.addEventListener("paste", function(n) {
        var a = n.clipboardData || window.clipboardData, i = a && a.items;
        if (i) {
          var o = Nn(i).some(function(m) {
            return m.kind === "string" && m.type === "text/rtf";
          });
          if (!o) {
            var u = Eh(i);
            u && (n.preventDefault(), Rc(r.eventEmitter, u, n.type));
          }
        }
      }), this.clipboard.addEventListener("input", function(n) {
        var a = n.target.value;
        r.replaceSelection(a), n.preventDefault(), n.target.value = "";
      }), this.el.insertBefore(this.clipboard, this.view.dom);
    }, e.prototype.createContext = function() {
      return {
        toastMark: this.toastMark,
        schema: this.schema,
        eventEmitter: this.eventEmitter
      };
    }, e.prototype.createSpecs = function() {
      return new Lh([
        new G7(),
        new aZ(),
        new Ah(),
        new iZ(),
        new sZ(),
        new K7(),
        new lZ(),
        new qZ(),
        new dZ(),
        new PZ(),
        new hZ(),
        new gZ(),
        new kZ(),
        new TZ(),
        new xZ(),
        new LZ(),
        new OZ(),
        new NZ(),
        new DZ(),
        new IZ(),
        new RZ(),
        new BZ()
      ]);
    }, e.prototype.createPlugins = function() {
      return Wr([
        P7(this.context),
        j7(this.context),
        HZ(this.context)
      ], this.createPluginProps()).concat(this.defaultPlugins);
    }, e.prototype.createView = function() {
      var r = this;
      return new ia.EditorView(this.el, {
        state: this.createState(),
        dispatchTransaction: function(n) {
          r.updateMarkdown(n);
          var a = r.view.state.applyTransaction(n).state;
          r.view.updateState(a), r.emitChangeEvent(n);
        },
        handleKeyDown: function(n, a) {
          return (a.metaKey || a.ctrlKey) && a.key.toUpperCase() === "V" && r.clipboard.focus(), r.eventEmitter.emit("keydown", r.editorType, a), !1;
        },
        handleDOMEvents: {
          copy: function(n, a) {
            return r.captureCopy(a);
          },
          cut: function(n, a) {
            return r.captureCopy(a, wu);
          },
          scroll: function() {
            return r.eventEmitter.emit("scroll", "editor"), !0;
          },
          keyup: function(n, a) {
            return r.eventEmitter.emit("keyup", r.editorType, a), !1;
          }
        },
        nodeViews: {
          widget: xh
        }
      });
    }, e.prototype.createCommands = function() {
      return this.specs.commands(this.view);
    }, e.prototype.captureCopy = function(r, n) {
      r.preventDefault();
      var a = this.view.state, i = a.selection, o = a.tr;
      if (i.empty)
        return !0;
      var u = this.getChanged(i.content());
      return r.clipboardData ? r.clipboardData.setData("text/plain", u) : window.clipboardData.setData("Text", u), n === wu && this.view.dispatch(o.deleteSelection().scrollIntoView().setMeta("uiEvent", wu)), !0;
    }, e.prototype.updateMarkdown = function(r) {
      var n = this;
      r.docChanged && r.steps.forEach(function(a, i) {
        if (a.slice && !(a instanceof zt.ReplaceAroundStep)) {
          var o = r.docs[i], u = [a.from, a.to], m = u[0], y = u[1], C = is(o, m, y), T = C[0], x = C[1], M = n.getChanged(a.slice);
          T[0] === x[0] && T[1] === x[1] && M === "" && (M = `
`);
          var P = n.toastMark.editMarkdown(T, x, M);
          n.eventEmitter.emit("updatePreview", P), r.setMeta("editResult", P).scrollIntoView();
        }
      });
    }, e.prototype.getChanged = function(r) {
      var n = "", a = 0, i = r.content.size;
      return r.content.nodesBetween(a, i, function(o, u) {
        o.isText ? n += o.text.slice(Math.max(a, u) - u, i - u) : o.isBlock && u > 0 && (n += `
`);
      }), n;
    }, e.prototype.setSelection = function(r, n) {
      n === void 0 && (n = r);
      var a = this.view.state.tr, i = Ka(a.doc, r, n), o = i[0], u = i[1];
      this.view.dispatch(a.setSelection(Wt(a, o, u)).scrollIntoView());
    }, e.prototype.replaceSelection = function(r, n, a) {
      var i, o = this.view.state, u = o.tr, m = o.schema, y = o.doc, C = r.split(Qv), T = C.map(function(_) {
        return bs(m, Ja(_, m));
      }), x = new Qe.Slice(Qe.Fragment.from(T), 1, 1);
      if (this.focus(), n && a) {
        var M = Ka(y, n, a), P = M[0], q = M[1];
        i = u.replaceRange(P, q, x);
      } else
        i = u.replaceSelection(x);
      this.view.dispatch(i.scrollIntoView());
    }, e.prototype.deleteSelection = function(r, n) {
      var a, i = this.view.state, o = i.tr, u = i.doc;
      if (r && n) {
        var m = Ka(u, r, n), y = m[0], C = m[1];
        a = o.deleteRange(y, C);
      } else
        a = o.deleteSelection();
      this.view.dispatch(a.scrollIntoView());
    }, e.prototype.getSelectedText = function(r, n) {
      var a = this.view.state, i = a.doc, o = a.selection, u = o.from, m = o.to;
      if (r && n) {
        var y = Ka(i, r, n);
        u = y[0], m = y[1];
      }
      return i.textBetween(u, m, `
`);
    }, e.prototype.getSelection = function() {
      var r = this.view.state.selection, n = r.from, a = r.to;
      return is(this.view.state.tr.doc, n, a);
    }, e.prototype.setMarkdown = function(r, n) {
      n === void 0 && (n = !0);
      var a = r.split(Qv), i = this.view.state, o = i.tr, u = i.doc, m = i.schema, y = a.map(function(C) {
        return bs(m, Ja(C, m));
      });
      this.view.dispatch(o.replaceWith(0, u.content.size, y)), n && this.moveCursorToEnd(!0);
    }, e.prototype.addWidget = function(r, n, a) {
      var i = this.view.state, o = i.tr, u = i.doc, m = i.selection, y = a ? Ka(u, a, a)[0] : m.to;
      this.view.dispatch(o.setMeta("widget", { pos: y, node: r, style: n }));
    }, e.prototype.replaceWithWidget = function(r, n, a) {
      var i = this.view.state, o = i.tr, u = i.schema, m = i.doc, y = Ka(m, r, n), C = Ja(a, u);
      this.view.dispatch(o.replaceWith(y[0], y[1], C));
    }, e.prototype.getRangeInfoOfNode = function(r) {
      var n = this.view.state, a = n.doc, i = n.selection, o = r || is(a, i.from)[0], u = this.toastMark.findNodeAtPosition(o);
      return u.type === "text" && u.parent.type !== "paragraph" && (u = u.parent), u.sourcepos[1][1] += 1, { range: u.sourcepos, type: u.type };
    }, e.prototype.getMarkdown = function() {
      return this.toastMark.getLineTexts().map(function(r) {
        return Fs(r);
      }).join(`
`);
    }, e.prototype.getToastMark = function() {
      return this.toastMark;
    }, e;
  }(Mh)
), Xv = "_feEventKey";
function zZ(t, e) {
  var r = t[Xv], n;
  return r || (r = t[Xv] = {}), n = r[e], n || (n = r[e] = []), n;
}
var qh = zZ, $Z = sa, Ss = Ps, VZ = qh;
function WZ(t, e, r) {
  if ($Z(e)) {
    Ss(e.split(/\s+/g), function(n) {
      ed(t, n, r);
    });
    return;
  }
  Ss(e, function(n, a) {
    ed(t, a, n);
  });
}
function ed(t, e, r) {
  var n = VZ(t, e), a;
  r ? (Ss(n, function(i, o) {
    return r === i.handler ? (td(t, e, i.wrappedHandler), a = o, !1) : !0;
  }), n.splice(a, 1)) : (Ss(n, function(i) {
    td(t, e, i.wrappedHandler);
  }), n.splice(0, n.length));
}
function td(t, e, r) {
  "removeEventListener" in t ? t.removeEventListener(e, r) : "detachEvent" in t && t.detachEvent("on" + e, r);
}
var Fh = WZ, jZ = sa, Gu = Ps, GZ = qh;
function KZ(t, e, r, n) {
  if (jZ(e)) {
    Gu(e.split(/\s+/g), function(a) {
      rd(t, a, r, n);
    });
    return;
  }
  Gu(e, function(a, i) {
    rd(t, i, a, r);
  });
}
function rd(t, e, r, n) {
  function a(i) {
    r.call(n || t, i || window.event);
  }
  "addEventListener" in t ? t.addEventListener(e, a) : "attachEvent" in t && t.attachEvent("on" + e, a), JZ(t, e, r, a);
}
function JZ(t, e, r, n) {
  var a = GZ(t, e), i = !1;
  Gu(a, function(o) {
    return o.handler === r ? (i = !0, !1) : !0;
  }), i || a.push({
    handler: r,
    wrappedHandler: n
  });
}
var _h = KZ;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Ku = function(t, e) {
  return Ku = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, n) {
    r.__proto__ = n;
  } || function(r, n) {
    for (var a in n)
      Object.prototype.hasOwnProperty.call(n, a) && (r[a] = n[a]);
  }, Ku(t, e);
};
function cn(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  Ku(t, e);
  function r() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r());
}
var Er = function() {
  return Er = Object.assign || function(e) {
    for (var r, n = 1, a = arguments.length; n < a; n++) {
      r = arguments[n];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, Er.apply(this, arguments);
};
function Ju(t, e, r) {
  if (r || arguments.length === 2)
    for (var n = 0, a = e.length, i; n < a; n++)
      (i || !(n in e)) && (i || (i = Array.prototype.slice.call(e, 0, n)), i[n] = e[n]);
  return t.concat(i || Array.prototype.slice.call(e));
}
var Ai = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, nd = {};
function YZ(t) {
  var e, r, n = nd[t];
  if (n)
    return n;
  for (n = nd[t] = [], e = 0; e < 128; e++)
    r = String.fromCharCode(e), /^[0-9a-z]$/i.test(r) ? n.push(r) : n.push("%" + ("0" + e.toString(16).toUpperCase()).slice(-2));
  for (e = 0; e < t.length; e++)
    n[t.charCodeAt(e)] = t[e];
  return n;
}
function zs(t, e, r) {
  var n, a, i, o, u, m = "";
  for (typeof e != "string" && (r = e, e = zs.defaultChars), typeof r > "u" && (r = !0), u = YZ(e), n = 0, a = t.length; n < a; n++) {
    if (i = t.charCodeAt(n), r && i === 37 && n + 2 < a && /^[0-9a-f]{2}$/i.test(t.slice(n + 1, n + 3))) {
      m += t.slice(n, n + 3), n += 2;
      continue;
    }
    if (i < 128) {
      m += u[i];
      continue;
    }
    if (i >= 55296 && i <= 57343) {
      if (i >= 55296 && i <= 56319 && n + 1 < a && (o = t.charCodeAt(n + 1), o >= 56320 && o <= 57343)) {
        m += encodeURIComponent(t[n] + t[n + 1]), n++;
        continue;
      }
      m += "%EF%BF%BD";
      continue;
    }
    m += encodeURIComponent(t[n]);
  }
  return m;
}
zs.defaultChars = ";/?:@&=+$,-_.!~*'()#";
zs.componentChars = "-_.!~*'()";
var ZZ = zs, Fc = {}, aa = {}, QZ = "Á", XZ = "á", eQ = "Ă", tQ = "ă", rQ = "∾", nQ = "∿", aQ = "∾̳", iQ = "Â", oQ = "â", sQ = "´", lQ = "А", uQ = "а", cQ = "Æ", fQ = "æ", vQ = "⁡", dQ = "𝔄", pQ = "𝔞", hQ = "À", mQ = "à", gQ = "ℵ", yQ = "ℵ", bQ = "Α", kQ = "α", wQ = "Ā", CQ = "ā", TQ = "⨿", SQ = "&", EQ = "&", xQ = "⩕", AQ = "⩓", MQ = "∧", LQ = "⩜", OQ = "⩘", DQ = "⩚", NQ = "∠", RQ = "⦤", IQ = "∠", PQ = "⦨", BQ = "⦩", qQ = "⦪", FQ = "⦫", _Q = "⦬", HQ = "⦭", UQ = "⦮", zQ = "⦯", $Q = "∡", VQ = "∟", WQ = "⊾", jQ = "⦝", GQ = "∢", KQ = "Å", JQ = "⍼", YQ = "Ą", ZQ = "ą", QQ = "𝔸", XQ = "𝕒", eX = "⩯", tX = "≈", rX = "⩰", nX = "≊", aX = "≋", iX = "'", oX = "⁡", sX = "≈", lX = "≊", uX = "Å", cX = "å", fX = "𝒜", vX = "𝒶", dX = "≔", pX = "*", hX = "≈", mX = "≍", gX = "Ã", yX = "ã", bX = "Ä", kX = "ä", wX = "∳", CX = "⨑", TX = "≌", SX = "϶", EX = "‵", xX = "∽", AX = "⋍", MX = "∖", LX = "⫧", OX = "⊽", DX = "⌅", NX = "⌆", RX = "⌅", IX = "⎵", PX = "⎶", BX = "≌", qX = "Б", FX = "б", _X = "„", HX = "∵", UX = "∵", zX = "∵", $X = "⦰", VX = "϶", WX = "ℬ", jX = "ℬ", GX = "Β", KX = "β", JX = "ℶ", YX = "≬", ZX = "𝔅", QX = "𝔟", XX = "⋂", eee = "◯", tee = "⋃", ree = "⨀", nee = "⨁", aee = "⨂", iee = "⨆", oee = "★", see = "▽", lee = "△", uee = "⨄", cee = "⋁", fee = "⋀", vee = "⤍", dee = "⧫", pee = "▪", hee = "▴", mee = "▾", gee = "◂", yee = "▸", bee = "␣", kee = "▒", wee = "░", Cee = "▓", Tee = "█", See = "=⃥", Eee = "≡⃥", xee = "⫭", Aee = "⌐", Mee = "𝔹", Lee = "𝕓", Oee = "⊥", Dee = "⊥", Nee = "⋈", Ree = "⧉", Iee = "┐", Pee = "╕", Bee = "╖", qee = "╗", Fee = "┌", _ee = "╒", Hee = "╓", Uee = "╔", zee = "─", $ee = "═", Vee = "┬", Wee = "╤", jee = "╥", Gee = "╦", Kee = "┴", Jee = "╧", Yee = "╨", Zee = "╩", Qee = "⊟", Xee = "⊞", ete = "⊠", tte = "┘", rte = "╛", nte = "╜", ate = "╝", ite = "└", ote = "╘", ste = "╙", lte = "╚", ute = "│", cte = "║", fte = "┼", vte = "╪", dte = "╫", pte = "╬", hte = "┤", mte = "╡", gte = "╢", yte = "╣", bte = "├", kte = "╞", wte = "╟", Cte = "╠", Tte = "‵", Ste = "˘", Ete = "˘", xte = "¦", Ate = "𝒷", Mte = "ℬ", Lte = "⁏", Ote = "∽", Dte = "⋍", Nte = "⧅", Rte = "\\", Ite = "⟈", Pte = "•", Bte = "•", qte = "≎", Fte = "⪮", _te = "≏", Hte = "≎", Ute = "≏", zte = "Ć", $te = "ć", Vte = "⩄", Wte = "⩉", jte = "⩋", Gte = "∩", Kte = "⋒", Jte = "⩇", Yte = "⩀", Zte = "ⅅ", Qte = "∩︀", Xte = "⁁", ere = "ˇ", tre = "ℭ", rre = "⩍", nre = "Č", are = "č", ire = "Ç", ore = "ç", sre = "Ĉ", lre = "ĉ", ure = "∰", cre = "⩌", fre = "⩐", vre = "Ċ", dre = "ċ", pre = "¸", hre = "¸", mre = "⦲", gre = "¢", yre = "·", bre = "·", kre = "𝔠", wre = "ℭ", Cre = "Ч", Tre = "ч", Sre = "✓", Ere = "✓", xre = "Χ", Are = "χ", Mre = "ˆ", Lre = "≗", Ore = "↺", Dre = "↻", Nre = "⊛", Rre = "⊚", Ire = "⊝", Pre = "⊙", Bre = "®", qre = "Ⓢ", Fre = "⊖", _re = "⊕", Hre = "⊗", Ure = "○", zre = "⧃", $re = "≗", Vre = "⨐", Wre = "⫯", jre = "⧂", Gre = "∲", Kre = "”", Jre = "’", Yre = "♣", Zre = "♣", Qre = ":", Xre = "∷", ene = "⩴", tne = "≔", rne = "≔", nne = ",", ane = "@", ine = "∁", one = "∘", sne = "∁", lne = "ℂ", une = "≅", cne = "⩭", fne = "≡", vne = "∮", dne = "∯", pne = "∮", hne = "𝕔", mne = "ℂ", gne = "∐", yne = "∐", bne = "©", kne = "©", wne = "℗", Cne = "∳", Tne = "↵", Sne = "✗", Ene = "⨯", xne = "𝒞", Ane = "𝒸", Mne = "⫏", Lne = "⫑", One = "⫐", Dne = "⫒", Nne = "⋯", Rne = "⤸", Ine = "⤵", Pne = "⋞", Bne = "⋟", qne = "↶", Fne = "⤽", _ne = "⩈", Hne = "⩆", Une = "≍", zne = "∪", $ne = "⋓", Vne = "⩊", Wne = "⊍", jne = "⩅", Gne = "∪︀", Kne = "↷", Jne = "⤼", Yne = "⋞", Zne = "⋟", Qne = "⋎", Xne = "⋏", eae = "¤", tae = "↶", rae = "↷", nae = "⋎", aae = "⋏", iae = "∲", oae = "∱", sae = "⌭", lae = "†", uae = "‡", cae = "ℸ", fae = "↓", vae = "↡", dae = "⇓", pae = "‐", hae = "⫤", mae = "⊣", gae = "⤏", yae = "˝", bae = "Ď", kae = "ď", wae = "Д", Cae = "д", Tae = "‡", Sae = "⇊", Eae = "ⅅ", xae = "ⅆ", Aae = "⤑", Mae = "⩷", Lae = "°", Oae = "∇", Dae = "Δ", Nae = "δ", Rae = "⦱", Iae = "⥿", Pae = "𝔇", Bae = "𝔡", qae = "⥥", Fae = "⇃", _ae = "⇂", Hae = "´", Uae = "˙", zae = "˝", $ae = "`", Vae = "˜", Wae = "⋄", jae = "⋄", Gae = "⋄", Kae = "♦", Jae = "♦", Yae = "¨", Zae = "ⅆ", Qae = "ϝ", Xae = "⋲", eie = "÷", tie = "÷", rie = "⋇", nie = "⋇", aie = "Ђ", iie = "ђ", oie = "⌞", sie = "⌍", lie = "$", uie = "𝔻", cie = "𝕕", fie = "¨", vie = "˙", die = "⃜", pie = "≐", hie = "≑", mie = "≐", gie = "∸", yie = "∔", bie = "⊡", kie = "⌆", wie = "∯", Cie = "¨", Tie = "⇓", Sie = "⇐", Eie = "⇔", xie = "⫤", Aie = "⟸", Mie = "⟺", Lie = "⟹", Oie = "⇒", Die = "⊨", Nie = "⇑", Rie = "⇕", Iie = "∥", Pie = "⤓", Bie = "↓", qie = "↓", Fie = "⇓", _ie = "⇵", Hie = "̑", Uie = "⇊", zie = "⇃", $ie = "⇂", Vie = "⥐", Wie = "⥞", jie = "⥖", Gie = "↽", Kie = "⥟", Jie = "⥗", Yie = "⇁", Zie = "↧", Qie = "⊤", Xie = "⤐", eoe = "⌟", toe = "⌌", roe = "𝒟", noe = "𝒹", aoe = "Ѕ", ioe = "ѕ", ooe = "⧶", soe = "Đ", loe = "đ", uoe = "⋱", coe = "▿", foe = "▾", voe = "⇵", doe = "⥯", poe = "⦦", hoe = "Џ", moe = "џ", goe = "⟿", yoe = "É", boe = "é", koe = "⩮", woe = "Ě", Coe = "ě", Toe = "Ê", Soe = "ê", Eoe = "≖", xoe = "≕", Aoe = "Э", Moe = "э", Loe = "⩷", Ooe = "Ė", Doe = "ė", Noe = "≑", Roe = "ⅇ", Ioe = "≒", Poe = "𝔈", Boe = "𝔢", qoe = "⪚", Foe = "È", _oe = "è", Hoe = "⪖", Uoe = "⪘", zoe = "⪙", $oe = "∈", Voe = "⏧", Woe = "ℓ", joe = "⪕", Goe = "⪗", Koe = "Ē", Joe = "ē", Yoe = "∅", Zoe = "∅", Qoe = "◻", Xoe = "∅", ese = "▫", tse = " ", rse = " ", nse = " ", ase = "Ŋ", ise = "ŋ", ose = " ", sse = "Ę", lse = "ę", use = "𝔼", cse = "𝕖", fse = "⋕", vse = "⧣", dse = "⩱", pse = "ε", hse = "Ε", mse = "ε", gse = "ϵ", yse = "≖", bse = "≕", kse = "≂", wse = "⪖", Cse = "⪕", Tse = "⩵", Sse = "=", Ese = "≂", xse = "≟", Ase = "⇌", Mse = "≡", Lse = "⩸", Ose = "⧥", Dse = "⥱", Nse = "≓", Rse = "ℯ", Ise = "ℰ", Pse = "≐", Bse = "⩳", qse = "≂", Fse = "Η", _se = "η", Hse = "Ð", Use = "ð", zse = "Ë", $se = "ë", Vse = "€", Wse = "!", jse = "∃", Gse = "∃", Kse = "ℰ", Jse = "ⅇ", Yse = "ⅇ", Zse = "≒", Qse = "Ф", Xse = "ф", ele = "♀", tle = "ﬃ", rle = "ﬀ", nle = "ﬄ", ale = "𝔉", ile = "𝔣", ole = "ﬁ", sle = "◼", lle = "▪", ule = "fj", cle = "♭", fle = "ﬂ", vle = "▱", dle = "ƒ", ple = "𝔽", hle = "𝕗", mle = "∀", gle = "∀", yle = "⋔", ble = "⫙", kle = "ℱ", wle = "⨍", Cle = "½", Tle = "⅓", Sle = "¼", Ele = "⅕", xle = "⅙", Ale = "⅛", Mle = "⅔", Lle = "⅖", Ole = "¾", Dle = "⅗", Nle = "⅜", Rle = "⅘", Ile = "⅚", Ple = "⅝", Ble = "⅞", qle = "⁄", Fle = "⌢", _le = "𝒻", Hle = "ℱ", Ule = "ǵ", zle = "Γ", $le = "γ", Vle = "Ϝ", Wle = "ϝ", jle = "⪆", Gle = "Ğ", Kle = "ğ", Jle = "Ģ", Yle = "Ĝ", Zle = "ĝ", Qle = "Г", Xle = "г", eue = "Ġ", tue = "ġ", rue = "≥", nue = "≧", aue = "⪌", iue = "⋛", oue = "≥", sue = "≧", lue = "⩾", uue = "⪩", cue = "⩾", fue = "⪀", vue = "⪂", due = "⪄", pue = "⋛︀", hue = "⪔", mue = "𝔊", gue = "𝔤", yue = "≫", bue = "⋙", kue = "⋙", wue = "ℷ", Cue = "Ѓ", Tue = "ѓ", Sue = "⪥", Eue = "≷", xue = "⪒", Aue = "⪤", Mue = "⪊", Lue = "⪊", Oue = "⪈", Due = "≩", Nue = "⪈", Rue = "≩", Iue = "⋧", Pue = "𝔾", Bue = "𝕘", que = "`", Fue = "≥", _ue = "⋛", Hue = "≧", Uue = "⪢", zue = "≷", $ue = "⩾", Vue = "≳", Wue = "𝒢", jue = "ℊ", Gue = "≳", Kue = "⪎", Jue = "⪐", Yue = "⪧", Zue = "⩺", Que = ">", Xue = ">", ece = "≫", tce = "⋗", rce = "⦕", nce = "⩼", ace = "⪆", ice = "⥸", oce = "⋗", sce = "⋛", lce = "⪌", uce = "≷", cce = "≳", fce = "≩︀", vce = "≩︀", dce = "ˇ", pce = " ", hce = "½", mce = "ℋ", gce = "Ъ", yce = "ъ", bce = "⥈", kce = "↔", wce = "⇔", Cce = "↭", Tce = "^", Sce = "ℏ", Ece = "Ĥ", xce = "ĥ", Ace = "♥", Mce = "♥", Lce = "…", Oce = "⊹", Dce = "𝔥", Nce = "ℌ", Rce = "ℋ", Ice = "⤥", Pce = "⤦", Bce = "⇿", qce = "∻", Fce = "↩", _ce = "↪", Hce = "𝕙", Uce = "ℍ", zce = "―", $ce = "─", Vce = "𝒽", Wce = "ℋ", jce = "ℏ", Gce = "Ħ", Kce = "ħ", Jce = "≎", Yce = "≏", Zce = "⁃", Qce = "‐", Xce = "Í", efe = "í", tfe = "⁣", rfe = "Î", nfe = "î", afe = "И", ife = "и", ofe = "İ", sfe = "Е", lfe = "е", ufe = "¡", cfe = "⇔", ffe = "𝔦", vfe = "ℑ", dfe = "Ì", pfe = "ì", hfe = "ⅈ", mfe = "⨌", gfe = "∭", yfe = "⧜", bfe = "℩", kfe = "Ĳ", wfe = "ĳ", Cfe = "Ī", Tfe = "ī", Sfe = "ℑ", Efe = "ⅈ", xfe = "ℐ", Afe = "ℑ", Mfe = "ı", Lfe = "ℑ", Ofe = "⊷", Dfe = "Ƶ", Nfe = "⇒", Rfe = "℅", Ife = "∞", Pfe = "⧝", Bfe = "ı", qfe = "⊺", Ffe = "∫", _fe = "∬", Hfe = "ℤ", Ufe = "∫", zfe = "⊺", $fe = "⋂", Vfe = "⨗", Wfe = "⨼", jfe = "⁣", Gfe = "⁢", Kfe = "Ё", Jfe = "ё", Yfe = "Į", Zfe = "į", Qfe = "𝕀", Xfe = "𝕚", eve = "Ι", tve = "ι", rve = "⨼", nve = "¿", ave = "𝒾", ive = "ℐ", ove = "∈", sve = "⋵", lve = "⋹", uve = "⋴", cve = "⋳", fve = "∈", vve = "⁢", dve = "Ĩ", pve = "ĩ", hve = "І", mve = "і", gve = "Ï", yve = "ï", bve = "Ĵ", kve = "ĵ", wve = "Й", Cve = "й", Tve = "𝔍", Sve = "𝔧", Eve = "ȷ", xve = "𝕁", Ave = "𝕛", Mve = "𝒥", Lve = "𝒿", Ove = "Ј", Dve = "ј", Nve = "Є", Rve = "є", Ive = "Κ", Pve = "κ", Bve = "ϰ", qve = "Ķ", Fve = "ķ", _ve = "К", Hve = "к", Uve = "𝔎", zve = "𝔨", $ve = "ĸ", Vve = "Х", Wve = "х", jve = "Ќ", Gve = "ќ", Kve = "𝕂", Jve = "𝕜", Yve = "𝒦", Zve = "𝓀", Qve = "⇚", Xve = "Ĺ", ede = "ĺ", tde = "⦴", rde = "ℒ", nde = "Λ", ade = "λ", ide = "⟨", ode = "⟪", sde = "⦑", lde = "⟨", ude = "⪅", cde = "ℒ", fde = "«", vde = "⇤", dde = "⤟", pde = "←", hde = "↞", mde = "⇐", gde = "⤝", yde = "↩", bde = "↫", kde = "⤹", wde = "⥳", Cde = "↢", Tde = "⤙", Sde = "⤛", Ede = "⪫", xde = "⪭", Ade = "⪭︀", Mde = "⤌", Lde = "⤎", Ode = "❲", Dde = "{", Nde = "[", Rde = "⦋", Ide = "⦏", Pde = "⦍", Bde = "Ľ", qde = "ľ", Fde = "Ļ", _de = "ļ", Hde = "⌈", Ude = "{", zde = "Л", $de = "л", Vde = "⤶", Wde = "“", jde = "„", Gde = "⥧", Kde = "⥋", Jde = "↲", Yde = "≤", Zde = "≦", Qde = "⟨", Xde = "⇤", epe = "←", tpe = "←", rpe = "⇐", npe = "⇆", ape = "↢", ipe = "⌈", ope = "⟦", spe = "⥡", lpe = "⥙", upe = "⇃", cpe = "⌊", fpe = "↽", vpe = "↼", dpe = "⇇", ppe = "↔", hpe = "↔", mpe = "⇔", gpe = "⇆", ype = "⇋", bpe = "↭", kpe = "⥎", wpe = "↤", Cpe = "⊣", Tpe = "⥚", Spe = "⋋", Epe = "⧏", xpe = "⊲", Ape = "⊴", Mpe = "⥑", Lpe = "⥠", Ope = "⥘", Dpe = "↿", Npe = "⥒", Rpe = "↼", Ipe = "⪋", Ppe = "⋚", Bpe = "≤", qpe = "≦", Fpe = "⩽", _pe = "⪨", Hpe = "⩽", Upe = "⩿", zpe = "⪁", $pe = "⪃", Vpe = "⋚︀", Wpe = "⪓", jpe = "⪅", Gpe = "⋖", Kpe = "⋚", Jpe = "⪋", Ype = "⋚", Zpe = "≦", Qpe = "≶", Xpe = "≶", ehe = "⪡", the = "≲", rhe = "⩽", nhe = "≲", ahe = "⥼", ihe = "⌊", ohe = "𝔏", she = "𝔩", lhe = "≶", uhe = "⪑", che = "⥢", fhe = "↽", vhe = "↼", dhe = "⥪", phe = "▄", hhe = "Љ", mhe = "љ", ghe = "⇇", yhe = "≪", bhe = "⋘", khe = "⌞", whe = "⇚", Che = "⥫", The = "◺", She = "Ŀ", Ehe = "ŀ", xhe = "⎰", Ahe = "⎰", Mhe = "⪉", Lhe = "⪉", Ohe = "⪇", Dhe = "≨", Nhe = "⪇", Rhe = "≨", Ihe = "⋦", Phe = "⟬", Bhe = "⇽", qhe = "⟦", Fhe = "⟵", _he = "⟵", Hhe = "⟸", Uhe = "⟷", zhe = "⟷", $he = "⟺", Vhe = "⟼", Whe = "⟶", jhe = "⟶", Ghe = "⟹", Khe = "↫", Jhe = "↬", Yhe = "⦅", Zhe = "𝕃", Qhe = "𝕝", Xhe = "⨭", eme = "⨴", tme = "∗", rme = "_", nme = "↙", ame = "↘", ime = "◊", ome = "◊", sme = "⧫", lme = "(", ume = "⦓", cme = "⇆", fme = "⌟", vme = "⇋", dme = "⥭", pme = "‎", hme = "⊿", mme = "‹", gme = "𝓁", yme = "ℒ", bme = "↰", kme = "↰", wme = "≲", Cme = "⪍", Tme = "⪏", Sme = "[", Eme = "‘", xme = "‚", Ame = "Ł", Mme = "ł", Lme = "⪦", Ome = "⩹", Dme = "<", Nme = "<", Rme = "≪", Ime = "⋖", Pme = "⋋", Bme = "⋉", qme = "⥶", Fme = "⩻", _me = "◃", Hme = "⊴", Ume = "◂", zme = "⦖", $me = "⥊", Vme = "⥦", Wme = "≨︀", jme = "≨︀", Gme = "¯", Kme = "♂", Jme = "✠", Yme = "✠", Zme = "↦", Qme = "↦", Xme = "↧", ege = "↤", tge = "↥", rge = "▮", nge = "⨩", age = "М", ige = "м", oge = "—", sge = "∺", lge = "∡", uge = " ", cge = "ℳ", fge = "𝔐", vge = "𝔪", dge = "℧", pge = "µ", hge = "*", mge = "⫰", gge = "∣", yge = "·", bge = "⊟", kge = "−", wge = "∸", Cge = "⨪", Tge = "∓", Sge = "⫛", Ege = "…", xge = "∓", Age = "⊧", Mge = "𝕄", Lge = "𝕞", Oge = "∓", Dge = "𝓂", Nge = "ℳ", Rge = "∾", Ige = "Μ", Pge = "μ", Bge = "⊸", qge = "⊸", Fge = "∇", _ge = "Ń", Hge = "ń", Uge = "∠⃒", zge = "≉", $ge = "⩰̸", Vge = "≋̸", Wge = "ŉ", jge = "≉", Gge = "♮", Kge = "ℕ", Jge = "♮", Yge = " ", Zge = "≎̸", Qge = "≏̸", Xge = "⩃", eye = "Ň", tye = "ň", rye = "Ņ", nye = "ņ", aye = "≇", iye = "⩭̸", oye = "⩂", sye = "Н", lye = "н", uye = "–", cye = "⤤", fye = "↗", vye = "⇗", dye = "↗", pye = "≠", hye = "≐̸", mye = "​", gye = "​", yye = "​", bye = "​", kye = "≢", wye = "⤨", Cye = "≂̸", Tye = "≫", Sye = "≪", Eye = `
`, xye = "∄", Aye = "∄", Mye = "𝔑", Lye = "𝔫", Oye = "≧̸", Dye = "≱", Nye = "≱", Rye = "≧̸", Iye = "⩾̸", Pye = "⩾̸", Bye = "⋙̸", qye = "≵", Fye = "≫⃒", _ye = "≯", Hye = "≯", Uye = "≫̸", zye = "↮", $ye = "⇎", Vye = "⫲", Wye = "∋", jye = "⋼", Gye = "⋺", Kye = "∋", Jye = "Њ", Yye = "њ", Zye = "↚", Qye = "⇍", Xye = "‥", ebe = "≦̸", tbe = "≰", rbe = "↚", nbe = "⇍", abe = "↮", ibe = "⇎", obe = "≰", sbe = "≦̸", lbe = "⩽̸", ube = "⩽̸", cbe = "≮", fbe = "⋘̸", vbe = "≴", dbe = "≪⃒", pbe = "≮", hbe = "⋪", mbe = "⋬", gbe = "≪̸", ybe = "∤", bbe = "⁠", kbe = " ", wbe = "𝕟", Cbe = "ℕ", Tbe = "⫬", Sbe = "¬", Ebe = "≢", xbe = "≭", Abe = "∦", Mbe = "∉", Lbe = "≠", Obe = "≂̸", Dbe = "∄", Nbe = "≯", Rbe = "≱", Ibe = "≧̸", Pbe = "≫̸", Bbe = "≹", qbe = "⩾̸", Fbe = "≵", _be = "≎̸", Hbe = "≏̸", Ube = "∉", zbe = "⋵̸", $be = "⋹̸", Vbe = "∉", Wbe = "⋷", jbe = "⋶", Gbe = "⧏̸", Kbe = "⋪", Jbe = "⋬", Ybe = "≮", Zbe = "≰", Qbe = "≸", Xbe = "≪̸", eke = "⩽̸", tke = "≴", rke = "⪢̸", nke = "⪡̸", ake = "∌", ike = "∌", oke = "⋾", ske = "⋽", lke = "⊀", uke = "⪯̸", cke = "⋠", fke = "∌", vke = "⧐̸", dke = "⋫", pke = "⋭", hke = "⊏̸", mke = "⋢", gke = "⊐̸", yke = "⋣", bke = "⊂⃒", kke = "⊈", wke = "⊁", Cke = "⪰̸", Tke = "⋡", Ske = "≿̸", Eke = "⊃⃒", xke = "⊉", Ake = "≁", Mke = "≄", Lke = "≇", Oke = "≉", Dke = "∤", Nke = "∦", Rke = "∦", Ike = "⫽⃥", Pke = "∂̸", Bke = "⨔", qke = "⊀", Fke = "⋠", _ke = "⊀", Hke = "⪯̸", Uke = "⪯̸", zke = "⤳̸", $ke = "↛", Vke = "⇏", Wke = "↝̸", jke = "↛", Gke = "⇏", Kke = "⋫", Jke = "⋭", Yke = "⊁", Zke = "⋡", Qke = "⪰̸", Xke = "𝒩", ewe = "𝓃", twe = "∤", rwe = "∦", nwe = "≁", awe = "≄", iwe = "≄", owe = "∤", swe = "∦", lwe = "⋢", uwe = "⋣", cwe = "⊄", fwe = "⫅̸", vwe = "⊈", dwe = "⊂⃒", pwe = "⊈", hwe = "⫅̸", mwe = "⊁", gwe = "⪰̸", ywe = "⊅", bwe = "⫆̸", kwe = "⊉", wwe = "⊃⃒", Cwe = "⊉", Twe = "⫆̸", Swe = "≹", Ewe = "Ñ", xwe = "ñ", Awe = "≸", Mwe = "⋪", Lwe = "⋬", Owe = "⋫", Dwe = "⋭", Nwe = "Ν", Rwe = "ν", Iwe = "#", Pwe = "№", Bwe = " ", qwe = "≍⃒", Fwe = "⊬", _we = "⊭", Hwe = "⊮", Uwe = "⊯", zwe = "≥⃒", $we = ">⃒", Vwe = "⤄", Wwe = "⧞", jwe = "⤂", Gwe = "≤⃒", Kwe = "<⃒", Jwe = "⊴⃒", Ywe = "⤃", Zwe = "⊵⃒", Qwe = "∼⃒", Xwe = "⤣", eCe = "↖", tCe = "⇖", rCe = "↖", nCe = "⤧", aCe = "Ó", iCe = "ó", oCe = "⊛", sCe = "Ô", lCe = "ô", uCe = "⊚", cCe = "О", fCe = "о", vCe = "⊝", dCe = "Ő", pCe = "ő", hCe = "⨸", mCe = "⊙", gCe = "⦼", yCe = "Œ", bCe = "œ", kCe = "⦿", wCe = "𝔒", CCe = "𝔬", TCe = "˛", SCe = "Ò", ECe = "ò", xCe = "⧁", ACe = "⦵", MCe = "Ω", LCe = "∮", OCe = "↺", DCe = "⦾", NCe = "⦻", RCe = "‾", ICe = "⧀", PCe = "Ō", BCe = "ō", qCe = "Ω", FCe = "ω", _Ce = "Ο", HCe = "ο", UCe = "⦶", zCe = "⊖", $Ce = "𝕆", VCe = "𝕠", WCe = "⦷", jCe = "“", GCe = "‘", KCe = "⦹", JCe = "⊕", YCe = "↻", ZCe = "⩔", QCe = "∨", XCe = "⩝", eTe = "ℴ", tTe = "ℴ", rTe = "ª", nTe = "º", aTe = "⊶", iTe = "⩖", oTe = "⩗", sTe = "⩛", lTe = "Ⓢ", uTe = "𝒪", cTe = "ℴ", fTe = "Ø", vTe = "ø", dTe = "⊘", pTe = "Õ", hTe = "õ", mTe = "⨶", gTe = "⨷", yTe = "⊗", bTe = "Ö", kTe = "ö", wTe = "⌽", CTe = "‾", TTe = "⏞", STe = "⎴", ETe = "⏜", xTe = "¶", ATe = "∥", MTe = "∥", LTe = "⫳", OTe = "⫽", DTe = "∂", NTe = "∂", RTe = "П", ITe = "п", PTe = "%", BTe = ".", qTe = "‰", FTe = "⊥", _Te = "‱", HTe = "𝔓", UTe = "𝔭", zTe = "Φ", $Te = "φ", VTe = "ϕ", WTe = "ℳ", jTe = "☎", GTe = "Π", KTe = "π", JTe = "⋔", YTe = "ϖ", ZTe = "ℏ", QTe = "ℎ", XTe = "ℏ", e0e = "⨣", t0e = "⊞", r0e = "⨢", n0e = "+", a0e = "∔", i0e = "⨥", o0e = "⩲", s0e = "±", l0e = "±", u0e = "⨦", c0e = "⨧", f0e = "±", v0e = "ℌ", d0e = "⨕", p0e = "𝕡", h0e = "ℙ", m0e = "£", g0e = "⪷", y0e = "⪻", b0e = "≺", k0e = "≼", w0e = "⪷", C0e = "≺", T0e = "≼", S0e = "≺", E0e = "⪯", x0e = "≼", A0e = "≾", M0e = "⪯", L0e = "⪹", O0e = "⪵", D0e = "⋨", N0e = "⪯", R0e = "⪳", I0e = "≾", P0e = "′", B0e = "″", q0e = "ℙ", F0e = "⪹", _0e = "⪵", H0e = "⋨", U0e = "∏", z0e = "∏", $0e = "⌮", V0e = "⌒", W0e = "⌓", j0e = "∝", G0e = "∝", K0e = "∷", J0e = "∝", Y0e = "≾", Z0e = "⊰", Q0e = "𝒫", X0e = "𝓅", e1e = "Ψ", t1e = "ψ", r1e = " ", n1e = "𝔔", a1e = "𝔮", i1e = "⨌", o1e = "𝕢", s1e = "ℚ", l1e = "⁗", u1e = "𝒬", c1e = "𝓆", f1e = "ℍ", v1e = "⨖", d1e = "?", p1e = "≟", h1e = '"', m1e = '"', g1e = "⇛", y1e = "∽̱", b1e = "Ŕ", k1e = "ŕ", w1e = "√", C1e = "⦳", T1e = "⟩", S1e = "⟫", E1e = "⦒", x1e = "⦥", A1e = "⟩", M1e = "»", L1e = "⥵", O1e = "⇥", D1e = "⤠", N1e = "⤳", R1e = "→", I1e = "↠", P1e = "⇒", B1e = "⤞", q1e = "↪", F1e = "↬", _1e = "⥅", H1e = "⥴", U1e = "⤖", z1e = "↣", $1e = "↝", V1e = "⤚", W1e = "⤜", j1e = "∶", G1e = "ℚ", K1e = "⤍", J1e = "⤏", Y1e = "⤐", Z1e = "❳", Q1e = "}", X1e = "]", eSe = "⦌", tSe = "⦎", rSe = "⦐", nSe = "Ř", aSe = "ř", iSe = "Ŗ", oSe = "ŗ", sSe = "⌉", lSe = "}", uSe = "Р", cSe = "р", fSe = "⤷", vSe = "⥩", dSe = "”", pSe = "”", hSe = "↳", mSe = "ℜ", gSe = "ℛ", ySe = "ℜ", bSe = "ℝ", kSe = "ℜ", wSe = "▭", CSe = "®", TSe = "®", SSe = "∋", ESe = "⇋", xSe = "⥯", ASe = "⥽", MSe = "⌋", LSe = "𝔯", OSe = "ℜ", DSe = "⥤", NSe = "⇁", RSe = "⇀", ISe = "⥬", PSe = "Ρ", BSe = "ρ", qSe = "ϱ", FSe = "⟩", _Se = "⇥", HSe = "→", USe = "→", zSe = "⇒", $Se = "⇄", VSe = "↣", WSe = "⌉", jSe = "⟧", GSe = "⥝", KSe = "⥕", JSe = "⇂", YSe = "⌋", ZSe = "⇁", QSe = "⇀", XSe = "⇄", eEe = "⇌", tEe = "⇉", rEe = "↝", nEe = "↦", aEe = "⊢", iEe = "⥛", oEe = "⋌", sEe = "⧐", lEe = "⊳", uEe = "⊵", cEe = "⥏", fEe = "⥜", vEe = "⥔", dEe = "↾", pEe = "⥓", hEe = "⇀", mEe = "˚", gEe = "≓", yEe = "⇄", bEe = "⇌", kEe = "‏", wEe = "⎱", CEe = "⎱", TEe = "⫮", SEe = "⟭", EEe = "⇾", xEe = "⟧", AEe = "⦆", MEe = "𝕣", LEe = "ℝ", OEe = "⨮", DEe = "⨵", NEe = "⥰", REe = ")", IEe = "⦔", PEe = "⨒", BEe = "⇉", qEe = "⇛", FEe = "›", _Ee = "𝓇", HEe = "ℛ", UEe = "↱", zEe = "↱", $Ee = "]", VEe = "’", WEe = "’", jEe = "⋌", GEe = "⋊", KEe = "▹", JEe = "⊵", YEe = "▸", ZEe = "⧎", QEe = "⧴", XEe = "⥨", exe = "℞", txe = "Ś", rxe = "ś", nxe = "‚", axe = "⪸", ixe = "Š", oxe = "š", sxe = "⪼", lxe = "≻", uxe = "≽", cxe = "⪰", fxe = "⪴", vxe = "Ş", dxe = "ş", pxe = "Ŝ", hxe = "ŝ", mxe = "⪺", gxe = "⪶", yxe = "⋩", bxe = "⨓", kxe = "≿", wxe = "С", Cxe = "с", Txe = "⊡", Sxe = "⋅", Exe = "⩦", xxe = "⤥", Axe = "↘", Mxe = "⇘", Lxe = "↘", Oxe = "§", Dxe = ";", Nxe = "⤩", Rxe = "∖", Ixe = "∖", Pxe = "✶", Bxe = "𝔖", qxe = "𝔰", Fxe = "⌢", _xe = "♯", Hxe = "Щ", Uxe = "щ", zxe = "Ш", $xe = "ш", Vxe = "↓", Wxe = "←", jxe = "∣", Gxe = "∥", Kxe = "→", Jxe = "↑", Yxe = "­", Zxe = "Σ", Qxe = "σ", Xxe = "ς", eAe = "ς", tAe = "∼", rAe = "⩪", nAe = "≃", aAe = "≃", iAe = "⪞", oAe = "⪠", sAe = "⪝", lAe = "⪟", uAe = "≆", cAe = "⨤", fAe = "⥲", vAe = "←", dAe = "∘", pAe = "∖", hAe = "⨳", mAe = "⧤", gAe = "∣", yAe = "⌣", bAe = "⪪", kAe = "⪬", wAe = "⪬︀", CAe = "Ь", TAe = "ь", SAe = "⌿", EAe = "⧄", xAe = "/", AAe = "𝕊", MAe = "𝕤", LAe = "♠", OAe = "♠", DAe = "∥", NAe = "⊓", RAe = "⊓︀", IAe = "⊔", PAe = "⊔︀", BAe = "√", qAe = "⊏", FAe = "⊑", _Ae = "⊏", HAe = "⊑", UAe = "⊐", zAe = "⊒", $Ae = "⊐", VAe = "⊒", WAe = "□", jAe = "□", GAe = "⊓", KAe = "⊏", JAe = "⊑", YAe = "⊐", ZAe = "⊒", QAe = "⊔", XAe = "▪", eMe = "□", tMe = "▪", rMe = "→", nMe = "𝒮", aMe = "𝓈", iMe = "∖", oMe = "⌣", sMe = "⋆", lMe = "⋆", uMe = "☆", cMe = "★", fMe = "ϵ", vMe = "ϕ", dMe = "¯", pMe = "⊂", hMe = "⋐", mMe = "⪽", gMe = "⫅", yMe = "⊆", bMe = "⫃", kMe = "⫁", wMe = "⫋", CMe = "⊊", TMe = "⪿", SMe = "⥹", EMe = "⊂", xMe = "⋐", AMe = "⊆", MMe = "⫅", LMe = "⊆", OMe = "⊊", DMe = "⫋", NMe = "⫇", RMe = "⫕", IMe = "⫓", PMe = "⪸", BMe = "≻", qMe = "≽", FMe = "≻", _Me = "⪰", HMe = "≽", UMe = "≿", zMe = "⪰", $Me = "⪺", VMe = "⪶", WMe = "⋩", jMe = "≿", GMe = "∋", KMe = "∑", JMe = "∑", YMe = "♪", ZMe = "¹", QMe = "²", XMe = "³", eLe = "⊃", tLe = "⋑", rLe = "⪾", nLe = "⫘", aLe = "⫆", iLe = "⊇", oLe = "⫄", sLe = "⊃", lLe = "⊇", uLe = "⟉", cLe = "⫗", fLe = "⥻", vLe = "⫂", dLe = "⫌", pLe = "⊋", hLe = "⫀", mLe = "⊃", gLe = "⋑", yLe = "⊇", bLe = "⫆", kLe = "⊋", wLe = "⫌", CLe = "⫈", TLe = "⫔", SLe = "⫖", ELe = "⤦", xLe = "↙", ALe = "⇙", MLe = "↙", LLe = "⤪", OLe = "ß", DLe = "	", NLe = "⌖", RLe = "Τ", ILe = "τ", PLe = "⎴", BLe = "Ť", qLe = "ť", FLe = "Ţ", _Le = "ţ", HLe = "Т", ULe = "т", zLe = "⃛", $Le = "⌕", VLe = "𝔗", WLe = "𝔱", jLe = "∴", GLe = "∴", KLe = "∴", JLe = "Θ", YLe = "θ", ZLe = "ϑ", QLe = "ϑ", XLe = "≈", eOe = "∼", tOe = "  ", rOe = " ", nOe = " ", aOe = "≈", iOe = "∼", oOe = "Þ", sOe = "þ", lOe = "˜", uOe = "∼", cOe = "≃", fOe = "≅", vOe = "≈", dOe = "⨱", pOe = "⊠", hOe = "×", mOe = "⨰", gOe = "∭", yOe = "⤨", bOe = "⌶", kOe = "⫱", wOe = "⊤", COe = "𝕋", TOe = "𝕥", SOe = "⫚", EOe = "⤩", xOe = "‴", AOe = "™", MOe = "™", LOe = "▵", OOe = "▿", DOe = "◃", NOe = "⊴", ROe = "≜", IOe = "▹", POe = "⊵", BOe = "◬", qOe = "≜", FOe = "⨺", _Oe = "⃛", HOe = "⨹", UOe = "⧍", zOe = "⨻", $Oe = "⏢", VOe = "𝒯", WOe = "𝓉", jOe = "Ц", GOe = "ц", KOe = "Ћ", JOe = "ћ", YOe = "Ŧ", ZOe = "ŧ", QOe = "≬", XOe = "↞", eDe = "↠", tDe = "Ú", rDe = "ú", nDe = "↑", aDe = "↟", iDe = "⇑", oDe = "⥉", sDe = "Ў", lDe = "ў", uDe = "Ŭ", cDe = "ŭ", fDe = "Û", vDe = "û", dDe = "У", pDe = "у", hDe = "⇅", mDe = "Ű", gDe = "ű", yDe = "⥮", bDe = "⥾", kDe = "𝔘", wDe = "𝔲", CDe = "Ù", TDe = "ù", SDe = "⥣", EDe = "↿", xDe = "↾", ADe = "▀", MDe = "⌜", LDe = "⌜", ODe = "⌏", DDe = "◸", NDe = "Ū", RDe = "ū", IDe = "¨", PDe = "_", BDe = "⏟", qDe = "⎵", FDe = "⏝", _De = "⋃", HDe = "⊎", UDe = "Ų", zDe = "ų", $De = "𝕌", VDe = "𝕦", WDe = "⤒", jDe = "↑", GDe = "↑", KDe = "⇑", JDe = "⇅", YDe = "↕", ZDe = "↕", QDe = "⇕", XDe = "⥮", eNe = "↿", tNe = "↾", rNe = "⊎", nNe = "↖", aNe = "↗", iNe = "υ", oNe = "ϒ", sNe = "ϒ", lNe = "Υ", uNe = "υ", cNe = "↥", fNe = "⊥", vNe = "⇈", dNe = "⌝", pNe = "⌝", hNe = "⌎", mNe = "Ů", gNe = "ů", yNe = "◹", bNe = "𝒰", kNe = "𝓊", wNe = "⋰", CNe = "Ũ", TNe = "ũ", SNe = "▵", ENe = "▴", xNe = "⇈", ANe = "Ü", MNe = "ü", LNe = "⦧", ONe = "⦜", DNe = "ϵ", NNe = "ϰ", RNe = "∅", INe = "ϕ", PNe = "ϖ", BNe = "∝", qNe = "↕", FNe = "⇕", _Ne = "ϱ", HNe = "ς", UNe = "⊊︀", zNe = "⫋︀", $Ne = "⊋︀", VNe = "⫌︀", WNe = "ϑ", jNe = "⊲", GNe = "⊳", KNe = "⫨", JNe = "⫫", YNe = "⫩", ZNe = "В", QNe = "в", XNe = "⊢", eRe = "⊨", tRe = "⊩", rRe = "⊫", nRe = "⫦", aRe = "⊻", iRe = "∨", oRe = "⋁", sRe = "≚", lRe = "⋮", uRe = "|", cRe = "‖", fRe = "|", vRe = "‖", dRe = "∣", pRe = "|", hRe = "❘", mRe = "≀", gRe = " ", yRe = "𝔙", bRe = "𝔳", kRe = "⊲", wRe = "⊂⃒", CRe = "⊃⃒", TRe = "𝕍", SRe = "𝕧", ERe = "∝", xRe = "⊳", ARe = "𝒱", MRe = "𝓋", LRe = "⫋︀", ORe = "⊊︀", DRe = "⫌︀", NRe = "⊋︀", RRe = "⊪", IRe = "⦚", PRe = "Ŵ", BRe = "ŵ", qRe = "⩟", FRe = "∧", _Re = "⋀", HRe = "≙", URe = "℘", zRe = "𝔚", $Re = "𝔴", VRe = "𝕎", WRe = "𝕨", jRe = "℘", GRe = "≀", KRe = "≀", JRe = "𝒲", YRe = "𝓌", ZRe = "⋂", QRe = "◯", XRe = "⋃", eIe = "▽", tIe = "𝔛", rIe = "𝔵", nIe = "⟷", aIe = "⟺", iIe = "Ξ", oIe = "ξ", sIe = "⟵", lIe = "⟸", uIe = "⟼", cIe = "⋻", fIe = "⨀", vIe = "𝕏", dIe = "𝕩", pIe = "⨁", hIe = "⨂", mIe = "⟶", gIe = "⟹", yIe = "𝒳", bIe = "𝓍", kIe = "⨆", wIe = "⨄", CIe = "△", TIe = "⋁", SIe = "⋀", EIe = "Ý", xIe = "ý", AIe = "Я", MIe = "я", LIe = "Ŷ", OIe = "ŷ", DIe = "Ы", NIe = "ы", RIe = "¥", IIe = "𝔜", PIe = "𝔶", BIe = "Ї", qIe = "ї", FIe = "𝕐", _Ie = "𝕪", HIe = "𝒴", UIe = "𝓎", zIe = "Ю", $Ie = "ю", VIe = "ÿ", WIe = "Ÿ", jIe = "Ź", GIe = "ź", KIe = "Ž", JIe = "ž", YIe = "З", ZIe = "з", QIe = "Ż", XIe = "ż", ePe = "ℨ", tPe = "​", rPe = "Ζ", nPe = "ζ", aPe = "𝔷", iPe = "ℨ", oPe = "Ж", sPe = "ж", lPe = "⇝", uPe = "𝕫", cPe = "ℤ", fPe = "𝒵", vPe = "𝓏", dPe = "‍", pPe = "‌", Hh = {
  Aacute: QZ,
  aacute: XZ,
  Abreve: eQ,
  abreve: tQ,
  ac: rQ,
  acd: nQ,
  acE: aQ,
  Acirc: iQ,
  acirc: oQ,
  acute: sQ,
  Acy: lQ,
  acy: uQ,
  AElig: cQ,
  aelig: fQ,
  af: vQ,
  Afr: dQ,
  afr: pQ,
  Agrave: hQ,
  agrave: mQ,
  alefsym: gQ,
  aleph: yQ,
  Alpha: bQ,
  alpha: kQ,
  Amacr: wQ,
  amacr: CQ,
  amalg: TQ,
  amp: SQ,
  AMP: EQ,
  andand: xQ,
  And: AQ,
  and: MQ,
  andd: LQ,
  andslope: OQ,
  andv: DQ,
  ang: NQ,
  ange: RQ,
  angle: IQ,
  angmsdaa: PQ,
  angmsdab: BQ,
  angmsdac: qQ,
  angmsdad: FQ,
  angmsdae: _Q,
  angmsdaf: HQ,
  angmsdag: UQ,
  angmsdah: zQ,
  angmsd: $Q,
  angrt: VQ,
  angrtvb: WQ,
  angrtvbd: jQ,
  angsph: GQ,
  angst: KQ,
  angzarr: JQ,
  Aogon: YQ,
  aogon: ZQ,
  Aopf: QQ,
  aopf: XQ,
  apacir: eX,
  ap: tX,
  apE: rX,
  ape: nX,
  apid: aX,
  apos: iX,
  ApplyFunction: oX,
  approx: sX,
  approxeq: lX,
  Aring: uX,
  aring: cX,
  Ascr: fX,
  ascr: vX,
  Assign: dX,
  ast: pX,
  asymp: hX,
  asympeq: mX,
  Atilde: gX,
  atilde: yX,
  Auml: bX,
  auml: kX,
  awconint: wX,
  awint: CX,
  backcong: TX,
  backepsilon: SX,
  backprime: EX,
  backsim: xX,
  backsimeq: AX,
  Backslash: MX,
  Barv: LX,
  barvee: OX,
  barwed: DX,
  Barwed: NX,
  barwedge: RX,
  bbrk: IX,
  bbrktbrk: PX,
  bcong: BX,
  Bcy: qX,
  bcy: FX,
  bdquo: _X,
  becaus: HX,
  because: UX,
  Because: zX,
  bemptyv: $X,
  bepsi: VX,
  bernou: WX,
  Bernoullis: jX,
  Beta: GX,
  beta: KX,
  beth: JX,
  between: YX,
  Bfr: ZX,
  bfr: QX,
  bigcap: XX,
  bigcirc: eee,
  bigcup: tee,
  bigodot: ree,
  bigoplus: nee,
  bigotimes: aee,
  bigsqcup: iee,
  bigstar: oee,
  bigtriangledown: see,
  bigtriangleup: lee,
  biguplus: uee,
  bigvee: cee,
  bigwedge: fee,
  bkarow: vee,
  blacklozenge: dee,
  blacksquare: pee,
  blacktriangle: hee,
  blacktriangledown: mee,
  blacktriangleleft: gee,
  blacktriangleright: yee,
  blank: bee,
  blk12: kee,
  blk14: wee,
  blk34: Cee,
  block: Tee,
  bne: See,
  bnequiv: Eee,
  bNot: xee,
  bnot: Aee,
  Bopf: Mee,
  bopf: Lee,
  bot: Oee,
  bottom: Dee,
  bowtie: Nee,
  boxbox: Ree,
  boxdl: Iee,
  boxdL: Pee,
  boxDl: Bee,
  boxDL: qee,
  boxdr: Fee,
  boxdR: _ee,
  boxDr: Hee,
  boxDR: Uee,
  boxh: zee,
  boxH: $ee,
  boxhd: Vee,
  boxHd: Wee,
  boxhD: jee,
  boxHD: Gee,
  boxhu: Kee,
  boxHu: Jee,
  boxhU: Yee,
  boxHU: Zee,
  boxminus: Qee,
  boxplus: Xee,
  boxtimes: ete,
  boxul: tte,
  boxuL: rte,
  boxUl: nte,
  boxUL: ate,
  boxur: ite,
  boxuR: ote,
  boxUr: ste,
  boxUR: lte,
  boxv: ute,
  boxV: cte,
  boxvh: fte,
  boxvH: vte,
  boxVh: dte,
  boxVH: pte,
  boxvl: hte,
  boxvL: mte,
  boxVl: gte,
  boxVL: yte,
  boxvr: bte,
  boxvR: kte,
  boxVr: wte,
  boxVR: Cte,
  bprime: Tte,
  breve: Ste,
  Breve: Ete,
  brvbar: xte,
  bscr: Ate,
  Bscr: Mte,
  bsemi: Lte,
  bsim: Ote,
  bsime: Dte,
  bsolb: Nte,
  bsol: Rte,
  bsolhsub: Ite,
  bull: Pte,
  bullet: Bte,
  bump: qte,
  bumpE: Fte,
  bumpe: _te,
  Bumpeq: Hte,
  bumpeq: Ute,
  Cacute: zte,
  cacute: $te,
  capand: Vte,
  capbrcup: Wte,
  capcap: jte,
  cap: Gte,
  Cap: Kte,
  capcup: Jte,
  capdot: Yte,
  CapitalDifferentialD: Zte,
  caps: Qte,
  caret: Xte,
  caron: ere,
  Cayleys: tre,
  ccaps: rre,
  Ccaron: nre,
  ccaron: are,
  Ccedil: ire,
  ccedil: ore,
  Ccirc: sre,
  ccirc: lre,
  Cconint: ure,
  ccups: cre,
  ccupssm: fre,
  Cdot: vre,
  cdot: dre,
  cedil: pre,
  Cedilla: hre,
  cemptyv: mre,
  cent: gre,
  centerdot: yre,
  CenterDot: bre,
  cfr: kre,
  Cfr: wre,
  CHcy: Cre,
  chcy: Tre,
  check: Sre,
  checkmark: Ere,
  Chi: xre,
  chi: Are,
  circ: Mre,
  circeq: Lre,
  circlearrowleft: Ore,
  circlearrowright: Dre,
  circledast: Nre,
  circledcirc: Rre,
  circleddash: Ire,
  CircleDot: Pre,
  circledR: Bre,
  circledS: qre,
  CircleMinus: Fre,
  CirclePlus: _re,
  CircleTimes: Hre,
  cir: Ure,
  cirE: zre,
  cire: $re,
  cirfnint: Vre,
  cirmid: Wre,
  cirscir: jre,
  ClockwiseContourIntegral: Gre,
  CloseCurlyDoubleQuote: Kre,
  CloseCurlyQuote: Jre,
  clubs: Yre,
  clubsuit: Zre,
  colon: Qre,
  Colon: Xre,
  Colone: ene,
  colone: tne,
  coloneq: rne,
  comma: nne,
  commat: ane,
  comp: ine,
  compfn: one,
  complement: sne,
  complexes: lne,
  cong: une,
  congdot: cne,
  Congruent: fne,
  conint: vne,
  Conint: dne,
  ContourIntegral: pne,
  copf: hne,
  Copf: mne,
  coprod: gne,
  Coproduct: yne,
  copy: bne,
  COPY: kne,
  copysr: wne,
  CounterClockwiseContourIntegral: Cne,
  crarr: Tne,
  cross: Sne,
  Cross: Ene,
  Cscr: xne,
  cscr: Ane,
  csub: Mne,
  csube: Lne,
  csup: One,
  csupe: Dne,
  ctdot: Nne,
  cudarrl: Rne,
  cudarrr: Ine,
  cuepr: Pne,
  cuesc: Bne,
  cularr: qne,
  cularrp: Fne,
  cupbrcap: _ne,
  cupcap: Hne,
  CupCap: Une,
  cup: zne,
  Cup: $ne,
  cupcup: Vne,
  cupdot: Wne,
  cupor: jne,
  cups: Gne,
  curarr: Kne,
  curarrm: Jne,
  curlyeqprec: Yne,
  curlyeqsucc: Zne,
  curlyvee: Qne,
  curlywedge: Xne,
  curren: eae,
  curvearrowleft: tae,
  curvearrowright: rae,
  cuvee: nae,
  cuwed: aae,
  cwconint: iae,
  cwint: oae,
  cylcty: sae,
  dagger: lae,
  Dagger: uae,
  daleth: cae,
  darr: fae,
  Darr: vae,
  dArr: dae,
  dash: pae,
  Dashv: hae,
  dashv: mae,
  dbkarow: gae,
  dblac: yae,
  Dcaron: bae,
  dcaron: kae,
  Dcy: wae,
  dcy: Cae,
  ddagger: Tae,
  ddarr: Sae,
  DD: Eae,
  dd: xae,
  DDotrahd: Aae,
  ddotseq: Mae,
  deg: Lae,
  Del: Oae,
  Delta: Dae,
  delta: Nae,
  demptyv: Rae,
  dfisht: Iae,
  Dfr: Pae,
  dfr: Bae,
  dHar: qae,
  dharl: Fae,
  dharr: _ae,
  DiacriticalAcute: Hae,
  DiacriticalDot: Uae,
  DiacriticalDoubleAcute: zae,
  DiacriticalGrave: $ae,
  DiacriticalTilde: Vae,
  diam: Wae,
  diamond: jae,
  Diamond: Gae,
  diamondsuit: Kae,
  diams: Jae,
  die: Yae,
  DifferentialD: Zae,
  digamma: Qae,
  disin: Xae,
  div: eie,
  divide: tie,
  divideontimes: rie,
  divonx: nie,
  DJcy: aie,
  djcy: iie,
  dlcorn: oie,
  dlcrop: sie,
  dollar: lie,
  Dopf: uie,
  dopf: cie,
  Dot: fie,
  dot: vie,
  DotDot: die,
  doteq: pie,
  doteqdot: hie,
  DotEqual: mie,
  dotminus: gie,
  dotplus: yie,
  dotsquare: bie,
  doublebarwedge: kie,
  DoubleContourIntegral: wie,
  DoubleDot: Cie,
  DoubleDownArrow: Tie,
  DoubleLeftArrow: Sie,
  DoubleLeftRightArrow: Eie,
  DoubleLeftTee: xie,
  DoubleLongLeftArrow: Aie,
  DoubleLongLeftRightArrow: Mie,
  DoubleLongRightArrow: Lie,
  DoubleRightArrow: Oie,
  DoubleRightTee: Die,
  DoubleUpArrow: Nie,
  DoubleUpDownArrow: Rie,
  DoubleVerticalBar: Iie,
  DownArrowBar: Pie,
  downarrow: Bie,
  DownArrow: qie,
  Downarrow: Fie,
  DownArrowUpArrow: _ie,
  DownBreve: Hie,
  downdownarrows: Uie,
  downharpoonleft: zie,
  downharpoonright: $ie,
  DownLeftRightVector: Vie,
  DownLeftTeeVector: Wie,
  DownLeftVectorBar: jie,
  DownLeftVector: Gie,
  DownRightTeeVector: Kie,
  DownRightVectorBar: Jie,
  DownRightVector: Yie,
  DownTeeArrow: Zie,
  DownTee: Qie,
  drbkarow: Xie,
  drcorn: eoe,
  drcrop: toe,
  Dscr: roe,
  dscr: noe,
  DScy: aoe,
  dscy: ioe,
  dsol: ooe,
  Dstrok: soe,
  dstrok: loe,
  dtdot: uoe,
  dtri: coe,
  dtrif: foe,
  duarr: voe,
  duhar: doe,
  dwangle: poe,
  DZcy: hoe,
  dzcy: moe,
  dzigrarr: goe,
  Eacute: yoe,
  eacute: boe,
  easter: koe,
  Ecaron: woe,
  ecaron: Coe,
  Ecirc: Toe,
  ecirc: Soe,
  ecir: Eoe,
  ecolon: xoe,
  Ecy: Aoe,
  ecy: Moe,
  eDDot: Loe,
  Edot: Ooe,
  edot: Doe,
  eDot: Noe,
  ee: Roe,
  efDot: Ioe,
  Efr: Poe,
  efr: Boe,
  eg: qoe,
  Egrave: Foe,
  egrave: _oe,
  egs: Hoe,
  egsdot: Uoe,
  el: zoe,
  Element: $oe,
  elinters: Voe,
  ell: Woe,
  els: joe,
  elsdot: Goe,
  Emacr: Koe,
  emacr: Joe,
  empty: Yoe,
  emptyset: Zoe,
  EmptySmallSquare: Qoe,
  emptyv: Xoe,
  EmptyVerySmallSquare: ese,
  emsp13: tse,
  emsp14: rse,
  emsp: nse,
  ENG: ase,
  eng: ise,
  ensp: ose,
  Eogon: sse,
  eogon: lse,
  Eopf: use,
  eopf: cse,
  epar: fse,
  eparsl: vse,
  eplus: dse,
  epsi: pse,
  Epsilon: hse,
  epsilon: mse,
  epsiv: gse,
  eqcirc: yse,
  eqcolon: bse,
  eqsim: kse,
  eqslantgtr: wse,
  eqslantless: Cse,
  Equal: Tse,
  equals: Sse,
  EqualTilde: Ese,
  equest: xse,
  Equilibrium: Ase,
  equiv: Mse,
  equivDD: Lse,
  eqvparsl: Ose,
  erarr: Dse,
  erDot: Nse,
  escr: Rse,
  Escr: Ise,
  esdot: Pse,
  Esim: Bse,
  esim: qse,
  Eta: Fse,
  eta: _se,
  ETH: Hse,
  eth: Use,
  Euml: zse,
  euml: $se,
  euro: Vse,
  excl: Wse,
  exist: jse,
  Exists: Gse,
  expectation: Kse,
  exponentiale: Jse,
  ExponentialE: Yse,
  fallingdotseq: Zse,
  Fcy: Qse,
  fcy: Xse,
  female: ele,
  ffilig: tle,
  fflig: rle,
  ffllig: nle,
  Ffr: ale,
  ffr: ile,
  filig: ole,
  FilledSmallSquare: sle,
  FilledVerySmallSquare: lle,
  fjlig: ule,
  flat: cle,
  fllig: fle,
  fltns: vle,
  fnof: dle,
  Fopf: ple,
  fopf: hle,
  forall: mle,
  ForAll: gle,
  fork: yle,
  forkv: ble,
  Fouriertrf: kle,
  fpartint: wle,
  frac12: Cle,
  frac13: Tle,
  frac14: Sle,
  frac15: Ele,
  frac16: xle,
  frac18: Ale,
  frac23: Mle,
  frac25: Lle,
  frac34: Ole,
  frac35: Dle,
  frac38: Nle,
  frac45: Rle,
  frac56: Ile,
  frac58: Ple,
  frac78: Ble,
  frasl: qle,
  frown: Fle,
  fscr: _le,
  Fscr: Hle,
  gacute: Ule,
  Gamma: zle,
  gamma: $le,
  Gammad: Vle,
  gammad: Wle,
  gap: jle,
  Gbreve: Gle,
  gbreve: Kle,
  Gcedil: Jle,
  Gcirc: Yle,
  gcirc: Zle,
  Gcy: Qle,
  gcy: Xle,
  Gdot: eue,
  gdot: tue,
  ge: rue,
  gE: nue,
  gEl: aue,
  gel: iue,
  geq: oue,
  geqq: sue,
  geqslant: lue,
  gescc: uue,
  ges: cue,
  gesdot: fue,
  gesdoto: vue,
  gesdotol: due,
  gesl: pue,
  gesles: hue,
  Gfr: mue,
  gfr: gue,
  gg: yue,
  Gg: bue,
  ggg: kue,
  gimel: wue,
  GJcy: Cue,
  gjcy: Tue,
  gla: Sue,
  gl: Eue,
  glE: xue,
  glj: Aue,
  gnap: Mue,
  gnapprox: Lue,
  gne: Oue,
  gnE: Due,
  gneq: Nue,
  gneqq: Rue,
  gnsim: Iue,
  Gopf: Pue,
  gopf: Bue,
  grave: que,
  GreaterEqual: Fue,
  GreaterEqualLess: _ue,
  GreaterFullEqual: Hue,
  GreaterGreater: Uue,
  GreaterLess: zue,
  GreaterSlantEqual: $ue,
  GreaterTilde: Vue,
  Gscr: Wue,
  gscr: jue,
  gsim: Gue,
  gsime: Kue,
  gsiml: Jue,
  gtcc: Yue,
  gtcir: Zue,
  gt: Que,
  GT: Xue,
  Gt: ece,
  gtdot: tce,
  gtlPar: rce,
  gtquest: nce,
  gtrapprox: ace,
  gtrarr: ice,
  gtrdot: oce,
  gtreqless: sce,
  gtreqqless: lce,
  gtrless: uce,
  gtrsim: cce,
  gvertneqq: fce,
  gvnE: vce,
  Hacek: dce,
  hairsp: pce,
  half: hce,
  hamilt: mce,
  HARDcy: gce,
  hardcy: yce,
  harrcir: bce,
  harr: kce,
  hArr: wce,
  harrw: Cce,
  Hat: Tce,
  hbar: Sce,
  Hcirc: Ece,
  hcirc: xce,
  hearts: Ace,
  heartsuit: Mce,
  hellip: Lce,
  hercon: Oce,
  hfr: Dce,
  Hfr: Nce,
  HilbertSpace: Rce,
  hksearow: Ice,
  hkswarow: Pce,
  hoarr: Bce,
  homtht: qce,
  hookleftarrow: Fce,
  hookrightarrow: _ce,
  hopf: Hce,
  Hopf: Uce,
  horbar: zce,
  HorizontalLine: $ce,
  hscr: Vce,
  Hscr: Wce,
  hslash: jce,
  Hstrok: Gce,
  hstrok: Kce,
  HumpDownHump: Jce,
  HumpEqual: Yce,
  hybull: Zce,
  hyphen: Qce,
  Iacute: Xce,
  iacute: efe,
  ic: tfe,
  Icirc: rfe,
  icirc: nfe,
  Icy: afe,
  icy: ife,
  Idot: ofe,
  IEcy: sfe,
  iecy: lfe,
  iexcl: ufe,
  iff: cfe,
  ifr: ffe,
  Ifr: vfe,
  Igrave: dfe,
  igrave: pfe,
  ii: hfe,
  iiiint: mfe,
  iiint: gfe,
  iinfin: yfe,
  iiota: bfe,
  IJlig: kfe,
  ijlig: wfe,
  Imacr: Cfe,
  imacr: Tfe,
  image: Sfe,
  ImaginaryI: Efe,
  imagline: xfe,
  imagpart: Afe,
  imath: Mfe,
  Im: Lfe,
  imof: Ofe,
  imped: Dfe,
  Implies: Nfe,
  incare: Rfe,
  in: "∈",
  infin: Ife,
  infintie: Pfe,
  inodot: Bfe,
  intcal: qfe,
  int: Ffe,
  Int: _fe,
  integers: Hfe,
  Integral: Ufe,
  intercal: zfe,
  Intersection: $fe,
  intlarhk: Vfe,
  intprod: Wfe,
  InvisibleComma: jfe,
  InvisibleTimes: Gfe,
  IOcy: Kfe,
  iocy: Jfe,
  Iogon: Yfe,
  iogon: Zfe,
  Iopf: Qfe,
  iopf: Xfe,
  Iota: eve,
  iota: tve,
  iprod: rve,
  iquest: nve,
  iscr: ave,
  Iscr: ive,
  isin: ove,
  isindot: sve,
  isinE: lve,
  isins: uve,
  isinsv: cve,
  isinv: fve,
  it: vve,
  Itilde: dve,
  itilde: pve,
  Iukcy: hve,
  iukcy: mve,
  Iuml: gve,
  iuml: yve,
  Jcirc: bve,
  jcirc: kve,
  Jcy: wve,
  jcy: Cve,
  Jfr: Tve,
  jfr: Sve,
  jmath: Eve,
  Jopf: xve,
  jopf: Ave,
  Jscr: Mve,
  jscr: Lve,
  Jsercy: Ove,
  jsercy: Dve,
  Jukcy: Nve,
  jukcy: Rve,
  Kappa: Ive,
  kappa: Pve,
  kappav: Bve,
  Kcedil: qve,
  kcedil: Fve,
  Kcy: _ve,
  kcy: Hve,
  Kfr: Uve,
  kfr: zve,
  kgreen: $ve,
  KHcy: Vve,
  khcy: Wve,
  KJcy: jve,
  kjcy: Gve,
  Kopf: Kve,
  kopf: Jve,
  Kscr: Yve,
  kscr: Zve,
  lAarr: Qve,
  Lacute: Xve,
  lacute: ede,
  laemptyv: tde,
  lagran: rde,
  Lambda: nde,
  lambda: ade,
  lang: ide,
  Lang: ode,
  langd: sde,
  langle: lde,
  lap: ude,
  Laplacetrf: cde,
  laquo: fde,
  larrb: vde,
  larrbfs: dde,
  larr: pde,
  Larr: hde,
  lArr: mde,
  larrfs: gde,
  larrhk: yde,
  larrlp: bde,
  larrpl: kde,
  larrsim: wde,
  larrtl: Cde,
  latail: Tde,
  lAtail: Sde,
  lat: Ede,
  late: xde,
  lates: Ade,
  lbarr: Mde,
  lBarr: Lde,
  lbbrk: Ode,
  lbrace: Dde,
  lbrack: Nde,
  lbrke: Rde,
  lbrksld: Ide,
  lbrkslu: Pde,
  Lcaron: Bde,
  lcaron: qde,
  Lcedil: Fde,
  lcedil: _de,
  lceil: Hde,
  lcub: Ude,
  Lcy: zde,
  lcy: $de,
  ldca: Vde,
  ldquo: Wde,
  ldquor: jde,
  ldrdhar: Gde,
  ldrushar: Kde,
  ldsh: Jde,
  le: Yde,
  lE: Zde,
  LeftAngleBracket: Qde,
  LeftArrowBar: Xde,
  leftarrow: epe,
  LeftArrow: tpe,
  Leftarrow: rpe,
  LeftArrowRightArrow: npe,
  leftarrowtail: ape,
  LeftCeiling: ipe,
  LeftDoubleBracket: ope,
  LeftDownTeeVector: spe,
  LeftDownVectorBar: lpe,
  LeftDownVector: upe,
  LeftFloor: cpe,
  leftharpoondown: fpe,
  leftharpoonup: vpe,
  leftleftarrows: dpe,
  leftrightarrow: ppe,
  LeftRightArrow: hpe,
  Leftrightarrow: mpe,
  leftrightarrows: gpe,
  leftrightharpoons: ype,
  leftrightsquigarrow: bpe,
  LeftRightVector: kpe,
  LeftTeeArrow: wpe,
  LeftTee: Cpe,
  LeftTeeVector: Tpe,
  leftthreetimes: Spe,
  LeftTriangleBar: Epe,
  LeftTriangle: xpe,
  LeftTriangleEqual: Ape,
  LeftUpDownVector: Mpe,
  LeftUpTeeVector: Lpe,
  LeftUpVectorBar: Ope,
  LeftUpVector: Dpe,
  LeftVectorBar: Npe,
  LeftVector: Rpe,
  lEg: Ipe,
  leg: Ppe,
  leq: Bpe,
  leqq: qpe,
  leqslant: Fpe,
  lescc: _pe,
  les: Hpe,
  lesdot: Upe,
  lesdoto: zpe,
  lesdotor: $pe,
  lesg: Vpe,
  lesges: Wpe,
  lessapprox: jpe,
  lessdot: Gpe,
  lesseqgtr: Kpe,
  lesseqqgtr: Jpe,
  LessEqualGreater: Ype,
  LessFullEqual: Zpe,
  LessGreater: Qpe,
  lessgtr: Xpe,
  LessLess: ehe,
  lesssim: the,
  LessSlantEqual: rhe,
  LessTilde: nhe,
  lfisht: ahe,
  lfloor: ihe,
  Lfr: ohe,
  lfr: she,
  lg: lhe,
  lgE: uhe,
  lHar: che,
  lhard: fhe,
  lharu: vhe,
  lharul: dhe,
  lhblk: phe,
  LJcy: hhe,
  ljcy: mhe,
  llarr: ghe,
  ll: yhe,
  Ll: bhe,
  llcorner: khe,
  Lleftarrow: whe,
  llhard: Che,
  lltri: The,
  Lmidot: She,
  lmidot: Ehe,
  lmoustache: xhe,
  lmoust: Ahe,
  lnap: Mhe,
  lnapprox: Lhe,
  lne: Ohe,
  lnE: Dhe,
  lneq: Nhe,
  lneqq: Rhe,
  lnsim: Ihe,
  loang: Phe,
  loarr: Bhe,
  lobrk: qhe,
  longleftarrow: Fhe,
  LongLeftArrow: _he,
  Longleftarrow: Hhe,
  longleftrightarrow: Uhe,
  LongLeftRightArrow: zhe,
  Longleftrightarrow: $he,
  longmapsto: Vhe,
  longrightarrow: Whe,
  LongRightArrow: jhe,
  Longrightarrow: Ghe,
  looparrowleft: Khe,
  looparrowright: Jhe,
  lopar: Yhe,
  Lopf: Zhe,
  lopf: Qhe,
  loplus: Xhe,
  lotimes: eme,
  lowast: tme,
  lowbar: rme,
  LowerLeftArrow: nme,
  LowerRightArrow: ame,
  loz: ime,
  lozenge: ome,
  lozf: sme,
  lpar: lme,
  lparlt: ume,
  lrarr: cme,
  lrcorner: fme,
  lrhar: vme,
  lrhard: dme,
  lrm: pme,
  lrtri: hme,
  lsaquo: mme,
  lscr: gme,
  Lscr: yme,
  lsh: bme,
  Lsh: kme,
  lsim: wme,
  lsime: Cme,
  lsimg: Tme,
  lsqb: Sme,
  lsquo: Eme,
  lsquor: xme,
  Lstrok: Ame,
  lstrok: Mme,
  ltcc: Lme,
  ltcir: Ome,
  lt: Dme,
  LT: Nme,
  Lt: Rme,
  ltdot: Ime,
  lthree: Pme,
  ltimes: Bme,
  ltlarr: qme,
  ltquest: Fme,
  ltri: _me,
  ltrie: Hme,
  ltrif: Ume,
  ltrPar: zme,
  lurdshar: $me,
  luruhar: Vme,
  lvertneqq: Wme,
  lvnE: jme,
  macr: Gme,
  male: Kme,
  malt: Jme,
  maltese: Yme,
  Map: "⤅",
  map: Zme,
  mapsto: Qme,
  mapstodown: Xme,
  mapstoleft: ege,
  mapstoup: tge,
  marker: rge,
  mcomma: nge,
  Mcy: age,
  mcy: ige,
  mdash: oge,
  mDDot: sge,
  measuredangle: lge,
  MediumSpace: uge,
  Mellintrf: cge,
  Mfr: fge,
  mfr: vge,
  mho: dge,
  micro: pge,
  midast: hge,
  midcir: mge,
  mid: gge,
  middot: yge,
  minusb: bge,
  minus: kge,
  minusd: wge,
  minusdu: Cge,
  MinusPlus: Tge,
  mlcp: Sge,
  mldr: Ege,
  mnplus: xge,
  models: Age,
  Mopf: Mge,
  mopf: Lge,
  mp: Oge,
  mscr: Dge,
  Mscr: Nge,
  mstpos: Rge,
  Mu: Ige,
  mu: Pge,
  multimap: Bge,
  mumap: qge,
  nabla: Fge,
  Nacute: _ge,
  nacute: Hge,
  nang: Uge,
  nap: zge,
  napE: $ge,
  napid: Vge,
  napos: Wge,
  napprox: jge,
  natural: Gge,
  naturals: Kge,
  natur: Jge,
  nbsp: Yge,
  nbump: Zge,
  nbumpe: Qge,
  ncap: Xge,
  Ncaron: eye,
  ncaron: tye,
  Ncedil: rye,
  ncedil: nye,
  ncong: aye,
  ncongdot: iye,
  ncup: oye,
  Ncy: sye,
  ncy: lye,
  ndash: uye,
  nearhk: cye,
  nearr: fye,
  neArr: vye,
  nearrow: dye,
  ne: pye,
  nedot: hye,
  NegativeMediumSpace: mye,
  NegativeThickSpace: gye,
  NegativeThinSpace: yye,
  NegativeVeryThinSpace: bye,
  nequiv: kye,
  nesear: wye,
  nesim: Cye,
  NestedGreaterGreater: Tye,
  NestedLessLess: Sye,
  NewLine: Eye,
  nexist: xye,
  nexists: Aye,
  Nfr: Mye,
  nfr: Lye,
  ngE: Oye,
  nge: Dye,
  ngeq: Nye,
  ngeqq: Rye,
  ngeqslant: Iye,
  nges: Pye,
  nGg: Bye,
  ngsim: qye,
  nGt: Fye,
  ngt: _ye,
  ngtr: Hye,
  nGtv: Uye,
  nharr: zye,
  nhArr: $ye,
  nhpar: Vye,
  ni: Wye,
  nis: jye,
  nisd: Gye,
  niv: Kye,
  NJcy: Jye,
  njcy: Yye,
  nlarr: Zye,
  nlArr: Qye,
  nldr: Xye,
  nlE: ebe,
  nle: tbe,
  nleftarrow: rbe,
  nLeftarrow: nbe,
  nleftrightarrow: abe,
  nLeftrightarrow: ibe,
  nleq: obe,
  nleqq: sbe,
  nleqslant: lbe,
  nles: ube,
  nless: cbe,
  nLl: fbe,
  nlsim: vbe,
  nLt: dbe,
  nlt: pbe,
  nltri: hbe,
  nltrie: mbe,
  nLtv: gbe,
  nmid: ybe,
  NoBreak: bbe,
  NonBreakingSpace: kbe,
  nopf: wbe,
  Nopf: Cbe,
  Not: Tbe,
  not: Sbe,
  NotCongruent: Ebe,
  NotCupCap: xbe,
  NotDoubleVerticalBar: Abe,
  NotElement: Mbe,
  NotEqual: Lbe,
  NotEqualTilde: Obe,
  NotExists: Dbe,
  NotGreater: Nbe,
  NotGreaterEqual: Rbe,
  NotGreaterFullEqual: Ibe,
  NotGreaterGreater: Pbe,
  NotGreaterLess: Bbe,
  NotGreaterSlantEqual: qbe,
  NotGreaterTilde: Fbe,
  NotHumpDownHump: _be,
  NotHumpEqual: Hbe,
  notin: Ube,
  notindot: zbe,
  notinE: $be,
  notinva: Vbe,
  notinvb: Wbe,
  notinvc: jbe,
  NotLeftTriangleBar: Gbe,
  NotLeftTriangle: Kbe,
  NotLeftTriangleEqual: Jbe,
  NotLess: Ybe,
  NotLessEqual: Zbe,
  NotLessGreater: Qbe,
  NotLessLess: Xbe,
  NotLessSlantEqual: eke,
  NotLessTilde: tke,
  NotNestedGreaterGreater: rke,
  NotNestedLessLess: nke,
  notni: ake,
  notniva: ike,
  notnivb: oke,
  notnivc: ske,
  NotPrecedes: lke,
  NotPrecedesEqual: uke,
  NotPrecedesSlantEqual: cke,
  NotReverseElement: fke,
  NotRightTriangleBar: vke,
  NotRightTriangle: dke,
  NotRightTriangleEqual: pke,
  NotSquareSubset: hke,
  NotSquareSubsetEqual: mke,
  NotSquareSuperset: gke,
  NotSquareSupersetEqual: yke,
  NotSubset: bke,
  NotSubsetEqual: kke,
  NotSucceeds: wke,
  NotSucceedsEqual: Cke,
  NotSucceedsSlantEqual: Tke,
  NotSucceedsTilde: Ske,
  NotSuperset: Eke,
  NotSupersetEqual: xke,
  NotTilde: Ake,
  NotTildeEqual: Mke,
  NotTildeFullEqual: Lke,
  NotTildeTilde: Oke,
  NotVerticalBar: Dke,
  nparallel: Nke,
  npar: Rke,
  nparsl: Ike,
  npart: Pke,
  npolint: Bke,
  npr: qke,
  nprcue: Fke,
  nprec: _ke,
  npreceq: Hke,
  npre: Uke,
  nrarrc: zke,
  nrarr: $ke,
  nrArr: Vke,
  nrarrw: Wke,
  nrightarrow: jke,
  nRightarrow: Gke,
  nrtri: Kke,
  nrtrie: Jke,
  nsc: Yke,
  nsccue: Zke,
  nsce: Qke,
  Nscr: Xke,
  nscr: ewe,
  nshortmid: twe,
  nshortparallel: rwe,
  nsim: nwe,
  nsime: awe,
  nsimeq: iwe,
  nsmid: owe,
  nspar: swe,
  nsqsube: lwe,
  nsqsupe: uwe,
  nsub: cwe,
  nsubE: fwe,
  nsube: vwe,
  nsubset: dwe,
  nsubseteq: pwe,
  nsubseteqq: hwe,
  nsucc: mwe,
  nsucceq: gwe,
  nsup: ywe,
  nsupE: bwe,
  nsupe: kwe,
  nsupset: wwe,
  nsupseteq: Cwe,
  nsupseteqq: Twe,
  ntgl: Swe,
  Ntilde: Ewe,
  ntilde: xwe,
  ntlg: Awe,
  ntriangleleft: Mwe,
  ntrianglelefteq: Lwe,
  ntriangleright: Owe,
  ntrianglerighteq: Dwe,
  Nu: Nwe,
  nu: Rwe,
  num: Iwe,
  numero: Pwe,
  numsp: Bwe,
  nvap: qwe,
  nvdash: Fwe,
  nvDash: _we,
  nVdash: Hwe,
  nVDash: Uwe,
  nvge: zwe,
  nvgt: $we,
  nvHarr: Vwe,
  nvinfin: Wwe,
  nvlArr: jwe,
  nvle: Gwe,
  nvlt: Kwe,
  nvltrie: Jwe,
  nvrArr: Ywe,
  nvrtrie: Zwe,
  nvsim: Qwe,
  nwarhk: Xwe,
  nwarr: eCe,
  nwArr: tCe,
  nwarrow: rCe,
  nwnear: nCe,
  Oacute: aCe,
  oacute: iCe,
  oast: oCe,
  Ocirc: sCe,
  ocirc: lCe,
  ocir: uCe,
  Ocy: cCe,
  ocy: fCe,
  odash: vCe,
  Odblac: dCe,
  odblac: pCe,
  odiv: hCe,
  odot: mCe,
  odsold: gCe,
  OElig: yCe,
  oelig: bCe,
  ofcir: kCe,
  Ofr: wCe,
  ofr: CCe,
  ogon: TCe,
  Ograve: SCe,
  ograve: ECe,
  ogt: xCe,
  ohbar: ACe,
  ohm: MCe,
  oint: LCe,
  olarr: OCe,
  olcir: DCe,
  olcross: NCe,
  oline: RCe,
  olt: ICe,
  Omacr: PCe,
  omacr: BCe,
  Omega: qCe,
  omega: FCe,
  Omicron: _Ce,
  omicron: HCe,
  omid: UCe,
  ominus: zCe,
  Oopf: $Ce,
  oopf: VCe,
  opar: WCe,
  OpenCurlyDoubleQuote: jCe,
  OpenCurlyQuote: GCe,
  operp: KCe,
  oplus: JCe,
  orarr: YCe,
  Or: ZCe,
  or: QCe,
  ord: XCe,
  order: eTe,
  orderof: tTe,
  ordf: rTe,
  ordm: nTe,
  origof: aTe,
  oror: iTe,
  orslope: oTe,
  orv: sTe,
  oS: lTe,
  Oscr: uTe,
  oscr: cTe,
  Oslash: fTe,
  oslash: vTe,
  osol: dTe,
  Otilde: pTe,
  otilde: hTe,
  otimesas: mTe,
  Otimes: gTe,
  otimes: yTe,
  Ouml: bTe,
  ouml: kTe,
  ovbar: wTe,
  OverBar: CTe,
  OverBrace: TTe,
  OverBracket: STe,
  OverParenthesis: ETe,
  para: xTe,
  parallel: ATe,
  par: MTe,
  parsim: LTe,
  parsl: OTe,
  part: DTe,
  PartialD: NTe,
  Pcy: RTe,
  pcy: ITe,
  percnt: PTe,
  period: BTe,
  permil: qTe,
  perp: FTe,
  pertenk: _Te,
  Pfr: HTe,
  pfr: UTe,
  Phi: zTe,
  phi: $Te,
  phiv: VTe,
  phmmat: WTe,
  phone: jTe,
  Pi: GTe,
  pi: KTe,
  pitchfork: JTe,
  piv: YTe,
  planck: ZTe,
  planckh: QTe,
  plankv: XTe,
  plusacir: e0e,
  plusb: t0e,
  pluscir: r0e,
  plus: n0e,
  plusdo: a0e,
  plusdu: i0e,
  pluse: o0e,
  PlusMinus: s0e,
  plusmn: l0e,
  plussim: u0e,
  plustwo: c0e,
  pm: f0e,
  Poincareplane: v0e,
  pointint: d0e,
  popf: p0e,
  Popf: h0e,
  pound: m0e,
  prap: g0e,
  Pr: y0e,
  pr: b0e,
  prcue: k0e,
  precapprox: w0e,
  prec: C0e,
  preccurlyeq: T0e,
  Precedes: S0e,
  PrecedesEqual: E0e,
  PrecedesSlantEqual: x0e,
  PrecedesTilde: A0e,
  preceq: M0e,
  precnapprox: L0e,
  precneqq: O0e,
  precnsim: D0e,
  pre: N0e,
  prE: R0e,
  precsim: I0e,
  prime: P0e,
  Prime: B0e,
  primes: q0e,
  prnap: F0e,
  prnE: _0e,
  prnsim: H0e,
  prod: U0e,
  Product: z0e,
  profalar: $0e,
  profline: V0e,
  profsurf: W0e,
  prop: j0e,
  Proportional: G0e,
  Proportion: K0e,
  propto: J0e,
  prsim: Y0e,
  prurel: Z0e,
  Pscr: Q0e,
  pscr: X0e,
  Psi: e1e,
  psi: t1e,
  puncsp: r1e,
  Qfr: n1e,
  qfr: a1e,
  qint: i1e,
  qopf: o1e,
  Qopf: s1e,
  qprime: l1e,
  Qscr: u1e,
  qscr: c1e,
  quaternions: f1e,
  quatint: v1e,
  quest: d1e,
  questeq: p1e,
  quot: h1e,
  QUOT: m1e,
  rAarr: g1e,
  race: y1e,
  Racute: b1e,
  racute: k1e,
  radic: w1e,
  raemptyv: C1e,
  rang: T1e,
  Rang: S1e,
  rangd: E1e,
  range: x1e,
  rangle: A1e,
  raquo: M1e,
  rarrap: L1e,
  rarrb: O1e,
  rarrbfs: D1e,
  rarrc: N1e,
  rarr: R1e,
  Rarr: I1e,
  rArr: P1e,
  rarrfs: B1e,
  rarrhk: q1e,
  rarrlp: F1e,
  rarrpl: _1e,
  rarrsim: H1e,
  Rarrtl: U1e,
  rarrtl: z1e,
  rarrw: $1e,
  ratail: V1e,
  rAtail: W1e,
  ratio: j1e,
  rationals: G1e,
  rbarr: K1e,
  rBarr: J1e,
  RBarr: Y1e,
  rbbrk: Z1e,
  rbrace: Q1e,
  rbrack: X1e,
  rbrke: eSe,
  rbrksld: tSe,
  rbrkslu: rSe,
  Rcaron: nSe,
  rcaron: aSe,
  Rcedil: iSe,
  rcedil: oSe,
  rceil: sSe,
  rcub: lSe,
  Rcy: uSe,
  rcy: cSe,
  rdca: fSe,
  rdldhar: vSe,
  rdquo: dSe,
  rdquor: pSe,
  rdsh: hSe,
  real: mSe,
  realine: gSe,
  realpart: ySe,
  reals: bSe,
  Re: kSe,
  rect: wSe,
  reg: CSe,
  REG: TSe,
  ReverseElement: SSe,
  ReverseEquilibrium: ESe,
  ReverseUpEquilibrium: xSe,
  rfisht: ASe,
  rfloor: MSe,
  rfr: LSe,
  Rfr: OSe,
  rHar: DSe,
  rhard: NSe,
  rharu: RSe,
  rharul: ISe,
  Rho: PSe,
  rho: BSe,
  rhov: qSe,
  RightAngleBracket: FSe,
  RightArrowBar: _Se,
  rightarrow: HSe,
  RightArrow: USe,
  Rightarrow: zSe,
  RightArrowLeftArrow: $Se,
  rightarrowtail: VSe,
  RightCeiling: WSe,
  RightDoubleBracket: jSe,
  RightDownTeeVector: GSe,
  RightDownVectorBar: KSe,
  RightDownVector: JSe,
  RightFloor: YSe,
  rightharpoondown: ZSe,
  rightharpoonup: QSe,
  rightleftarrows: XSe,
  rightleftharpoons: eEe,
  rightrightarrows: tEe,
  rightsquigarrow: rEe,
  RightTeeArrow: nEe,
  RightTee: aEe,
  RightTeeVector: iEe,
  rightthreetimes: oEe,
  RightTriangleBar: sEe,
  RightTriangle: lEe,
  RightTriangleEqual: uEe,
  RightUpDownVector: cEe,
  RightUpTeeVector: fEe,
  RightUpVectorBar: vEe,
  RightUpVector: dEe,
  RightVectorBar: pEe,
  RightVector: hEe,
  ring: mEe,
  risingdotseq: gEe,
  rlarr: yEe,
  rlhar: bEe,
  rlm: kEe,
  rmoustache: wEe,
  rmoust: CEe,
  rnmid: TEe,
  roang: SEe,
  roarr: EEe,
  robrk: xEe,
  ropar: AEe,
  ropf: MEe,
  Ropf: LEe,
  roplus: OEe,
  rotimes: DEe,
  RoundImplies: NEe,
  rpar: REe,
  rpargt: IEe,
  rppolint: PEe,
  rrarr: BEe,
  Rrightarrow: qEe,
  rsaquo: FEe,
  rscr: _Ee,
  Rscr: HEe,
  rsh: UEe,
  Rsh: zEe,
  rsqb: $Ee,
  rsquo: VEe,
  rsquor: WEe,
  rthree: jEe,
  rtimes: GEe,
  rtri: KEe,
  rtrie: JEe,
  rtrif: YEe,
  rtriltri: ZEe,
  RuleDelayed: QEe,
  ruluhar: XEe,
  rx: exe,
  Sacute: txe,
  sacute: rxe,
  sbquo: nxe,
  scap: axe,
  Scaron: ixe,
  scaron: oxe,
  Sc: sxe,
  sc: lxe,
  sccue: uxe,
  sce: cxe,
  scE: fxe,
  Scedil: vxe,
  scedil: dxe,
  Scirc: pxe,
  scirc: hxe,
  scnap: mxe,
  scnE: gxe,
  scnsim: yxe,
  scpolint: bxe,
  scsim: kxe,
  Scy: wxe,
  scy: Cxe,
  sdotb: Txe,
  sdot: Sxe,
  sdote: Exe,
  searhk: xxe,
  searr: Axe,
  seArr: Mxe,
  searrow: Lxe,
  sect: Oxe,
  semi: Dxe,
  seswar: Nxe,
  setminus: Rxe,
  setmn: Ixe,
  sext: Pxe,
  Sfr: Bxe,
  sfr: qxe,
  sfrown: Fxe,
  sharp: _xe,
  SHCHcy: Hxe,
  shchcy: Uxe,
  SHcy: zxe,
  shcy: $xe,
  ShortDownArrow: Vxe,
  ShortLeftArrow: Wxe,
  shortmid: jxe,
  shortparallel: Gxe,
  ShortRightArrow: Kxe,
  ShortUpArrow: Jxe,
  shy: Yxe,
  Sigma: Zxe,
  sigma: Qxe,
  sigmaf: Xxe,
  sigmav: eAe,
  sim: tAe,
  simdot: rAe,
  sime: nAe,
  simeq: aAe,
  simg: iAe,
  simgE: oAe,
  siml: sAe,
  simlE: lAe,
  simne: uAe,
  simplus: cAe,
  simrarr: fAe,
  slarr: vAe,
  SmallCircle: dAe,
  smallsetminus: pAe,
  smashp: hAe,
  smeparsl: mAe,
  smid: gAe,
  smile: yAe,
  smt: bAe,
  smte: kAe,
  smtes: wAe,
  SOFTcy: CAe,
  softcy: TAe,
  solbar: SAe,
  solb: EAe,
  sol: xAe,
  Sopf: AAe,
  sopf: MAe,
  spades: LAe,
  spadesuit: OAe,
  spar: DAe,
  sqcap: NAe,
  sqcaps: RAe,
  sqcup: IAe,
  sqcups: PAe,
  Sqrt: BAe,
  sqsub: qAe,
  sqsube: FAe,
  sqsubset: _Ae,
  sqsubseteq: HAe,
  sqsup: UAe,
  sqsupe: zAe,
  sqsupset: $Ae,
  sqsupseteq: VAe,
  square: WAe,
  Square: jAe,
  SquareIntersection: GAe,
  SquareSubset: KAe,
  SquareSubsetEqual: JAe,
  SquareSuperset: YAe,
  SquareSupersetEqual: ZAe,
  SquareUnion: QAe,
  squarf: XAe,
  squ: eMe,
  squf: tMe,
  srarr: rMe,
  Sscr: nMe,
  sscr: aMe,
  ssetmn: iMe,
  ssmile: oMe,
  sstarf: sMe,
  Star: lMe,
  star: uMe,
  starf: cMe,
  straightepsilon: fMe,
  straightphi: vMe,
  strns: dMe,
  sub: pMe,
  Sub: hMe,
  subdot: mMe,
  subE: gMe,
  sube: yMe,
  subedot: bMe,
  submult: kMe,
  subnE: wMe,
  subne: CMe,
  subplus: TMe,
  subrarr: SMe,
  subset: EMe,
  Subset: xMe,
  subseteq: AMe,
  subseteqq: MMe,
  SubsetEqual: LMe,
  subsetneq: OMe,
  subsetneqq: DMe,
  subsim: NMe,
  subsub: RMe,
  subsup: IMe,
  succapprox: PMe,
  succ: BMe,
  succcurlyeq: qMe,
  Succeeds: FMe,
  SucceedsEqual: _Me,
  SucceedsSlantEqual: HMe,
  SucceedsTilde: UMe,
  succeq: zMe,
  succnapprox: $Me,
  succneqq: VMe,
  succnsim: WMe,
  succsim: jMe,
  SuchThat: GMe,
  sum: KMe,
  Sum: JMe,
  sung: YMe,
  sup1: ZMe,
  sup2: QMe,
  sup3: XMe,
  sup: eLe,
  Sup: tLe,
  supdot: rLe,
  supdsub: nLe,
  supE: aLe,
  supe: iLe,
  supedot: oLe,
  Superset: sLe,
  SupersetEqual: lLe,
  suphsol: uLe,
  suphsub: cLe,
  suplarr: fLe,
  supmult: vLe,
  supnE: dLe,
  supne: pLe,
  supplus: hLe,
  supset: mLe,
  Supset: gLe,
  supseteq: yLe,
  supseteqq: bLe,
  supsetneq: kLe,
  supsetneqq: wLe,
  supsim: CLe,
  supsub: TLe,
  supsup: SLe,
  swarhk: ELe,
  swarr: xLe,
  swArr: ALe,
  swarrow: MLe,
  swnwar: LLe,
  szlig: OLe,
  Tab: DLe,
  target: NLe,
  Tau: RLe,
  tau: ILe,
  tbrk: PLe,
  Tcaron: BLe,
  tcaron: qLe,
  Tcedil: FLe,
  tcedil: _Le,
  Tcy: HLe,
  tcy: ULe,
  tdot: zLe,
  telrec: $Le,
  Tfr: VLe,
  tfr: WLe,
  there4: jLe,
  therefore: GLe,
  Therefore: KLe,
  Theta: JLe,
  theta: YLe,
  thetasym: ZLe,
  thetav: QLe,
  thickapprox: XLe,
  thicksim: eOe,
  ThickSpace: tOe,
  ThinSpace: rOe,
  thinsp: nOe,
  thkap: aOe,
  thksim: iOe,
  THORN: oOe,
  thorn: sOe,
  tilde: lOe,
  Tilde: uOe,
  TildeEqual: cOe,
  TildeFullEqual: fOe,
  TildeTilde: vOe,
  timesbar: dOe,
  timesb: pOe,
  times: hOe,
  timesd: mOe,
  tint: gOe,
  toea: yOe,
  topbot: bOe,
  topcir: kOe,
  top: wOe,
  Topf: COe,
  topf: TOe,
  topfork: SOe,
  tosa: EOe,
  tprime: xOe,
  trade: AOe,
  TRADE: MOe,
  triangle: LOe,
  triangledown: OOe,
  triangleleft: DOe,
  trianglelefteq: NOe,
  triangleq: ROe,
  triangleright: IOe,
  trianglerighteq: POe,
  tridot: BOe,
  trie: qOe,
  triminus: FOe,
  TripleDot: _Oe,
  triplus: HOe,
  trisb: UOe,
  tritime: zOe,
  trpezium: $Oe,
  Tscr: VOe,
  tscr: WOe,
  TScy: jOe,
  tscy: GOe,
  TSHcy: KOe,
  tshcy: JOe,
  Tstrok: YOe,
  tstrok: ZOe,
  twixt: QOe,
  twoheadleftarrow: XOe,
  twoheadrightarrow: eDe,
  Uacute: tDe,
  uacute: rDe,
  uarr: nDe,
  Uarr: aDe,
  uArr: iDe,
  Uarrocir: oDe,
  Ubrcy: sDe,
  ubrcy: lDe,
  Ubreve: uDe,
  ubreve: cDe,
  Ucirc: fDe,
  ucirc: vDe,
  Ucy: dDe,
  ucy: pDe,
  udarr: hDe,
  Udblac: mDe,
  udblac: gDe,
  udhar: yDe,
  ufisht: bDe,
  Ufr: kDe,
  ufr: wDe,
  Ugrave: CDe,
  ugrave: TDe,
  uHar: SDe,
  uharl: EDe,
  uharr: xDe,
  uhblk: ADe,
  ulcorn: MDe,
  ulcorner: LDe,
  ulcrop: ODe,
  ultri: DDe,
  Umacr: NDe,
  umacr: RDe,
  uml: IDe,
  UnderBar: PDe,
  UnderBrace: BDe,
  UnderBracket: qDe,
  UnderParenthesis: FDe,
  Union: _De,
  UnionPlus: HDe,
  Uogon: UDe,
  uogon: zDe,
  Uopf: $De,
  uopf: VDe,
  UpArrowBar: WDe,
  uparrow: jDe,
  UpArrow: GDe,
  Uparrow: KDe,
  UpArrowDownArrow: JDe,
  updownarrow: YDe,
  UpDownArrow: ZDe,
  Updownarrow: QDe,
  UpEquilibrium: XDe,
  upharpoonleft: eNe,
  upharpoonright: tNe,
  uplus: rNe,
  UpperLeftArrow: nNe,
  UpperRightArrow: aNe,
  upsi: iNe,
  Upsi: oNe,
  upsih: sNe,
  Upsilon: lNe,
  upsilon: uNe,
  UpTeeArrow: cNe,
  UpTee: fNe,
  upuparrows: vNe,
  urcorn: dNe,
  urcorner: pNe,
  urcrop: hNe,
  Uring: mNe,
  uring: gNe,
  urtri: yNe,
  Uscr: bNe,
  uscr: kNe,
  utdot: wNe,
  Utilde: CNe,
  utilde: TNe,
  utri: SNe,
  utrif: ENe,
  uuarr: xNe,
  Uuml: ANe,
  uuml: MNe,
  uwangle: LNe,
  vangrt: ONe,
  varepsilon: DNe,
  varkappa: NNe,
  varnothing: RNe,
  varphi: INe,
  varpi: PNe,
  varpropto: BNe,
  varr: qNe,
  vArr: FNe,
  varrho: _Ne,
  varsigma: HNe,
  varsubsetneq: UNe,
  varsubsetneqq: zNe,
  varsupsetneq: $Ne,
  varsupsetneqq: VNe,
  vartheta: WNe,
  vartriangleleft: jNe,
  vartriangleright: GNe,
  vBar: KNe,
  Vbar: JNe,
  vBarv: YNe,
  Vcy: ZNe,
  vcy: QNe,
  vdash: XNe,
  vDash: eRe,
  Vdash: tRe,
  VDash: rRe,
  Vdashl: nRe,
  veebar: aRe,
  vee: iRe,
  Vee: oRe,
  veeeq: sRe,
  vellip: lRe,
  verbar: uRe,
  Verbar: cRe,
  vert: fRe,
  Vert: vRe,
  VerticalBar: dRe,
  VerticalLine: pRe,
  VerticalSeparator: hRe,
  VerticalTilde: mRe,
  VeryThinSpace: gRe,
  Vfr: yRe,
  vfr: bRe,
  vltri: kRe,
  vnsub: wRe,
  vnsup: CRe,
  Vopf: TRe,
  vopf: SRe,
  vprop: ERe,
  vrtri: xRe,
  Vscr: ARe,
  vscr: MRe,
  vsubnE: LRe,
  vsubne: ORe,
  vsupnE: DRe,
  vsupne: NRe,
  Vvdash: RRe,
  vzigzag: IRe,
  Wcirc: PRe,
  wcirc: BRe,
  wedbar: qRe,
  wedge: FRe,
  Wedge: _Re,
  wedgeq: HRe,
  weierp: URe,
  Wfr: zRe,
  wfr: $Re,
  Wopf: VRe,
  wopf: WRe,
  wp: jRe,
  wr: GRe,
  wreath: KRe,
  Wscr: JRe,
  wscr: YRe,
  xcap: ZRe,
  xcirc: QRe,
  xcup: XRe,
  xdtri: eIe,
  Xfr: tIe,
  xfr: rIe,
  xharr: nIe,
  xhArr: aIe,
  Xi: iIe,
  xi: oIe,
  xlarr: sIe,
  xlArr: lIe,
  xmap: uIe,
  xnis: cIe,
  xodot: fIe,
  Xopf: vIe,
  xopf: dIe,
  xoplus: pIe,
  xotime: hIe,
  xrarr: mIe,
  xrArr: gIe,
  Xscr: yIe,
  xscr: bIe,
  xsqcup: kIe,
  xuplus: wIe,
  xutri: CIe,
  xvee: TIe,
  xwedge: SIe,
  Yacute: EIe,
  yacute: xIe,
  YAcy: AIe,
  yacy: MIe,
  Ycirc: LIe,
  ycirc: OIe,
  Ycy: DIe,
  ycy: NIe,
  yen: RIe,
  Yfr: IIe,
  yfr: PIe,
  YIcy: BIe,
  yicy: qIe,
  Yopf: FIe,
  yopf: _Ie,
  Yscr: HIe,
  yscr: UIe,
  YUcy: zIe,
  yucy: $Ie,
  yuml: VIe,
  Yuml: WIe,
  Zacute: jIe,
  zacute: GIe,
  Zcaron: KIe,
  zcaron: JIe,
  Zcy: YIe,
  zcy: ZIe,
  Zdot: QIe,
  zdot: XIe,
  zeetrf: ePe,
  ZeroWidthSpace: tPe,
  Zeta: rPe,
  zeta: nPe,
  zfr: aPe,
  Zfr: iPe,
  ZHcy: oPe,
  zhcy: sPe,
  zigrarr: lPe,
  zopf: uPe,
  Zopf: cPe,
  Zscr: fPe,
  zscr: vPe,
  zwj: dPe,
  zwnj: pPe
}, hPe = "Á", mPe = "á", gPe = "Â", yPe = "â", bPe = "´", kPe = "Æ", wPe = "æ", CPe = "À", TPe = "à", SPe = "&", EPe = "&", xPe = "Å", APe = "å", MPe = "Ã", LPe = "ã", OPe = "Ä", DPe = "ä", NPe = "¦", RPe = "Ç", IPe = "ç", PPe = "¸", BPe = "¢", qPe = "©", FPe = "©", _Pe = "¤", HPe = "°", UPe = "÷", zPe = "É", $Pe = "é", VPe = "Ê", WPe = "ê", jPe = "È", GPe = "è", KPe = "Ð", JPe = "ð", YPe = "Ë", ZPe = "ë", QPe = "½", XPe = "¼", eBe = "¾", tBe = ">", rBe = ">", nBe = "Í", aBe = "í", iBe = "Î", oBe = "î", sBe = "¡", lBe = "Ì", uBe = "ì", cBe = "¿", fBe = "Ï", vBe = "ï", dBe = "«", pBe = "<", hBe = "<", mBe = "¯", gBe = "µ", yBe = "·", bBe = " ", kBe = "¬", wBe = "Ñ", CBe = "ñ", TBe = "Ó", SBe = "ó", EBe = "Ô", xBe = "ô", ABe = "Ò", MBe = "ò", LBe = "ª", OBe = "º", DBe = "Ø", NBe = "ø", RBe = "Õ", IBe = "õ", PBe = "Ö", BBe = "ö", qBe = "¶", FBe = "±", _Be = "£", HBe = '"', UBe = '"', zBe = "»", $Be = "®", VBe = "®", WBe = "§", jBe = "­", GBe = "¹", KBe = "²", JBe = "³", YBe = "ß", ZBe = "Þ", QBe = "þ", XBe = "×", eqe = "Ú", tqe = "ú", rqe = "Û", nqe = "û", aqe = "Ù", iqe = "ù", oqe = "¨", sqe = "Ü", lqe = "ü", uqe = "Ý", cqe = "ý", fqe = "¥", vqe = "ÿ", dqe = {
  Aacute: hPe,
  aacute: mPe,
  Acirc: gPe,
  acirc: yPe,
  acute: bPe,
  AElig: kPe,
  aelig: wPe,
  Agrave: CPe,
  agrave: TPe,
  amp: SPe,
  AMP: EPe,
  Aring: xPe,
  aring: APe,
  Atilde: MPe,
  atilde: LPe,
  Auml: OPe,
  auml: DPe,
  brvbar: NPe,
  Ccedil: RPe,
  ccedil: IPe,
  cedil: PPe,
  cent: BPe,
  copy: qPe,
  COPY: FPe,
  curren: _Pe,
  deg: HPe,
  divide: UPe,
  Eacute: zPe,
  eacute: $Pe,
  Ecirc: VPe,
  ecirc: WPe,
  Egrave: jPe,
  egrave: GPe,
  ETH: KPe,
  eth: JPe,
  Euml: YPe,
  euml: ZPe,
  frac12: QPe,
  frac14: XPe,
  frac34: eBe,
  gt: tBe,
  GT: rBe,
  Iacute: nBe,
  iacute: aBe,
  Icirc: iBe,
  icirc: oBe,
  iexcl: sBe,
  Igrave: lBe,
  igrave: uBe,
  iquest: cBe,
  Iuml: fBe,
  iuml: vBe,
  laquo: dBe,
  lt: pBe,
  LT: hBe,
  macr: mBe,
  micro: gBe,
  middot: yBe,
  nbsp: bBe,
  not: kBe,
  Ntilde: wBe,
  ntilde: CBe,
  Oacute: TBe,
  oacute: SBe,
  Ocirc: EBe,
  ocirc: xBe,
  Ograve: ABe,
  ograve: MBe,
  ordf: LBe,
  ordm: OBe,
  Oslash: DBe,
  oslash: NBe,
  Otilde: RBe,
  otilde: IBe,
  Ouml: PBe,
  ouml: BBe,
  para: qBe,
  plusmn: FBe,
  pound: _Be,
  quot: HBe,
  QUOT: UBe,
  raquo: zBe,
  reg: $Be,
  REG: VBe,
  sect: WBe,
  shy: jBe,
  sup1: GBe,
  sup2: KBe,
  sup3: JBe,
  szlig: YBe,
  THORN: ZBe,
  thorn: QBe,
  times: XBe,
  Uacute: eqe,
  uacute: tqe,
  Ucirc: rqe,
  ucirc: nqe,
  Ugrave: aqe,
  ugrave: iqe,
  uml: oqe,
  Uuml: sqe,
  uuml: lqe,
  Yacute: uqe,
  yacute: cqe,
  yen: fqe,
  yuml: vqe
}, pqe = "&", hqe = "'", mqe = ">", gqe = "<", yqe = '"', Uh = {
  amp: pqe,
  apos: hqe,
  gt: mqe,
  lt: gqe,
  quot: yqe
}, _c = {}, bqe = {
  0: 65533,
  128: 8364,
  130: 8218,
  131: 402,
  132: 8222,
  133: 8230,
  134: 8224,
  135: 8225,
  136: 710,
  137: 8240,
  138: 352,
  139: 8249,
  140: 338,
  142: 381,
  145: 8216,
  146: 8217,
  147: 8220,
  148: 8221,
  149: 8226,
  150: 8211,
  151: 8212,
  152: 732,
  153: 8482,
  154: 353,
  155: 8250,
  156: 339,
  158: 382,
  159: 376
}, kqe = Ai && Ai.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(_c, "__esModule", { value: !0 });
var ad = kqe(bqe), wqe = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.fromCodePoint || function(t) {
    var e = "";
    return t > 65535 && (t -= 65536, e += String.fromCharCode(t >>> 10 & 1023 | 55296), t = 56320 | t & 1023), e += String.fromCharCode(t), e;
  }
);
function Cqe(t) {
  return t >= 55296 && t <= 57343 || t > 1114111 ? "�" : (t in ad.default && (t = ad.default[t]), wqe(t));
}
_c.default = Cqe;
var $s = Ai && Ai.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(aa, "__esModule", { value: !0 });
aa.decodeHTML = aa.decodeHTMLStrict = aa.decodeXML = void 0;
var Yu = $s(Hh), Tqe = $s(dqe), Sqe = $s(Uh), id = $s(_c), Eqe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
aa.decodeXML = zh(Sqe.default);
aa.decodeHTMLStrict = zh(Yu.default);
function zh(t) {
  var e = $h(t);
  return function(r) {
    return String(r).replace(Eqe, e);
  };
}
var od = function(t, e) {
  return t < e ? 1 : -1;
};
aa.decodeHTML = function() {
  for (var t = Object.keys(Tqe.default).sort(od), e = Object.keys(Yu.default).sort(od), r = 0, n = 0; r < e.length; r++)
    t[n] === e[r] ? (e[r] += ";?", n++) : e[r] += ";";
  var a = new RegExp("&(?:" + e.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), i = $h(Yu.default);
  function o(u) {
    return u.substr(-1) !== ";" && (u += ";"), i(u);
  }
  return function(u) {
    return String(u).replace(a, o);
  };
}();
function $h(t) {
  return function(r) {
    if (r.charAt(1) === "#") {
      var n = r.charAt(2);
      return n === "X" || n === "x" ? id.default(parseInt(r.substr(3), 16)) : id.default(parseInt(r.substr(2), 10));
    }
    return t[r.slice(1, -1)] || r;
  };
}
var tn = {}, Vh = Ai && Ai.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(tn, "__esModule", { value: !0 });
tn.escapeUTF8 = tn.escape = tn.encodeNonAsciiHTML = tn.encodeHTML = tn.encodeXML = void 0;
var xqe = Vh(Uh), Wh = Gh(xqe.default), jh = Kh(Wh);
tn.encodeXML = Zh(Wh);
var Aqe = Vh(Hh), Hc = Gh(Aqe.default), Mqe = Kh(Hc);
tn.encodeHTML = Oqe(Hc, Mqe);
tn.encodeNonAsciiHTML = Zh(Hc);
function Gh(t) {
  return Object.keys(t).sort().reduce(function(e, r) {
    return e[t[r]] = "&" + r + ";", e;
  }, {});
}
function Kh(t) {
  for (var e = [], r = [], n = 0, a = Object.keys(t); n < a.length; n++) {
    var i = a[n];
    i.length === 1 ? e.push("\\" + i) : r.push(i);
  }
  e.sort();
  for (var o = 0; o < e.length - 1; o++) {
    for (var u = o; u < e.length - 1 && e[u].charCodeAt(1) + 1 === e[u + 1].charCodeAt(1); )
      u += 1;
    var m = 1 + u - o;
    m < 3 || e.splice(o, m, e[o] + "-" + e[u]);
  }
  return r.unshift("[" + e.join("") + "]"), new RegExp(r.join("|"), "g");
}
var Jh = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, Lqe = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    function(t) {
      return t.codePointAt(0);
    }
  ) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    function(t) {
      return (t.charCodeAt(0) - 55296) * 1024 + t.charCodeAt(1) - 56320 + 65536;
    }
  )
);
function Vs(t) {
  return "&#x" + (t.length > 1 ? Lqe(t) : t.charCodeAt(0)).toString(16).toUpperCase() + ";";
}
function Oqe(t, e) {
  return function(r) {
    return r.replace(e, function(n) {
      return t[n];
    }).replace(Jh, Vs);
  };
}
var Yh = new RegExp(jh.source + "|" + Jh.source, "g");
function Dqe(t) {
  return t.replace(Yh, Vs);
}
tn.escape = Dqe;
function Nqe(t) {
  return t.replace(jh, Vs);
}
tn.escapeUTF8 = Nqe;
function Zh(t) {
  return function(e) {
    return e.replace(Yh, function(r) {
      return t[r] || Vs(r);
    });
  };
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.decodeXMLStrict = t.decodeHTML5Strict = t.decodeHTML4Strict = t.decodeHTML5 = t.decodeHTML4 = t.decodeHTMLStrict = t.decodeHTML = t.decodeXML = t.encodeHTML5 = t.encodeHTML4 = t.escapeUTF8 = t.escape = t.encodeNonAsciiHTML = t.encodeHTML = t.encodeXML = t.encode = t.decodeStrict = t.decode = void 0;
  var e = aa, r = tn;
  function n(m, y) {
    return (!y || y <= 0 ? e.decodeXML : e.decodeHTML)(m);
  }
  t.decode = n;
  function a(m, y) {
    return (!y || y <= 0 ? e.decodeXML : e.decodeHTMLStrict)(m);
  }
  t.decodeStrict = a;
  function i(m, y) {
    return (!y || y <= 0 ? r.encodeXML : r.encodeHTML)(m);
  }
  t.encode = i;
  var o = tn;
  Object.defineProperty(t, "encodeXML", { enumerable: !0, get: function() {
    return o.encodeXML;
  } }), Object.defineProperty(t, "encodeHTML", { enumerable: !0, get: function() {
    return o.encodeHTML;
  } }), Object.defineProperty(t, "encodeNonAsciiHTML", { enumerable: !0, get: function() {
    return o.encodeNonAsciiHTML;
  } }), Object.defineProperty(t, "escape", { enumerable: !0, get: function() {
    return o.escape;
  } }), Object.defineProperty(t, "escapeUTF8", { enumerable: !0, get: function() {
    return o.escapeUTF8;
  } }), Object.defineProperty(t, "encodeHTML4", { enumerable: !0, get: function() {
    return o.encodeHTML;
  } }), Object.defineProperty(t, "encodeHTML5", { enumerable: !0, get: function() {
    return o.encodeHTML;
  } });
  var u = aa;
  Object.defineProperty(t, "decodeXML", { enumerable: !0, get: function() {
    return u.decodeXML;
  } }), Object.defineProperty(t, "decodeHTML", { enumerable: !0, get: function() {
    return u.decodeHTML;
  } }), Object.defineProperty(t, "decodeHTMLStrict", { enumerable: !0, get: function() {
    return u.decodeHTMLStrict;
  } }), Object.defineProperty(t, "decodeHTML4", { enumerable: !0, get: function() {
    return u.decodeHTML;
  } }), Object.defineProperty(t, "decodeHTML5", { enumerable: !0, get: function() {
    return u.decodeHTML;
  } }), Object.defineProperty(t, "decodeHTML4Strict", { enumerable: !0, get: function() {
    return u.decodeHTMLStrict;
  } }), Object.defineProperty(t, "decodeHTML5Strict", { enumerable: !0, get: function() {
    return u.decodeHTMLStrict;
  } }), Object.defineProperty(t, "decodeXMLStrict", { enumerable: !0, get: function() {
    return u.decodeXML;
  } });
})(Fc);
var Qh = "&(?:#x[a-f0-9]{1,6}|#[0-9]{1,7}|[a-z][a-z0-9]{1,31});", Rqe = 92, Iqe = /[\\&]/, Uc = "[!\"#$%&'()*+,./:;<=>?@[\\\\\\]^_`{|}~-]", Pqe = new RegExp("\\\\" + Uc + "|" + Qh, "gi"), Bqe = '[&<>"]', sd = new RegExp(Bqe, "g"), qqe = function(t) {
  return t.charCodeAt(0) === Rqe ? t.charAt(1) : Fc.decodeHTML(t);
};
function to(t) {
  return Iqe.test(t) ? t.replace(Pqe, qqe) : t;
}
function Jo(t) {
  try {
    return ZZ(t);
  } catch {
    return t;
  }
}
function Fqe(t) {
  switch (t) {
    case "&":
      return "&amp;";
    case "<":
      return "&lt;";
    case ">":
      return "&gt;";
    case '"':
      return "&quot;";
    default:
      return t;
  }
}
function yi(t) {
  return sd.test(t) ? t.replace(sd, Fqe) : t;
}
function Zu(t, e) {
  for (var r = [], n = 0; n < e; n++)
    r.push(t);
  return r.join("");
}
function ld(t) {
  return t ? !/[^ \t]+/.test(t) : !0;
}
var _qe = (
  /** @class */
  function() {
    function t(e) {
      this.current = e, this.root = e, this.entering = !0;
    }
    return t.prototype.next = function() {
      var e = this.current, r = this.entering;
      if (e === null)
        return null;
      var n = zc(e);
      return r && n ? e.firstChild ? (this.current = e.firstChild, this.entering = !0) : this.entering = !1 : e === this.root ? this.current = null : e.next === null ? (this.current = e.parent, this.entering = !1) : (this.current = e.next, this.entering = !0), { entering: r, node: e };
    }, t.prototype.resumeAt = function(e, r) {
      this.current = e, this.entering = r === !0;
    }, t;
  }()
);
function zc(t) {
  switch (t.type) {
    case "document":
    case "blockQuote":
    case "list":
    case "item":
    case "paragraph":
    case "heading":
    case "emph":
    case "strong":
    case "strike":
    case "link":
    case "image":
    case "table":
    case "tableHead":
    case "tableBody":
    case "tableRow":
    case "tableCell":
    case "tableDelimRow":
    case "customInline":
      return !0;
    default:
      return !1;
  }
}
var Hqe = 1, Ws = {};
function Uqe(t) {
  return Ws[t];
}
function Qu(t) {
  delete Ws[t];
}
function zqe() {
  Ws = {};
}
var uo = (
  /** @class */
  function() {
    function t(e, r) {
      this.parent = null, this.prev = null, this.next = null, this.firstChild = null, this.lastChild = null, this.literal = null, e === "document" ? this.id = -1 : this.id = Hqe++, this.type = e, this.sourcepos = r, Ws[this.id] = this;
    }
    return t.prototype.isContainer = function() {
      return zc(this);
    }, t.prototype.unlink = function() {
      this.prev ? this.prev.next = this.next : this.parent && (this.parent.firstChild = this.next), this.next ? this.next.prev = this.prev : this.parent && (this.parent.lastChild = this.prev), this.parent = null, this.next = null, this.prev = null;
    }, t.prototype.replaceWith = function(e) {
      this.insertBefore(e), this.unlink();
    }, t.prototype.insertAfter = function(e) {
      e.unlink(), e.next = this.next, e.next && (e.next.prev = e), e.prev = this, this.next = e, this.parent && (e.parent = this.parent, e.next || (e.parent.lastChild = e));
    }, t.prototype.insertBefore = function(e) {
      e.unlink(), e.prev = this.prev, e.prev && (e.prev.next = e), e.next = this, this.prev = e, e.parent = this.parent, e.prev || (e.parent.firstChild = e);
    }, t.prototype.appendChild = function(e) {
      e.unlink(), e.parent = this, this.lastChild ? (this.lastChild.next = e, e.prev = this.lastChild, this.lastChild = e) : (this.firstChild = e, this.lastChild = e);
    }, t.prototype.prependChild = function(e) {
      e.unlink(), e.parent = this, this.firstChild ? (this.firstChild.prev = e, e.next = this.firstChild, this.firstChild = e) : (this.firstChild = e, this.lastChild = e);
    }, t.prototype.walker = function() {
      return new _qe(this);
    }, t;
  }()
), la = (
  /** @class */
  function(t) {
    cn(e, t);
    function e(r, n) {
      var a = t.call(this, r, n) || this;
      return a.open = !0, a.lineOffsets = null, a.stringContent = null, a.lastLineBlank = !1, a.lastLineChecked = !1, a.type = r, a;
    }
    return e;
  }(uo)
), $qe = (
  /** @class */
  function(t) {
    cn(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.listData = null, r;
    }
    return e;
  }(la)
), Vqe = (
  /** @class */
  function(t) {
    cn(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.level = 0, r.headingType = "atx", r;
    }
    return e;
  }(la)
), Wqe = (
  /** @class */
  function(t) {
    cn(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.isFenced = !1, r.fenceChar = null, r.fenceLength = 0, r.fenceOffset = -1, r.info = null, r.infoPadding = 0, r;
    }
    return e;
  }(la)
), jqe = (
  /** @class */
  function(t) {
    cn(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.columns = [], r;
    }
    return e;
  }(la)
), Gqe = (
  /** @class */
  function(t) {
    cn(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.startIdx = 0, r.endIdx = 0, r.paddingLeft = 0, r.paddingRight = 0, r.ignored = !1, r;
    }
    return e;
  }(la)
), Kqe = (
  /** @class */
  function(t) {
    cn(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.title = "", r.dest = "", r.label = "", r;
    }
    return e;
  }(la)
), Jqe = (
  /** @class */
  function(t) {
    cn(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.syntaxLength = 0, r.offset = -1, r.info = "", r;
    }
    return e;
  }(la)
), Yqe = (
  /** @class */
  function(t) {
    cn(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.htmlBlockType = -1, r;
    }
    return e;
  }(la)
), Zqe = (
  /** @class */
  function(t) {
    cn(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.destination = null, r.title = null, r.extendedAutolink = !1, r;
    }
    return e;
  }(uo)
), Qqe = (
  /** @class */
  function(t) {
    cn(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.tickCount = 0, r;
    }
    return e;
  }(uo)
), Xqe = (
  /** @class */
  function(t) {
    cn(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.info = "", r;
    }
    return e;
  }(uo)
);
function tr(t, e) {
  switch (t) {
    case "heading":
      return new Vqe(t, e);
    case "list":
    case "item":
      return new $qe(t, e);
    case "link":
    case "image":
      return new Zqe(t, e);
    case "codeBlock":
      return new Wqe(t, e);
    case "htmlBlock":
      return new Yqe(t, e);
    case "table":
      return new jqe(t, e);
    case "tableCell":
      return new Gqe(t, e);
    case "document":
    case "paragraph":
    case "blockQuote":
    case "thematicBreak":
    case "tableRow":
    case "tableBody":
    case "tableHead":
    case "frontMatter":
      return new la(t, e);
    case "code":
      return new Qqe(t, e);
    case "refDef":
      return new Kqe(t, e);
    case "customBlock":
      return new Jqe(t, e);
    case "customInline":
      return new Xqe(t, e);
    default:
      return new uo(t, e);
  }
}
function Xh(t) {
  return t.type === "codeBlock";
}
function eFe(t) {
  return t.type === "htmlBlock";
}
function tFe(t) {
  return t.type === "heading";
}
function ud(t) {
  return t.type === "list";
}
function rFe(t) {
  return t.type === "table";
}
function hi(t) {
  return t.type === "refDef";
}
function em(t) {
  return t.type === "customBlock";
}
function nFe(t) {
  return t.type === "customInline";
}
function fr(t, e) {
  var r = tr("text", e);
  return r.literal = t, r;
}
var tm = "[A-Za-z][A-Za-z0-9-]*", aFe = "[a-zA-Z_:][a-zA-Z0-9:._-]*", iFe = "[^\"'=<>`\\x00-\\x20]+", oFe = "'[^']*'", sFe = '"[^"]*"', lFe = "(?:" + iFe + "|" + oFe + "|" + sFe + ")", uFe = "(?:\\s*=\\s*" + lFe + ")", cFe = "(?:\\s+" + aFe + uFe + "?)", rm = "<" + tm + cFe + "*\\s*/?>", nm = "</" + tm + "\\s*[>]", fFe = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->", vFe = "[<][?].*?[?][>]", dFe = "<![A-Z]+\\s+[^>]*>", pFe = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", hFe = "(?:" + rm + "|" + nm + "|" + fFe + "|" + vFe + "|" + dFe + "|" + pFe + ")", mFe = new RegExp("^" + hFe, "i");
/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */
var Xu;
if (String.fromCodePoint)
  Xu = function(t) {
    try {
      return String.fromCodePoint(t);
    } catch (e) {
      if (e instanceof RangeError)
        return String.fromCharCode(65533);
      throw e;
    }
  };
else {
  var gFe = String.fromCharCode, yFe = Math.floor;
  Xu = function() {
    for (var t = [], e = 0; e < arguments.length; e++)
      t[e] = arguments[e];
    var r = 16384, n = [], a, i, o = -1, u = t.length;
    if (!u)
      return "";
    for (var m = ""; ++o < u; ) {
      var y = Number(t[o]);
      if (!isFinite(y) || // `NaN`, `+Infinity`, or `-Infinity`
      y < 0 || // not a valid Unicode code point
      y > 1114111 || // not a valid Unicode code point
      yFe(y) !== y)
        return String.fromCharCode(65533);
      y <= 65535 ? n.push(y) : (y -= 65536, a = (y >> 10) + 55296, i = y % 1024 + 56320, n.push(a, i)), (o + 1 === u || n.length > r) && (m += gFe.apply(void 0, n), n.length = 0);
    }
    return m;
  };
}
var Cu = Xu, bFe = "(?:[w-]+.)*[A-Za-z0-9-]+.[A-Za-z0-9-]+", kFe = "[^<\\s]*[^<?!.,:*_?~\\s]", wFe = "[\\w.+-]+@(?:[\\w-]+\\.)+[\\w-]+";
function CFe(t) {
  var e = /\)+$/.exec(t);
  if (e) {
    for (var r = 0, n = 0, a = t; n < a.length; n++) {
      var i = a[n];
      i === "(" ? r < 0 ? r = 1 : r += 1 : i === ")" && (r -= 1);
    }
    if (r < 0) {
      var o = Math.min(-r, e[0].length);
      return t.substring(0, t.length - o);
    }
  }
  return t;
}
function TFe(t) {
  return t.replace(/&[A-Za-z0-9]+;$/, "");
}
function SFe(t) {
  for (var e = new RegExp(wFe, "g"), r = [], n; n = e.exec(t); ) {
    var a = n[0];
    /[_-]+$/.test(a) || r.push({
      text: a,
      range: [n.index, n.index + a.length - 1],
      url: "mailto:" + a
    });
  }
  return r;
}
function EFe(t) {
  for (var e = new RegExp("(www|https?://)." + bFe + kFe, "g"), r = [], n; n = e.exec(t); ) {
    var a = TFe(CFe(n[0])), i = n[1] === "www" ? "http://" : "";
    r.push({
      text: a,
      range: [n.index, n.index + a.length - 1],
      url: "" + i + a
    });
  }
  return r;
}
function xFe(t) {
  return Ju(Ju([], EFe(t)), SFe(t)).sort(function(e, r) {
    return e.range[0] - r.range[0];
  });
}
function AFe(t, e) {
  typeof e == "boolean" && (e = xFe);
  for (var r, n = function() {
    var a = r.entering, i = r.node;
    if (a && i.type === "text" && i.parent.type !== "link") {
      var o = i.literal, u = e(o);
      if (!u || !u.length)
        return "continue";
      for (var m = 0, y = i.sourcepos[0], C = y[0], T = y[1], x = function(Se, Re) {
        return [
          [C, T + Se],
          [C, T + Re]
        ];
      }, M = [], P = 0, q = u; P < q.length; P++) {
        var _ = q[P], K = _.range, X = _.url, ie = _.text;
        K[0] > m && M.push(fr(o.substring(m, K[0]), x(m, K[0] - 1)));
        var ee = tr("link", x.apply(void 0, K));
        ee.appendChild(fr(ie, x.apply(void 0, K))), ee.destination = X, ee.extendedAutolink = !0, M.push(ee), m = K[1] + 1;
      }
      m < o.length && M.push(fr(o.substring(m), x(m, o.length - 1)));
      for (var oe = 0, ue = M; oe < ue.length; oe++) {
        var pe = ue[oe];
        i.insertBefore(pe);
      }
      i.unlink();
    }
  }; r = t.next(); )
    n();
}
function Es(t) {
  return t[t.length - 1];
}
function cd(t) {
  return t.slice(1, t.length - 1).trim().replace(/[ \t\r\n]+/, " ").toLowerCase().toUpperCase();
}
function Yo(t, e) {
  Object.keys(t).forEach(function(r) {
    e(r, t[r]);
  });
}
function MFe(t) {
  for (var e = [], r = 1; r < arguments.length; r++)
    e[r - 1] = arguments[r];
  var n = Er({}, t);
  return e.forEach(function(a) {
    delete n[a];
  }), n;
}
function mi(t) {
  return !Object.keys(t).length;
}
function LFe(t) {
  Object.keys(t).forEach(function(e) {
    delete t[e];
  });
}
var ec = 10, Tu = 42, Zo = 95, OFe = 96, fd = 91, DFe = 93, Qo = 126, vd = 60, NFe = 33, dd = 92, RFe = 38, pd = 40, Su = 41, IFe = 58, Va = 39, Wa = 34, ja = 36, Eu = "\\\\" + Uc, hd = new RegExp(/[!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/), PFe = new RegExp('^(?:"(' + Eu + '|[^"\\x00])*"|' + ("'(" + Eu + "|[^'\\x00])*'") + "|" + ("\\((" + Eu + "|[^()\\x00])*\\))")), BFe = /^(?:<(?:[^<>\n\\\x00]|\\.)*>)/, md = new RegExp("^" + Uc), qFe = new RegExp("^" + Qh, "i"), FFe = /`+/, _Fe = /^`+/, HFe = /\.\.\./g, UFe = /--+/g, zFe = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/, $Fe = /^<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\x00-\x20]*>/i, VFe = /^ *(?:\n *)?/, xu = /^[ \t\n\x0b\x0c\x0d]/, gd = /^\s/, WFe = / *$/, jFe = /^ */, yd = /^ *(?:\n|$)/, GFe = /^\[(?:[^\\\[\]]|\\.){0,1000}\]/, KFe = /^[^\n`\[\]\\!<&*_'"~$]+/m, JFe = (
  /** @class */
  function() {
    function t(e) {
      this.subject = "", this.delimiters = null, this.brackets = null, this.pos = 0, this.lineStartNum = 0, this.lineIdx = 0, this.lineOffsets = [0], this.linePosOffset = 0, this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.options = e;
    }
    return t.prototype.sourcepos = function(e, r) {
      var n = this.linePosOffset + this.lineOffsets[this.lineIdx], a = this.lineStartNum + this.lineIdx, i = [a, e + n];
      return typeof r == "number" ? [i, [a, r + n]] : i;
    }, t.prototype.nextLine = function() {
      this.lineIdx += 1, this.linePosOffset = -this.pos;
    }, t.prototype.match = function(e) {
      var r = e.exec(this.subject.slice(this.pos));
      return r === null ? null : (this.pos += r.index + r[0].length, r[0]);
    }, t.prototype.peek = function() {
      return this.pos < this.subject.length ? this.subject.charCodeAt(this.pos) : -1;
    }, t.prototype.spnl = function() {
      return this.match(VFe), !0;
    }, t.prototype.parseBackticks = function(e) {
      var r = this.pos + 1, n = this.match(_Fe);
      if (n === null)
        return !1;
      for (var a = this.pos, i; (i = this.match(FFe)) !== null; )
        if (i === n) {
          var o = this.subject.slice(a, this.pos - n.length), u = this.sourcepos(r, this.pos), m = o.split(`
`);
          if (m.length > 1) {
            var y = Es(m);
            this.lineIdx += m.length - 1, this.linePosOffset = -(this.pos - y.length - n.length), u[1] = this.sourcepos(this.pos), o = m.join(" ");
          }
          var C = tr("code", u);
          return o.length > 0 && o.match(/[^ ]/) !== null && o[0] == " " && o[o.length - 1] == " " ? C.literal = o.slice(1, o.length - 1) : C.literal = o, C.tickCount = n.length, e.appendChild(C), !0;
        }
      return this.pos = a, e.appendChild(fr(n, this.sourcepos(r, this.pos - 1))), !0;
    }, t.prototype.parseBackslash = function(e) {
      var r = this.subject, n;
      this.pos += 1;
      var a = this.pos;
      return this.peek() === ec ? (this.pos += 1, n = tr("linebreak", this.sourcepos(this.pos - 1, this.pos)), e.appendChild(n), this.nextLine()) : md.test(r.charAt(this.pos)) ? (e.appendChild(fr(r.charAt(this.pos), this.sourcepos(a, this.pos))), this.pos += 1) : e.appendChild(fr("\\", this.sourcepos(a, a))), !0;
    }, t.prototype.parseAutolink = function(e) {
      var r, n, a, i = this.pos + 1;
      return (r = this.match(zFe)) ? (n = r.slice(1, r.length - 1), a = tr("link", this.sourcepos(i, this.pos)), a.destination = Jo("mailto:" + n), a.title = "", a.appendChild(fr(n, this.sourcepos(i + 1, this.pos - 1))), e.appendChild(a), !0) : (r = this.match($Fe)) ? (n = r.slice(1, r.length - 1), a = tr("link", this.sourcepos(i, this.pos)), a.destination = Jo(n), a.title = "", a.appendChild(fr(n, this.sourcepos(i + 1, this.pos - 1))), e.appendChild(a), !0) : !1;
    }, t.prototype.parseHtmlTag = function(e) {
      var r = this.pos + 1, n = this.match(mFe);
      if (n === null)
        return !1;
      var a = tr("htmlInline", this.sourcepos(r, this.pos));
      return a.literal = n, e.appendChild(a), !0;
    }, t.prototype.scanDelims = function(e) {
      var r = 0, n = this.pos;
      if (e === Va || e === Wa)
        r++, this.pos++;
      else
        for (; this.peek() === e; )
          r++, this.pos++;
      if (r === 0 || r < 2 && (e === Qo || e === ja))
        return this.pos = n, null;
      var a = n === 0 ? `
` : this.subject.charAt(n - 1), i = this.peek(), o;
      i === -1 ? o = `
` : o = Cu(i);
      var u = gd.test(o), m = hd.test(o), y = gd.test(a), C = hd.test(a), T = !u && (!m || y || C), x = !y && (!C || u || m), M, P;
      return e === Zo ? (M = T && (!x || C), P = x && (!T || m)) : e === Va || e === Wa ? (M = T && !x, P = x) : e === ja ? (M = !u, P = !y) : (M = T, P = x), this.pos = n, { numdelims: r, canOpen: M, canClose: P };
    }, t.prototype.handleDelim = function(e, r) {
      var n = this.scanDelims(e);
      if (!n)
        return !1;
      var a = n.numdelims, i = this.pos + 1, o;
      this.pos += a, e === Va ? o = "’" : e === Wa ? o = "“" : o = this.subject.slice(i - 1, this.pos);
      var u = fr(o, this.sourcepos(i, this.pos));
      return r.appendChild(u), (n.canOpen || n.canClose) && (this.options.smart || e !== Va && e !== Wa) && (this.delimiters = {
        cc: e,
        numdelims: a,
        origdelims: a,
        node: u,
        previous: this.delimiters,
        next: null,
        canOpen: n.canOpen,
        canClose: n.canClose
      }, this.delimiters.previous && (this.delimiters.previous.next = this.delimiters)), !0;
    }, t.prototype.removeDelimiter = function(e) {
      e.previous !== null && (e.previous.next = e.next), e.next === null ? this.delimiters = e.previous : e.next.previous = e.previous;
    }, t.prototype.removeDelimitersBetween = function(e, r) {
      e.next !== r && (e.next = r, r.previous = e);
    }, t.prototype.processEmphasis = function(e) {
      var r, n, a, i, o, u, m, y = !1, C = (r = {}, r[Zo] = [e, e, e], r[Tu] = [e, e, e], r[Va] = [e], r[Wa] = [e], r[Qo] = [e], r[ja] = [e], r);
      for (a = this.delimiters; a !== null && a.previous !== e; )
        a = a.previous;
      for (; a !== null; ) {
        var T = a.cc, x = T === Zo || T === Tu;
        if (!a.canClose)
          a = a.next;
        else {
          for (n = a.previous, m = !1; n !== null && n !== e && n !== C[T][x ? a.origdelims % 3 : 0]; ) {
            if (y = x && (a.canOpen || n.canClose) && a.origdelims % 3 !== 0 && (n.origdelims + a.origdelims) % 3 === 0, n.cc === a.cc && n.canOpen && !y) {
              m = !0;
              break;
            }
            n = n.previous;
          }
          if (i = a, x || T === Qo || T === ja) {
            if (!m)
              a = a.next;
            else if (n) {
              var M = a.numdelims >= 2 && n.numdelims >= 2 ? 2 : 1, P = x ? 0 : 1;
              o = n.node, u = a.node;
              var q = x ? M === 1 ? "emph" : "strong" : "strike";
              T === ja && (q = "customInline");
              var _ = tr(q), K = o.sourcepos[1], X = u.sourcepos[0];
              _.sourcepos = [
                [K[0], K[1] - M + 1],
                [X[0], X[1] + M - 1]
              ], o.sourcepos[1][1] -= M, u.sourcepos[0][1] += M, o.literal = o.literal.slice(M), u.literal = u.literal.slice(M), n.numdelims -= M, a.numdelims -= M;
              for (var ie = o.next, ee = void 0; ie && ie !== u; )
                ee = ie.next, ie.unlink(), _.appendChild(ie), ie = ee;
              if (T === ja) {
                var oe = _.firstChild, ue = oe.literal || "", pe = ue.split(/\s/)[0];
                _.info = pe, ue.length <= pe.length ? oe.unlink() : (oe.sourcepos[0][1] += pe.length, oe.literal = ue.replace(pe + " ", ""));
              }
              if (o.insertAfter(_), this.removeDelimitersBetween(n, a), n.numdelims <= P && (n.numdelims === 0 && o.unlink(), this.removeDelimiter(n)), a.numdelims <= P) {
                a.numdelims === 0 && u.unlink();
                var Se = a.next;
                this.removeDelimiter(a), a = Se;
              }
            }
          } else
            T === Va ? (a.node.literal = "’", m && (n.node.literal = "‘"), a = a.next) : T === Wa && (a.node.literal = "”", m && (n.node.literal = "“"), a = a.next);
          m || (C[T][x ? i.origdelims % 3 : 0] = i.previous, i.canOpen || this.removeDelimiter(i));
        }
      }
      for (; this.delimiters !== null && this.delimiters !== e; )
        this.removeDelimiter(this.delimiters);
    }, t.prototype.parseLinkTitle = function() {
      var e = this.match(PFe);
      return e === null ? null : to(e.substr(1, e.length - 2));
    }, t.prototype.parseLinkDestination = function() {
      var e = this.match(BFe);
      if (e === null) {
        if (this.peek() === vd)
          return null;
        for (var r = this.pos, n = 0, a = void 0; (a = this.peek()) !== -1; )
          if (a === dd && md.test(this.subject.charAt(this.pos + 1)))
            this.pos += 1, this.peek() !== -1 && (this.pos += 1);
          else if (a === pd)
            this.pos += 1, n += 1;
          else if (a === Su) {
            if (n < 1)
              break;
            this.pos += 1, n -= 1;
          } else {
            if (xu.exec(Cu(a)) !== null)
              break;
            this.pos += 1;
          }
        return this.pos === r && a !== Su || n !== 0 ? null : (e = this.subject.substr(r, this.pos - r), Jo(to(e)));
      }
      return Jo(to(e.substr(1, e.length - 2)));
    }, t.prototype.parseLinkLabel = function() {
      var e = this.match(GFe);
      return e === null || e.length > 1001 ? 0 : e.length;
    }, t.prototype.parseOpenBracket = function(e) {
      var r = this.pos;
      this.pos += 1;
      var n = fr("[", this.sourcepos(this.pos, this.pos));
      return e.appendChild(n), this.addBracket(n, r, !1), !0;
    }, t.prototype.parseBang = function(e) {
      var r = this.pos;
      if (this.pos += 1, this.peek() === fd) {
        this.pos += 1;
        var n = fr("![", this.sourcepos(this.pos - 1, this.pos));
        e.appendChild(n), this.addBracket(n, r + 1, !0);
      } else {
        var n = fr("!", this.sourcepos(this.pos, this.pos));
        e.appendChild(n);
      }
      return !0;
    }, t.prototype.parseCloseBracket = function(e) {
      var r = null, n = null, a = !1;
      this.pos += 1;
      var i = this.pos, o = this.brackets;
      if (o === null)
        return e.appendChild(fr("]", this.sourcepos(i, i))), !0;
      if (!o.active)
        return e.appendChild(fr("]", this.sourcepos(i, i))), this.removeBracket(), !0;
      var u = o.image, m = this.pos;
      this.peek() === pd && (this.pos++, this.spnl() && (r = this.parseLinkDestination()) !== null && this.spnl() && // make sure there's a space before the title:
      (xu.test(this.subject.charAt(this.pos - 1)) && (n = this.parseLinkTitle()) || !0) && this.spnl() && this.peek() === Su ? (this.pos += 1, a = !0) : this.pos = m);
      var y = "";
      if (!a) {
        var C = this.pos, T = this.parseLinkLabel();
        if (T > 2 ? y = this.subject.slice(C, C + T) : o.bracketAfter || (y = this.subject.slice(o.index, i)), T === 0 && (this.pos = m), y) {
          y = cd(y);
          var x = this.refMap[y];
          x && (r = x.destination, n = x.title, a = !0);
        }
      }
      if (a) {
        var M = tr(u ? "image" : "link");
        M.destination = r, M.title = n || "", M.sourcepos = [o.startpos, this.sourcepos(this.pos)];
        for (var P = o.node.next, q = void 0; P; )
          q = P.next, P.unlink(), M.appendChild(P), P = q;
        if (e.appendChild(M), this.processEmphasis(o.previousDelimiter), this.removeBracket(), o.node.unlink(), !u)
          for (o = this.brackets; o !== null; )
            o.image || (o.active = !1), o = o.previous;
        return this.options.referenceDefinition && (this.refLinkCandidateMap[e.id] = { node: e, refLabel: y }), !0;
      }
      return this.removeBracket(), this.pos = i, e.appendChild(fr("]", this.sourcepos(i, i))), this.options.referenceDefinition && (this.refLinkCandidateMap[e.id] = { node: e, refLabel: y }), !0;
    }, t.prototype.addBracket = function(e, r, n) {
      this.brackets !== null && (this.brackets.bracketAfter = !0), this.brackets = {
        node: e,
        startpos: this.sourcepos(r + (n ? 0 : 1)),
        previous: this.brackets,
        previousDelimiter: this.delimiters,
        index: r,
        image: n,
        active: !0
      };
    }, t.prototype.removeBracket = function() {
      this.brackets && (this.brackets = this.brackets.previous);
    }, t.prototype.parseEntity = function(e) {
      var r, n = this.pos + 1;
      return (r = this.match(qFe)) ? (e.appendChild(fr(Fc.decodeHTML(r), this.sourcepos(n, this.pos))), !0) : !1;
    }, t.prototype.parseString = function(e) {
      var r, n = this.pos + 1;
      if (r = this.match(KFe)) {
        if (this.options.smart) {
          var a = r.replace(HFe, "…").replace(UFe, function(o) {
            var u = 0, m = 0;
            return o.length % 3 === 0 ? m = o.length / 3 : o.length % 2 === 0 ? u = o.length / 2 : o.length % 3 === 2 ? (u = 1, m = (o.length - 2) / 3) : (u = 2, m = (o.length - 4) / 3), Zu("—", m) + Zu("–", u);
          });
          e.appendChild(fr(a, this.sourcepos(n, this.pos)));
        } else {
          var i = fr(r, this.sourcepos(n, this.pos));
          e.appendChild(i);
        }
        return !0;
      }
      return !1;
    }, t.prototype.parseNewline = function(e) {
      this.pos += 1;
      var r = e.lastChild;
      if (r && r.type === "text" && r.literal[r.literal.length - 1] === " ") {
        var n = r.literal[r.literal.length - 2] === " ", a = r.literal.length;
        r.literal = r.literal.replace(WFe, "");
        var i = a - r.literal.length;
        r.sourcepos[1][1] -= i, e.appendChild(tr(n ? "linebreak" : "softbreak", this.sourcepos(this.pos - i, this.pos)));
      } else
        e.appendChild(tr("softbreak", this.sourcepos(this.pos, this.pos)));
      return this.nextLine(), this.match(jFe), !0;
    }, t.prototype.parseReference = function(e, r) {
      if (!this.options.referenceDefinition)
        return 0;
      this.subject = e.stringContent, this.pos = 0;
      var n = null, a = this.pos, i = this.parseLinkLabel();
      if (i === 0)
        return 0;
      var o = this.subject.substr(0, i);
      if (this.peek() === IFe)
        this.pos++;
      else
        return this.pos = a, 0;
      this.spnl();
      var u = this.parseLinkDestination();
      if (u === null)
        return this.pos = a, 0;
      var m = this.pos;
      this.spnl(), this.pos !== m && (n = this.parseLinkTitle()), n === null && (n = "", this.pos = m);
      var y = !0;
      if (this.match(yd) === null && (n === "" ? y = !1 : (n = "", this.pos = m, y = this.match(yd) !== null)), !y)
        return this.pos = a, 0;
      var C = cd(o);
      if (C === "")
        return this.pos = a, 0;
      var T = this.getReferenceDefSourcepos(e);
      e.sourcepos[0][0] = T[1][0] + 1;
      var x = tr("refDef", T);
      return x.title = n, x.dest = u, x.label = C, e.insertBefore(x), r[C] ? this.refDefCandidateMap[x.id] = x : r[C] = nc(x), this.pos - a;
    }, t.prototype.mergeTextNodes = function(e) {
      for (var r, n = []; r = e.next(); ) {
        var a = r.entering, i = r.node;
        if (a && i.type === "text")
          n.push(i);
        else if (n.length === 1)
          n = [];
        else if (n.length > 1) {
          var o = n[0], u = n[n.length - 1];
          o.sourcepos && u.sourcepos && (o.sourcepos[1] = u.sourcepos[1]), o.next = u.next, o.next && (o.next.prev = o);
          for (var m = 1; m < n.length; m += 1)
            o.literal += n[m].literal, n[m].unlink();
          n = [];
        }
      }
    }, t.prototype.getReferenceDefSourcepos = function(e) {
      for (var r = e.stringContent.split(/\n|\r\n/), n = !1, a = 0, i = { line: 0, ch: 0 }, o = 0; o < r.length; o += 1) {
        var u = r[o];
        if (xu.test(u))
          break;
        if (/\:/.test(u) && a === 0) {
          if (n)
            break;
          var m = u.indexOf(":") === u.length - 1 ? o + 1 : o;
          i = { line: m, ch: r[m].length }, n = !0;
        }
        var y = u.match(/'|"/g);
        if (y && (a += y.length), a === 2) {
          i = { line: o, ch: u.length };
          break;
        }
      }
      return [
        [e.sourcepos[0][0], e.sourcepos[0][1]],
        [e.sourcepos[0][0] + i.line, i.ch]
      ];
    }, t.prototype.parseInline = function(e) {
      var r, n = !1, a = this.peek();
      if (a === -1)
        return !1;
      switch (a) {
        case ec:
          n = this.parseNewline(e);
          break;
        case dd:
          n = this.parseBackslash(e);
          break;
        case OFe:
          n = this.parseBackticks(e);
          break;
        case Tu:
        case Zo:
        case Qo:
        case ja:
          n = this.handleDelim(a, e);
          break;
        case Va:
        case Wa:
          n = !!(!((r = this.options) === null || r === void 0) && r.smart) && this.handleDelim(a, e);
          break;
        case fd:
          n = this.parseOpenBracket(e);
          break;
        case NFe:
          n = this.parseBang(e);
          break;
        case DFe:
          n = this.parseCloseBracket(e);
          break;
        case vd:
          n = this.parseAutolink(e) || this.parseHtmlTag(e);
          break;
        case RFe:
          e.disabledEntityParse || (n = this.parseEntity(e));
          break;
        default:
          n = this.parseString(e);
          break;
      }
      return n || (this.pos += 1, e.appendChild(fr(Cu(a), this.sourcepos(this.pos, this.pos + 1)))), !0;
    }, t.prototype.parse = function(e) {
      for (this.subject = e.stringContent.trim(), this.pos = 0, this.delimiters = null, this.brackets = null, this.lineOffsets = e.lineOffsets || [0], this.lineIdx = 0, this.linePosOffset = 0, this.lineStartNum = e.sourcepos[0][0], tFe(e) && (this.lineOffsets[0] += e.level + 1); this.parseInline(e); )
        ;
      e.stringContent = null, this.processEmphasis(null), this.mergeTextNodes(e.walker());
      var r = this.options, n = r.extendedAutolinks, a = r.customParser;
      if (n && AFe(e.walker(), n), a && e.firstChild)
        for (var i, o = e.firstChild.walker(); i = o.next(); ) {
          var u = i.node, m = i.entering;
          a[u.type] && a[u.type](u, { entering: m, options: this.options });
        }
    }, t;
  }()
), YFe = /^\[([ \txX])\][ \t]+/;
function ZFe(t, e) {
  if (e.firstChild && e.firstChild.type === "paragraph") {
    var r = e.firstChild, n = r.stringContent.match(YFe);
    if (n) {
      var a = n[0].length;
      r.stringContent = r.stringContent.substring(a - 1), r.sourcepos[0][1] += a, r.lineOffsets[0] += a, e.listData.task = !0, e.listData.checked = /[xX]/.test(n[1]);
    }
  }
}
var QFe = {
  continue: function() {
    return 0;
  },
  finalize: function() {
  },
  canContain: function(t) {
    return t === "tableHead" || t === "tableBody";
  },
  acceptsLines: !1
}, XFe = {
  continue: function() {
    return 0;
  },
  finalize: function() {
  },
  canContain: function(t) {
    return t === "tableRow";
  },
  acceptsLines: !1
}, e_e = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function(t) {
    return t === "tableRow" || t === "tableDelimRow";
  },
  acceptsLines: !1
}, t_e = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function(t) {
    return t === "tableDelimCell";
  },
  acceptsLines: !1
}, r_e = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !1
}, n_e = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function(t) {
    return t === "tableCell";
  },
  acceptsLines: !1
}, a_e = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !1
}, xs = 4, am = 9, im = 62, i_e = 60, om = 32, sm = 91, lm = /[^ \t\f\v\r\n]/, o_e = /^(?:`{3,}|~{3,})(?= *$)/;
function bd(t) {
  for (var e = t; e; ) {
    if (e.lastLineBlank)
      return !0;
    var r = e.type;
    if (!e.lastLineChecked && (r === "list" || r === "item"))
      e.lastLineChecked = !0, e = e.lastChild;
    else {
      e.lastLineChecked = !0;
      break;
    }
  }
  return !1;
}
function rn(t, e) {
  return e < t.length ? t.charCodeAt(e) : -1;
}
function um(t) {
  return !lm.test(t);
}
function Mi(t) {
  return t === om || t === am;
}
var s_e = /^\$\$$/, l_e = {
  continue: function(t, e) {
    var r = t.currentLine, n = r.match(s_e);
    if (n)
      return t.lastLineLength = n[0].length, t.finalize(e, t.lineNumber), 2;
    for (var a = e.offset; a > 0 && Mi(rn(r, t.offset)); )
      t.advanceOffset(1, !0), a--;
    return 0;
  },
  finalize: function(t, e) {
    if (e.stringContent !== null) {
      var r = e.stringContent, n = r.indexOf(`
`), a = r.slice(0, n), i = r.slice(n + 1), o = a.match(/^(\s*)(.*)/);
      e.info = to(o[2].trim()), e.literal = i, e.stringContent = null;
    }
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, cm = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, u_e = {
  continue: function() {
    return 0;
  },
  finalize: function() {
  },
  canContain: function(t) {
    return t !== "item";
  },
  acceptsLines: !1
}, c_e = {
  continue: function() {
    return 0;
  },
  finalize: function(t, e) {
    for (var r = e.firstChild; r; ) {
      if (bd(r) && r.next) {
        e.listData.tight = !1;
        break;
      }
      for (var n = r.firstChild; n; ) {
        if (bd(n) && (r.next || n.next)) {
          e.listData.tight = !1;
          break;
        }
        n = n.next;
      }
      r = r.next;
    }
  },
  canContain: function(t) {
    return t === "item";
  },
  acceptsLines: !1
}, f_e = {
  continue: function(t) {
    var e = t.currentLine;
    if (!t.indented && rn(e, t.nextNonspace) === im)
      t.advanceNextNonspace(), t.advanceOffset(1, !1), Mi(rn(e, t.offset)) && t.advanceOffset(1, !0);
    else
      return 1;
    return 0;
  },
  finalize: function() {
  },
  canContain: function(t) {
    return t !== "item";
  },
  acceptsLines: !1
}, v_e = {
  continue: function(t, e) {
    if (t.blank) {
      if (e.firstChild === null)
        return 1;
      t.advanceNextNonspace();
    } else if (t.indent >= e.listData.markerOffset + e.listData.padding)
      t.advanceOffset(e.listData.markerOffset + e.listData.padding, !0);
    else
      return 1;
    return 0;
  },
  finalize: ZFe,
  canContain: function(t) {
    return t !== "item";
  },
  acceptsLines: !1
}, d_e = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !1
}, p_e = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !1
}, h_e = {
  continue: function(t, e) {
    var r = t.currentLine, n = t.indent;
    if (e.isFenced) {
      var a = n <= 3 && r.charAt(t.nextNonspace) === e.fenceChar && r.slice(t.nextNonspace).match(o_e);
      if (a && a[0].length >= e.fenceLength)
        return t.lastLineLength = t.offset + n + a[0].length, t.finalize(e, t.lineNumber), 2;
      for (var i = e.fenceOffset; i > 0 && Mi(rn(r, t.offset)); )
        t.advanceOffset(1, !0), i--;
    } else if (n >= xs)
      t.advanceOffset(xs, !0);
    else if (t.blank)
      t.advanceNextNonspace();
    else
      return 1;
    return 0;
  },
  finalize: function(t, e) {
    var r;
    if (e.stringContent !== null) {
      if (e.isFenced) {
        var n = e.stringContent, a = n.indexOf(`
`), i = n.slice(0, a), o = n.slice(a + 1), u = i.match(/^(\s*)(.*)/);
        e.infoPadding = u[1].length, e.info = to(u[2].trim()), e.literal = o;
      } else
        e.literal = (r = e.stringContent) === null || r === void 0 ? void 0 : r.replace(/(\n *)+$/, `
`);
      e.stringContent = null;
    }
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, m_e = {
  continue: function(t, e) {
    return t.blank && (e.htmlBlockType === 6 || e.htmlBlockType === 7) ? 1 : 0;
  },
  finalize: function(t, e) {
    var r;
    e.literal = ((r = e.stringContent) === null || r === void 0 ? void 0 : r.replace(/(\n *)+$/, "")) || null, e.stringContent = null;
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, g_e = {
  continue: function(t) {
    return t.blank ? 1 : 0;
  },
  finalize: function(t, e) {
    if (e.stringContent !== null) {
      for (var r, n = !1; rn(e.stringContent, 0) === sm && (r = t.inlineParser.parseReference(e, t.refMap)); )
        e.stringContent = e.stringContent.slice(r), n = !0;
      n && um(e.stringContent) && e.unlink();
    }
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, y_e = cm, b_e = cm, gi = {
  document: u_e,
  list: c_e,
  blockQuote: f_e,
  item: v_e,
  heading: d_e,
  thematicBreak: p_e,
  codeBlock: h_e,
  htmlBlock: m_e,
  paragraph: g_e,
  table: QFe,
  tableBody: XFe,
  tableHead: e_e,
  tableRow: n_e,
  tableCell: a_e,
  tableDelimRow: t_e,
  tableDelimCell: r_e,
  refDef: y_e,
  customBlock: l_e,
  frontMatter: b_e
};
function tc(t) {
  for (var e = 0, r = 0, n = [], a = 0; a < t.length; a += 1)
    if (t[a] === "|" && t[a - 1] !== "\\") {
      var i = t.substring(e, a);
      e === 0 && ld(i) ? r = a + 1 : n.push(i), e = a + 1;
    }
  if (e < t.length) {
    var i = t.substring(e, t.length);
    ld(i) || n.push(i);
  }
  return [r, n];
}
function rc(t, e, r, n) {
  for (var a = [], i = 0, o = e; i < o.length; i++) {
    var u = o[i], m = u.match(/^[ \t]+/), y = m ? m[0].length : 0, C = void 0, T = void 0;
    if (y === u.length)
      y = 0, C = 0, T = "";
    else {
      var x = u.match(/[ \t]+$/);
      C = x ? x[0].length : 0, T = u.slice(y, u.length - C);
    }
    var M = n + y, P = tr(t, [
      [r, n],
      [r, n + u.length - 1]
    ]);
    P.stringContent = T.replace(/\\\|/g, "|"), P.startIdx = a.length, P.endIdx = a.length, P.lineOffsets = [M - 1], P.paddingLeft = y, P.paddingRight = C, a.push(P), n += u.length + 1;
  }
  return a;
}
function k_e(t) {
  var e = null, r = t.stringContent, n = r[0], a = r[r.length - 1];
  return a === ":" ? e = n === ":" ? "center" : "right" : n === ":" && (e = "left"), { align: e };
}
var w_e = function(t, e) {
  var r = e.stringContent;
  if (e.type === "paragraph" && !t.indented && !t.blank) {
    var n = r.length - 1, a = r.lastIndexOf(`
`, n - 1) + 1, i = r.slice(a, n), o = t.currentLine.slice(t.nextNonspace), u = tc(i), m = u[0], y = u[1], C = tc(o), T = C[0], x = C[1], M = /^[ \t]*:?-+:?[ \t]*$/;
    if (
      // not checking if the number of header cells and delimiter cells are the same
      // to consider the case of merged-column (via plugin)
      !y.length || !x.length || x.some(function(Se) {
        return !M.test(Se);
      }) || // to prevent to regard setTextHeading as tabel delim cell with 'disallowDeepHeading' option
      x.length === 1 && o.indexOf("|") !== 0
    )
      return 0;
    var P = e.lineOffsets, q = t.lineNumber - 1, _ = Es(P) + 1, K = tr("table", [
      [q, _],
      [t.lineNumber, t.offset]
    ]);
    if (K.columns = x.map(function() {
      return { align: null };
    }), e.insertAfter(K), P.length === 1)
      e.unlink();
    else {
      e.stringContent = r.slice(0, a);
      var X = r.lastIndexOf(`
`, a - 2) + 1, ie = a - X - 1;
      t.lastLineLength = P[P.length - 2] + ie, t.finalize(e, q - 1);
    }
    t.advanceOffset(t.currentLine.length - t.offset, !1);
    var ee = tr("tableHead", [
      [q, _],
      [t.lineNumber, t.offset]
    ]);
    K.appendChild(ee);
    var oe = tr("tableRow", [
      [q, _],
      [q, _ + i.length - 1]
    ]), ue = tr("tableDelimRow", [
      [t.lineNumber, t.nextNonspace + 1],
      [t.lineNumber, t.offset]
    ]);
    ee.appendChild(oe), ee.appendChild(ue), rc("tableCell", y, q, _ + m).forEach(function(Se) {
      oe.appendChild(Se);
    });
    var pe = rc("tableDelimCell", x, t.lineNumber, t.nextNonspace + 1 + T);
    return pe.forEach(function(Se) {
      ue.appendChild(Se);
    }), K.columns = pe.map(k_e), t.tip = K, 2;
  }
  return 0;
}, C_e = function(t, e) {
  if (e.type !== "table" && e.type !== "tableBody" || !t.blank && t.currentLine.indexOf("|") === -1)
    return 0;
  if (t.advanceOffset(t.currentLine.length - t.offset, !1), t.blank) {
    var r = e;
    return e.type === "tableBody" && (r = e.parent, t.finalize(e, t.lineNumber - 1)), t.finalize(r, t.lineNumber - 1), 0;
  }
  var n = e;
  e.type === "table" && (n = t.addChild("tableBody", t.nextNonspace), n.stringContent = null);
  var a = tr("tableRow", [
    [t.lineNumber, t.nextNonspace + 1],
    [t.lineNumber, t.currentLine.length]
  ]);
  n.appendChild(a);
  var i = n.parent, o = t.currentLine.slice(t.nextNonspace), u = tc(o), m = u[0], y = u[1];
  return rc("tableCell", y, t.lineNumber, t.nextNonspace + 1 + m).forEach(function(C, T) {
    T >= i.columns.length && (C.ignored = !0), a.appendChild(C);
  }), 2;
}, T_e = /^(\$\$)(\s*[a-zA-Z])+/, S_e = /^(\$\$)(\s*[a-zA-Z])+.*(\$\$)/, E_e = function(t) {
  var e;
  if (!t.indented && !S_e.test(t.currentLine) && (e = t.currentLine.match(T_e))) {
    var r = e[1].length;
    t.closeUnmatchedBlocks();
    var n = t.addChild("customBlock", t.nextNonspace);
    return n.syntaxLength = r, n.offset = t.indent, t.advanceNextNonspace(), t.advanceOffset(r, !1), 2;
  }
  return 0;
}, x_e = /^`{3,}(?!.*`)|^~{3,}/, A_e = [
  /./,
  /^<(?:script|pre|style)(?:\s|>|$)/i,
  /^<!--/,
  /^<[?]/,
  /^<![A-Z]/,
  /^<!\[CDATA\[/,
  /^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[123456]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|[/]?[>]|$)/i,
  new RegExp("^(?:" + rm + "|" + nm + ")\\s*$", "i")
], M_e = /^(?:=+|-+)[ \t]*$/, L_e = /^#{1,6}(?:[ \t]+|$)/, O_e = /^(?:(?:\*[ \t]*){3,}|(?:_[ \t]*){3,}|(?:-[ \t]*){3,})[ \t]*$/, fm = /^[*+-]/, vm = /^(\d{1,9})([.)])/;
function D_e(t, e) {
  var r = t.currentLine.slice(t.nextNonspace), n, a, i = {
    type: "bullet",
    tight: !0,
    bulletChar: "",
    start: 0,
    delimiter: "",
    padding: 0,
    markerOffset: t.indent,
    // GFM: Task List Item
    task: !1,
    checked: !1
  };
  if (t.indent >= 4)
    return null;
  if (n = r.match(fm))
    i.type = "bullet", i.bulletChar = n[0][0];
  else if ((n = r.match(vm)) && (e.type !== "paragraph" || n[1] === "1"))
    i.type = "ordered", i.start = parseInt(n[1], 10), i.delimiter = n[2];
  else
    return null;
  if (a = rn(t.currentLine, t.nextNonspace + n[0].length), !(a === -1 || a === am || a === om) || e.type === "paragraph" && !t.currentLine.slice(t.nextNonspace + n[0].length).match(lm))
    return null;
  t.advanceNextNonspace(), t.advanceOffset(n[0].length, !0);
  var o = t.column, u = t.offset;
  do
    t.advanceOffset(1, !0), a = rn(t.currentLine, t.offset);
  while (t.column - o < 5 && Mi(a));
  var m = rn(t.currentLine, t.offset) === -1, y = t.column - o;
  return y >= 5 || y < 1 || m ? (i.padding = n[0].length + 1, t.column = o, t.offset = u, Mi(rn(t.currentLine, t.offset)) && t.advanceOffset(1, !0)) : i.padding = n[0].length + y, i;
}
function N_e(t, e) {
  return t.type === e.type && t.delimiter === e.delimiter && t.bulletChar === e.bulletChar;
}
function dm(t, e) {
  return t.options.disallowDeepHeading && (e.type === "blockQuote" || e.type === "item");
}
var R_e = function(t) {
  return !t.indented && rn(t.currentLine, t.nextNonspace) === im ? (t.advanceNextNonspace(), t.advanceOffset(1, !1), Mi(rn(t.currentLine, t.offset)) && t.advanceOffset(1, !0), t.closeUnmatchedBlocks(), t.addChild("blockQuote", t.nextNonspace), 1) : 0;
}, I_e = function(t, e) {
  var r;
  if (!t.indented && // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option
  !dm(t, e) && (r = t.currentLine.slice(t.nextNonspace).match(L_e))) {
    t.advanceNextNonspace(), t.advanceOffset(r[0].length, !1), t.closeUnmatchedBlocks();
    var n = t.addChild("heading", t.nextNonspace);
    return n.level = r[0].trim().length, n.headingType = "atx", n.stringContent = t.currentLine.slice(t.offset).replace(/^[ \t]*#+[ \t]*$/, "").replace(/[ \t]+#+[ \t]*$/, ""), t.advanceOffset(t.currentLine.length - t.offset), 2;
  }
  return 0;
}, P_e = function(t) {
  var e;
  if (!t.indented && (e = t.currentLine.slice(t.nextNonspace).match(x_e))) {
    var r = e[0].length;
    t.closeUnmatchedBlocks();
    var n = t.addChild("codeBlock", t.nextNonspace);
    return n.isFenced = !0, n.fenceLength = r, n.fenceChar = e[0][0], n.fenceOffset = t.indent, t.advanceNextNonspace(), t.advanceOffset(r, !1), 2;
  }
  return 0;
}, B_e = function(t, e) {
  if (!t.indented && rn(t.currentLine, t.nextNonspace) === i_e) {
    var r = t.currentLine.slice(t.nextNonspace), n = t.options.disallowedHtmlBlockTags, a = void 0;
    for (a = 1; a <= 7; a++) {
      var i = r.match(A_e[a]);
      if (i) {
        if (a === 7) {
          if (e.type === "paragraph")
            return 0;
          if (n.length > 0) {
            var o = new RegExp("</?(?:" + n.join("|") + ")", "i");
            if (o.test(i[0]))
              return 0;
          }
        }
        t.closeUnmatchedBlocks();
        var u = t.addChild("htmlBlock", t.offset);
        return u.htmlBlockType = a, 2;
      }
    }
  }
  return 0;
}, q_e = function(t, e) {
  var r;
  if (e.stringContent !== null && !t.indented && e.type === "paragraph" && // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option
  !dm(t, e.parent) && (r = t.currentLine.slice(t.nextNonspace).match(M_e))) {
    t.closeUnmatchedBlocks();
    for (var n = void 0; rn(e.stringContent, 0) === sm && (n = t.inlineParser.parseReference(e, t.refMap)); )
      e.stringContent = e.stringContent.slice(n);
    if (e.stringContent.length > 0) {
      var a = tr("heading", e.sourcepos);
      return a.level = r[0][0] === "=" ? 1 : 2, a.headingType = "setext", a.stringContent = e.stringContent, e.insertAfter(a), e.unlink(), t.tip = a, t.advanceOffset(t.currentLine.length - t.offset, !1), 2;
    }
    return 0;
  }
  return 0;
}, F_e = function(t) {
  return !t.indented && O_e.test(t.currentLine.slice(t.nextNonspace)) ? (t.closeUnmatchedBlocks(), t.addChild("thematicBreak", t.nextNonspace), t.advanceOffset(t.currentLine.length - t.offset, !1), 2) : 0;
}, __e = function(t, e) {
  var r, n = e;
  return (!t.indented || e.type === "list") && (r = D_e(t, n)) ? (t.closeUnmatchedBlocks(), (t.tip.type !== "list" || !N_e(n.listData, r)) && (n = t.addChild("list", t.nextNonspace), n.listData = r), n = t.addChild("item", t.nextNonspace), n.listData = r, 1) : 0;
}, H_e = function(t) {
  return t.indented && t.tip.type !== "paragraph" && !t.blank ? (t.advanceOffset(xs, !0), t.closeUnmatchedBlocks(), t.addChild("codeBlock", t.offset), 2) : 0;
}, Au = [
  R_e,
  I_e,
  P_e,
  B_e,
  q_e,
  F_e,
  __e,
  H_e,
  w_e,
  C_e,
  E_e
], pm = /^(-{3}|\+{3}|;{3})$/, U_e = function(t, e) {
  var r = t.currentLine, n = t.lineNumber, a = t.indented;
  if (n === 1 && !a && e.type === "document" && pm.test(r)) {
    t.closeUnmatchedBlocks();
    var i = t.addChild("frontMatter", t.nextNonspace);
    return i.stringContent = r, t.advanceNextNonspace(), t.advanceOffset(r.length, !1), 2;
  }
  return 0;
}, z_e = {
  continue: function(t, e) {
    var r = t.currentLine, n = r.match(pm);
    return e.type === "frontMatter" && n ? (e.stringContent += r, t.lastLineLength = n[0].length, t.finalize(e, t.lineNumber), 2) : 0;
  },
  finalize: function(t, e) {
    e.stringContent !== null && (e.literal = e.stringContent, e.stringContent = null);
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, $_e = [
  /./,
  /<\/(?:script|pre|style)>/i,
  /-->/,
  /\?>/,
  />/,
  /\]\]>/
], V_e = /^[#`~*+_=<>0-9-;$]/, W_e = /\r\n|\n|\r/;
function Mu() {
  return tr("document", [
    [1, 1],
    [0, 0]
  ]);
}
var j_e = {
  smart: !1,
  tagFilter: !1,
  extendedAutolinks: !1,
  disallowedHtmlBlockTags: [],
  referenceDefinition: !1,
  disallowDeepHeading: !1,
  customParser: null,
  frontMatter: !1
}, G_e = (
  /** @class */
  function() {
    function t(e) {
      this.options = Er(Er({}, j_e), e), this.doc = Mu(), this.tip = this.doc, this.oldtip = this.doc, this.lineNumber = 0, this.offset = 0, this.column = 0, this.nextNonspace = 0, this.nextNonspaceColumn = 0, this.indent = 0, this.currentLine = "", this.indented = !1, this.blank = !1, this.partiallyConsumedTab = !1, this.allClosed = !0, this.lastMatchedContainer = this.doc, this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.lastLineLength = 0, this.lines = [], this.options.frontMatter && (gi.frontMatter = z_e, Au.unshift(U_e)), this.inlineParser = new JFe(this.options);
    }
    return t.prototype.advanceOffset = function(e, r) {
      r === void 0 && (r = !1);
      for (var n = this.currentLine, a, i, o; e > 0 && (o = n[this.offset]); )
        o === "	" ? (a = 4 - this.column % 4, r ? (this.partiallyConsumedTab = a > e, i = a > e ? e : a, this.column += i, this.offset += this.partiallyConsumedTab ? 0 : 1, e -= i) : (this.partiallyConsumedTab = !1, this.column += a, this.offset += 1, e -= 1)) : (this.partiallyConsumedTab = !1, this.offset += 1, this.column += 1, e -= 1);
    }, t.prototype.advanceNextNonspace = function() {
      this.offset = this.nextNonspace, this.column = this.nextNonspaceColumn, this.partiallyConsumedTab = !1;
    }, t.prototype.findNextNonspace = function() {
      for (var e = this.currentLine, r = this.offset, n = this.column, a; (a = e.charAt(r)) !== ""; )
        if (a === " ")
          r++, n++;
        else if (a === "	")
          r++, n += 4 - n % 4;
        else
          break;
      this.blank = a === `
` || a === "\r" || a === "", this.nextNonspace = r, this.nextNonspaceColumn = n, this.indent = this.nextNonspaceColumn - this.column, this.indented = this.indent >= xs;
    }, t.prototype.addLine = function() {
      if (this.partiallyConsumedTab) {
        this.offset += 1;
        var e = 4 - this.column % 4;
        this.tip.stringContent += Zu(" ", e);
      }
      this.tip.lineOffsets ? this.tip.lineOffsets.push(this.offset) : this.tip.lineOffsets = [this.offset], this.tip.stringContent += this.currentLine.slice(this.offset) + `
`;
    }, t.prototype.addChild = function(e, r) {
      for (; !gi[this.tip.type].canContain(e); )
        this.finalize(this.tip, this.lineNumber - 1);
      var n = r + 1, a = tr(e, [
        [this.lineNumber, n],
        [0, 0]
      ]);
      return a.stringContent = "", this.tip.appendChild(a), this.tip = a, a;
    }, t.prototype.closeUnmatchedBlocks = function() {
      if (!this.allClosed) {
        for (; this.oldtip !== this.lastMatchedContainer; ) {
          var e = this.oldtip.parent;
          this.finalize(this.oldtip, this.lineNumber - 1), this.oldtip = e;
        }
        this.allClosed = !0;
      }
    }, t.prototype.finalize = function(e, r) {
      var n = e.parent;
      e.open = !1, e.sourcepos[1] = [r, this.lastLineLength], gi[e.type].finalize(this, e), this.tip = n;
    }, t.prototype.processInlines = function(e) {
      var r, n = this.options.customParser, a = e.walker();
      for (this.inlineParser.refMap = this.refMap, this.inlineParser.refLinkCandidateMap = this.refLinkCandidateMap, this.inlineParser.refDefCandidateMap = this.refDefCandidateMap, this.inlineParser.options = this.options; r = a.next(); ) {
        var i = r.node, o = r.entering, u = i.type;
        n && n[u] && n[u](i, { entering: o, options: this.options }), !o && (u === "paragraph" || u === "heading" || u === "tableCell" && !i.ignored) && this.inlineParser.parse(i);
      }
    }, t.prototype.incorporateLine = function(e) {
      var r = this.doc;
      this.oldtip = this.tip, this.offset = 0, this.column = 0, this.blank = !1, this.partiallyConsumedTab = !1, this.lineNumber += 1, e.indexOf("\0") !== -1 && (e = e.replace(/\0/g, "�")), this.currentLine = e;
      for (var n = !0, a; (a = r.lastChild) && a.open; ) {
        switch (r = a, this.findNextNonspace(), gi[r.type].continue(this, r)) {
          case 0:
            break;
          case 1:
            n = !1;
            break;
          case 2:
            this.lastLineLength = e.length;
            return;
          default:
            throw new Error("continue returned illegal value, must be 0, 1, or 2");
        }
        if (!n) {
          r = r.parent;
          break;
        }
      }
      this.allClosed = r === this.oldtip, this.lastMatchedContainer = r;
      for (var i = r.type !== "paragraph" && gi[r.type].acceptsLines, o = Au.length; !i; ) {
        if (this.findNextNonspace(), r.type !== "table" && r.type !== "tableBody" && r.type !== "paragraph" && !this.indented && !V_e.test(e.slice(this.nextNonspace))) {
          this.advanceNextNonspace();
          break;
        }
        for (var u = 0; u < o; ) {
          var m = Au[u](this, r);
          if (m === 1) {
            r = this.tip;
            break;
          } else if (m === 2) {
            r = this.tip, i = !0;
            break;
          } else
            u++;
        }
        if (u === o) {
          this.advanceNextNonspace();
          break;
        }
      }
      if (!this.allClosed && !this.blank && this.tip.type === "paragraph")
        this.addLine();
      else {
        this.closeUnmatchedBlocks(), this.blank && r.lastChild && (r.lastChild.lastLineBlank = !0);
        for (var y = r.type, C = this.blank && !(y === "blockQuote" || Xh(r) && r.isFenced || y === "item" && !r.firstChild && r.sourcepos[0][0] === this.lineNumber), T = r; T; )
          T.lastLineBlank = C, T = T.parent;
        gi[y].acceptsLines ? (this.addLine(), eFe(r) && r.htmlBlockType >= 1 && r.htmlBlockType <= 5 && $_e[r.htmlBlockType].test(this.currentLine.slice(this.offset)) && (this.lastLineLength = e.length, this.finalize(r, this.lineNumber))) : this.offset < e.length && !this.blank && (r = this.addChild("paragraph", this.offset), this.advanceNextNonspace(), this.addLine());
      }
      this.lastLineLength = e.length;
    }, t.prototype.parse = function(e, r) {
      this.doc = Mu(), this.tip = this.doc, this.lineNumber = 0, this.lastLineLength = 0, this.offset = 0, this.column = 0, this.lastMatchedContainer = this.doc, this.currentLine = "";
      var n = e.split(W_e), a = n.length;
      this.lines = r || n, this.options.referenceDefinition && this.clearRefMaps(), e.charCodeAt(e.length - 1) === ec && (a -= 1);
      for (var i = 0; i < a; i++)
        this.incorporateLine(n[i]);
      for (; this.tip; )
        this.finalize(this.tip, a);
      return this.processInlines(this.doc), this.doc;
    }, t.prototype.partialParseStart = function(e, r) {
      this.doc = Mu(), this.tip = this.doc, this.lineNumber = e - 1, this.lastLineLength = 0, this.offset = 0, this.column = 0, this.lastMatchedContainer = this.doc, this.currentLine = "";
      for (var n = r.length, a = 0; a < n; a++)
        this.incorporateLine(r[a]);
      return this.doc;
    }, t.prototype.partialParseExtends = function(e) {
      for (var r = 0; r < e.length; r++)
        this.incorporateLine(e[r]);
    }, t.prototype.partialParseFinish = function() {
      for (; this.tip; )
        this.finalize(this.tip, this.lineNumber);
      this.processInlines(this.doc);
    }, t.prototype.setRefMaps = function(e, r, n) {
      this.refMap = e, this.refLinkCandidateMap = r, this.refDefCandidateMap = n;
    }, t.prototype.clearRefMaps = function() {
      [this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function(e) {
        LFe(e);
      });
    }, t;
  }()
);
function kd(t, e) {
  return t[0] < e[0] ? 1 : t[0] > e[0] ? -1 : t[1] < e[1] ? 1 : t[1] > e[1] ? -1 : 0;
}
function K_e(t, e) {
  var r = t[0], n = t[1];
  return kd(n, e) === 1 ? 1 : kd(r, e) === -1 ? -1 : 0;
}
function J_e(t, e) {
  if (!(t.parent !== e.parent || t === e)) {
    for (var r = t.next; r && r !== e; ) {
      for (var n = r.next, a = 0, i = ["parent", "prev", "next"]; a < i.length; a++) {
        var o = i[a];
        r[o] && (Qu(r[o].id), r[o] = null);
      }
      r = n;
    }
    t.next = e.next, e.next ? e.next.prev = t : t.parent.lastChild = t;
  }
}
function Y_e(t) {
  for (var e = [], r = t.firstChild; r; )
    e.push(r), r = r.next;
  return e;
}
function wd(t, e) {
  for (var r = 0, n = e; r < n.length; r++) {
    var a = n[r];
    t.insertBefore(a);
  }
}
function Z_e(t, e) {
  for (var r = e.length - 1; r >= 0; r -= 1)
    t.prependChild(e[r]);
}
function Q_e(t, e) {
  if (!(!t || !t.parent || e === 0)) {
    var r = t.parent.walker();
    r.resumeAt(t, !0);
    for (var n; n = r.next(); ) {
      var a = n.node, i = n.entering;
      i && (a.sourcepos[0][0] += e, a.sourcepos[1][0] += e);
    }
  }
}
function hm(t, e) {
  var r = t[0], n = t[1];
  return n[0] < e ? 1 : r[0] > e ? -1 : 0;
}
function Xo(t, e) {
  for (var r = t.firstChild; r; ) {
    var n = hm(r.sourcepos, e);
    if (n === 0)
      return r;
    if (n === -1)
      return r.prev || r;
    r = r.next;
  }
  return t.lastChild;
}
function X_e(t) {
  for (; t.lastChild; )
    t = t.lastChild;
  return t;
}
function eHe(t) {
  for (; t.parent && t.parent.type !== "document" && t.parent.sourcepos[0][0] === t.sourcepos[0][0]; )
    t = t.parent;
  return t;
}
function tHe(t, e) {
  for (var r = t.firstChild, n = null; r; ) {
    var a = hm(r.sourcepos, e);
    if (a === 0) {
      if (r.sourcepos[0][0] === e || !r.firstChild)
        return r;
      n = r, r = r.firstChild;
    } else {
      if (a === -1)
        break;
      n = r, r = r.next;
    }
  }
  return n ? eHe(X_e(n)) : null;
}
function rHe(t, e) {
  for (var r = t, n = null; r; ) {
    var a = K_e(r.sourcepos, e);
    if (a === 0)
      if (r.firstChild)
        n = r, r = r.firstChild;
      else
        return r;
    else {
      if (a === -1)
        return n;
      if (r.next)
        r = r.next;
      else
        return n;
    }
  }
  return r;
}
function mm(t) {
  return Uqe(t) || null;
}
function Lu(t, e, r) {
  if (r === void 0 && (r = null), e)
    for (var n = e.walker(); e && e !== r; ) {
      t(e);
      var a = n.next();
      if (a)
        e = a.node;
      else
        break;
    }
}
function nHe(t) {
  var e = mm(t);
  if (!e)
    return !0;
  for (; e && e.type !== "document"; ) {
    if (!e.parent && !e.prev && !e.next)
      return !0;
    e = e.parent;
  }
  return !1;
}
var Cd = /\r\n|\n|\r/;
function aHe(t) {
  var e = t.match(/^[ \t]+/);
  if (e && (e[0].length >= 2 || /\t/.test(e[0])))
    return !0;
  var r = e ? t.slice(e.length) : t;
  return fm.test(r) || vm.test(r);
}
function iHe(t) {
  return !um(t) && t.indexOf("|") !== -1;
}
function nc(t) {
  var e = t.id, r = t.title, n = t.sourcepos, a = t.dest;
  return {
    id: e,
    title: r,
    sourcepos: n,
    unlinked: !1,
    destination: a
  };
}
var gm = (
  /** @class */
  function() {
    function t(e, r) {
      this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.referenceDefinition = !!(r != null && r.referenceDefinition), this.parser = new G_e(r), this.parser.setRefMaps(this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap), this.eventHandlerMap = { change: [] }, e = e || "", this.lineTexts = e.split(Cd), this.root = this.parser.parse(e, this.lineTexts);
    }
    return t.prototype.updateLineTexts = function(e, r, n) {
      var a, i = e[0], o = e[1], u = r[0], m = r[1], y = n.split(Cd), C = y.length, T = this.lineTexts[i - 1], x = this.lineTexts[u - 1];
      y[0] = T.slice(0, o - 1) + y[0], y[C - 1] = y[C - 1] + x.slice(m - 1);
      var M = u - i + 1;
      return (a = this.lineTexts).splice.apply(a, Ju([i - 1, M], y)), C - M;
    }, t.prototype.updateRootNodeState = function() {
      if (this.lineTexts.length === 1 && this.lineTexts[0] === "") {
        this.root.lastLineBlank = !0, this.root.sourcepos = [
          [1, 1],
          [1, 0]
        ];
        return;
      }
      this.root.lastChild && (this.root.lastLineBlank = this.root.lastChild.lastLineBlank);
      for (var e = this.lineTexts, r = e.length - 1; e[r] === ""; )
        r -= 1;
      e.length - 2 > r && (r += 1), this.root.sourcepos[1] = [r + 1, e[r].length];
    }, t.prototype.replaceRangeNodes = function(e, r, n) {
      e ? (wd(e, n), J_e(e, r), [e.id, r.id].forEach(function(a) {
        return Qu(a);
      }), e.unlink()) : r ? (wd(r, n), Qu(r.id), r.unlink()) : Z_e(this.root, n);
    }, t.prototype.getNodeRange = function(e, r) {
      var n = Xo(this.root, e[0]), a = Xo(this.root, r[0]);
      return a && a.next && r[0] + 1 === a.next.sourcepos[0][0] && (a = a.next), [n, a];
    }, t.prototype.trigger = function(e, r) {
      this.eventHandlerMap[e].forEach(function(n) {
        n(r);
      });
    }, t.prototype.extendEndLine = function(e) {
      for (; this.lineTexts[e] === ""; )
        e += 1;
      return e;
    }, t.prototype.parseRange = function(e, r, n, a) {
      e && e.prev && (ud(e.prev) && aHe(this.lineTexts[n - 1]) || rFe(e.prev) && iHe(this.lineTexts[n - 1])) && (e = e.prev, n = e.sourcepos[0][0]);
      for (var i = this.lineTexts.slice(n - 1, a), o = this.parser.partialParseStart(n, i), u = r ? r.next : this.root.firstChild, m = o.lastChild, y = m && Xh(m) && m.open, C = m && em(m) && m.open, T = m && ud(m); (y || C) && u || T && u && (u.type === "list" || u.sourcepos[0][1] >= 2); ) {
        var x = this.extendEndLine(u.sourcepos[1][0]);
        this.parser.partialParseExtends(this.lineTexts.slice(a, x)), e || (e = r), r = u, a = x, u = u.next;
      }
      this.parser.partialParseFinish();
      var M = Y_e(o);
      return { newNodes: M, extStartNode: e, extEndNode: r };
    }, t.prototype.getRemovedNodeRange = function(e, r) {
      return !e || e && hi(e) || r && hi(r) ? null : {
        id: [e.id, r.id],
        line: [e.sourcepos[0][0] - 1, r.sourcepos[1][0] - 1]
      };
    }, t.prototype.markDeletedRefMap = function(e, r) {
      var n = this;
      if (!mi(this.refMap)) {
        var a = function(i) {
          if (hi(i)) {
            var o = n.refMap[i.label];
            o && i.id === o.id && (o.unlinked = !0);
          }
        };
        e && Lu(a, e.parent, r), r && Lu(a, r);
      }
    }, t.prototype.replaceWithNewRefDefState = function(e) {
      var r = this;
      if (!mi(this.refMap)) {
        var n = function(a) {
          if (hi(a)) {
            var i = a.label, o = r.refMap[i];
            (!o || o.unlinked) && (r.refMap[i] = nc(a));
          }
        };
        e.forEach(function(a) {
          Lu(n, a);
        });
      }
    }, t.prototype.replaceWithRefDefCandidate = function() {
      var e = this;
      mi(this.refDefCandidateMap) || Yo(this.refDefCandidateMap, function(r, n) {
        var a = n.label, i = n.sourcepos, o = e.refMap[a];
        (!o || o.unlinked || o.sourcepos[0][0] > i[0][0]) && (e.refMap[a] = nc(n));
      });
    }, t.prototype.getRangeWithRefDef = function(e, r, n, a, i) {
      if (this.referenceDefinition && !mi(this.refMap)) {
        var o = Xo(this.root, e - 1), u = Xo(this.root, r + 1);
        o && hi(o) && o !== n && o !== a && (n = o, e = n.sourcepos[0][0]), u && hi(u) && u !== n && u !== a && (a = u, r = this.extendEndLine(a.sourcepos[1][0] + i));
      }
      return [n, a, e, r];
    }, t.prototype.parse = function(e, r, n) {
      n === void 0 && (n = 0);
      var a = this.getNodeRange(e, r), i = a[0], o = a[1], u = i ? Math.min(i.sourcepos[0][0], e[0]) : e[0], m = this.extendEndLine((o ? Math.max(o.sourcepos[1][0], r[0]) : r[0]) + n), y = this.parseRange.apply(this, this.getRangeWithRefDef(u, m, i, o, n)), C = y.newNodes, T = y.extStartNode, x = y.extEndNode, M = this.getRemovedNodeRange(T, x), P = x ? x.next : this.root.firstChild;
      return this.referenceDefinition ? (this.markDeletedRefMap(T, x), this.replaceRangeNodes(T, x, C), this.replaceWithNewRefDefState(C)) : this.replaceRangeNodes(T, x, C), { nodes: C, removedNodeRange: M, nextNode: P };
    }, t.prototype.parseRefLink = function() {
      var e = this, r = [];
      return mi(this.refMap) || Yo(this.refMap, function(n, a) {
        a.unlinked && delete e.refMap[n], Yo(e.refLinkCandidateMap, function(i, o) {
          var u = o.node, m = o.refLabel;
          m === n && r.push(e.parse(u.sourcepos[0], u.sourcepos[1]));
        });
      }), r;
    }, t.prototype.removeUnlinkedCandidate = function() {
      mi(this.refDefCandidateMap) || [this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function(e) {
        Yo(e, function(r) {
          nHe(r) && delete e[r];
        });
      });
    }, t.prototype.editMarkdown = function(e, r, n) {
      var a = this.updateLineTexts(e, r, n), i = this.parse(e, r, a), o = MFe(i, "nextNode");
      Q_e(i.nextNode, a), this.updateRootNodeState();
      var u = [o];
      return this.referenceDefinition && (this.removeUnlinkedCandidate(), this.replaceWithRefDefCandidate(), u = u.concat(this.parseRefLink())), this.trigger("change", u), u;
    }, t.prototype.getLineTexts = function() {
      return this.lineTexts;
    }, t.prototype.getRootNode = function() {
      return this.root;
    }, t.prototype.findNodeAtPosition = function(e) {
      var r = rHe(this.root, e);
      return !r || r === this.root ? null : r;
    }, t.prototype.findFirstNodeAtLine = function(e) {
      return tHe(this.root, e);
    }, t.prototype.on = function(e, r) {
      this.eventHandlerMap[e].push(r);
    }, t.prototype.off = function(e, r) {
      var n = this.eventHandlerMap[e], a = n.indexOf(r);
      n.splice(a, 1);
    }, t.prototype.findNodeById = function(e) {
      return mm(e);
    }, t.prototype.removeAllNode = function() {
      zqe();
    }, t;
  }()
), oHe = [
  "title",
  "textarea",
  "style",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "script",
  "plaintext"
], Td = new RegExp("<(/?(?:" + oHe.join("|") + ")[^>]*>)", "ig");
function Sd(t) {
  return Td.test(t) ? t.replace(Td, function(e, r) {
    return "&lt;" + r;
  }) : t;
}
var Ed = {
  heading: function(t, e) {
    var r = e.entering;
    return {
      type: r ? "openTag" : "closeTag",
      tagName: "h" + t.level,
      outerNewLine: !0
    };
  },
  text: function(t) {
    return {
      type: "text",
      content: t.literal
    };
  },
  softbreak: function(t, e) {
    var r = e.options;
    return {
      type: "html",
      content: r.softbreak
    };
  },
  linebreak: function() {
    return {
      type: "html",
      content: `<br />
`
    };
  },
  emph: function(t, e) {
    var r = e.entering;
    return {
      type: r ? "openTag" : "closeTag",
      tagName: "em"
    };
  },
  strong: function(t, e) {
    var r = e.entering;
    return {
      type: r ? "openTag" : "closeTag",
      tagName: "strong"
    };
  },
  paragraph: function(t, e) {
    var r, n = e.entering, a = (r = t.parent) === null || r === void 0 ? void 0 : r.parent;
    return a && a.type === "list" && a.listData.tight ? null : {
      type: n ? "openTag" : "closeTag",
      tagName: "p",
      outerNewLine: !0
    };
  },
  thematicBreak: function() {
    return {
      type: "openTag",
      tagName: "hr",
      outerNewLine: !0,
      selfClose: !0
    };
  },
  blockQuote: function(t, e) {
    var r = e.entering;
    return {
      type: r ? "openTag" : "closeTag",
      tagName: "blockquote",
      outerNewLine: !0,
      innerNewLine: !0
    };
  },
  list: function(t, e) {
    var r = e.entering, n = t.listData, a = n.type, i = n.start, o = a === "bullet" ? "ul" : "ol", u = {};
    return o === "ol" && i !== null && i !== 1 && (u.start = i.toString()), {
      type: r ? "openTag" : "closeTag",
      tagName: o,
      attributes: u,
      outerNewLine: !0
    };
  },
  item: function(t, e) {
    var r = e.entering;
    return {
      type: r ? "openTag" : "closeTag",
      tagName: "li",
      outerNewLine: !0
    };
  },
  htmlInline: function(t, e) {
    var r = e.options, n = r.tagFilter ? Sd(t.literal) : t.literal;
    return { type: "html", content: n };
  },
  htmlBlock: function(t, e) {
    var r = e.options, n = r.tagFilter ? Sd(t.literal) : t.literal;
    return r.nodeId ? [
      { type: "openTag", tagName: "div", outerNewLine: !0 },
      { type: "html", content: n },
      { type: "closeTag", tagName: "div", outerNewLine: !0 }
    ] : { type: "html", content: n, outerNewLine: !0 };
  },
  code: function(t) {
    return [
      { type: "openTag", tagName: "code" },
      { type: "text", content: t.literal },
      { type: "closeTag", tagName: "code" }
    ];
  },
  codeBlock: function(t) {
    var e = t.info, r = e ? e.split(/\s+/) : [], n = [];
    return r.length > 0 && r[0].length > 0 && n.push("language-" + yi(r[0])), [
      { type: "openTag", tagName: "pre", outerNewLine: !0 },
      { type: "openTag", tagName: "code", classNames: n },
      { type: "text", content: t.literal },
      { type: "closeTag", tagName: "code" },
      { type: "closeTag", tagName: "pre", outerNewLine: !0 }
    ];
  },
  link: function(t, e) {
    var r = e.entering;
    if (r) {
      var n = t, a = n.title, i = n.destination;
      return {
        type: "openTag",
        tagName: "a",
        attributes: Er({ href: yi(i) }, a && { title: yi(a) })
      };
    }
    return { type: "closeTag", tagName: "a" };
  },
  image: function(t, e) {
    var r = e.getChildrenText, n = e.skipChildren, a = t, i = a.title, o = a.destination;
    return n(), {
      type: "openTag",
      tagName: "img",
      selfClose: !0,
      attributes: Er({ src: yi(o), alt: r(t) }, i && { title: yi(i) })
    };
  },
  customBlock: function(t, e, r) {
    var n = t.info.trim().toLowerCase(), a = r[n];
    if (a)
      try {
        return a(t, e);
      } catch (i) {
        console.warn("[@toast-ui/editor] - The error occurred when " + n + " block node was parsed in markdown renderer: " + i);
      }
    return [
      { type: "openTag", tagName: "div", outerNewLine: !0 },
      { type: "text", content: t.literal },
      { type: "closeTag", tagName: "div", outerNewLine: !0 }
    ];
  },
  frontMatter: function(t) {
    return [
      {
        type: "openTag",
        tagName: "div",
        outerNewLine: !0,
        // Because front matter is metadata, it should not be render.
        attributes: { style: "white-space: pre; display: none;" }
      },
      { type: "text", content: t.literal },
      { type: "closeTag", tagName: "div", outerNewLine: !0 }
    ];
  },
  customInline: function(t, e, r) {
    var n = t, a = n.info, i = n.firstChild, o = a.trim().toLowerCase(), u = r[o], m = e.entering;
    if (u)
      try {
        return u(t, e);
      } catch (y) {
        console.warn("[@toast-ui/editor] - The error occurred when " + o + " inline node was parsed in markdown renderer: " + y);
      }
    return m ? [
      { type: "openTag", tagName: "span" },
      { type: "text", content: "$$" + a + (i ? " " : "") }
    ] : [
      { type: "text", content: "$$" },
      { type: "closeTag", tagName: "span" }
    ];
  }
}, xd = {
  strike: function(t, e) {
    var r = e.entering;
    return {
      type: r ? "openTag" : "closeTag",
      tagName: "del"
    };
  },
  item: function(t, e) {
    var r = e.entering, n = t.listData, a = n.checked, i = n.task;
    if (r) {
      var o = {
        type: "openTag",
        tagName: "li",
        outerNewLine: !0
      };
      return i ? [
        o,
        {
          type: "openTag",
          tagName: "input",
          selfClose: !0,
          attributes: Er(Er({}, a && { checked: "" }), { disabled: "", type: "checkbox" })
        },
        {
          type: "text",
          content: " "
        }
      ] : o;
    }
    return {
      type: "closeTag",
      tagName: "li",
      outerNewLine: !0
    };
  },
  table: function(t, e) {
    var r = e.entering;
    return {
      type: r ? "openTag" : "closeTag",
      tagName: "table",
      outerNewLine: !0
    };
  },
  tableHead: function(t, e) {
    var r = e.entering;
    return {
      type: r ? "openTag" : "closeTag",
      tagName: "thead",
      outerNewLine: !0
    };
  },
  tableBody: function(t, e) {
    var r = e.entering;
    return {
      type: r ? "openTag" : "closeTag",
      tagName: "tbody",
      outerNewLine: !0
    };
  },
  tableRow: function(t, e) {
    var r = e.entering;
    if (r)
      return {
        type: "openTag",
        tagName: "tr",
        outerNewLine: !0
      };
    var n = [];
    if (t.lastChild)
      for (var a = t.parent.parent.columns.length, i = t.lastChild.endIdx, o = i + 1; o < a; o += 1)
        n.push({
          type: "openTag",
          tagName: "td",
          outerNewLine: !0
        }, {
          type: "closeTag",
          tagName: "td",
          outerNewLine: !0
        });
    return n.push({
      type: "closeTag",
      tagName: "tr",
      outerNewLine: !0
    }), n;
  },
  tableCell: function(t, e) {
    var r = e.entering;
    if (t.ignored)
      return {
        type: "text",
        content: ""
      };
    var n = t.parent.parent, a = n.type === "tableHead" ? "th" : "td", i = n.parent, o = i.columns[t.startIdx], u = o != null && o.align ? { align: o.align } : null;
    return r ? Er({ type: "openTag", tagName: a, outerNewLine: !0 }, u && { attributes: u }) : {
      type: "closeTag",
      tagName: a,
      outerNewLine: !0
    };
  }
}, sHe = {
  softbreak: `
`,
  gfm: !1,
  tagFilter: !1,
  nodeId: !1
};
function lHe(t) {
  for (var e = [], r = t.walker(), n = null; n = r.next(); ) {
    var a = n.node;
    a.type === "text" && e.push(a.literal);
  }
  return e.join("");
}
var $c = (
  /** @class */
  function() {
    function t(e) {
      this.buffer = [], this.options = Er(Er({}, sHe), e), this.convertors = this.createConvertors(), delete this.options.convertors;
    }
    return t.prototype.createConvertors = function() {
      var e = Er({}, Ed);
      if (this.options.gfm && (e = Er(Er({}, e), xd)), this.options.convertors) {
        var r = this.options.convertors, n = Object.keys(r), a = Er(Er({}, Ed), xd);
        n.forEach(function(i) {
          var o = e[i], u = r[i], m = Object.keys(a).indexOf(i) === -1 ? i.toLowerCase() : i;
          o ? e[m] = function(y, C, T) {
            return C.origin = function() {
              return o(y, C, T);
            }, u(y, C);
          } : e[m] = u;
        });
      }
      return e;
    }, t.prototype.getConvertors = function() {
      return this.convertors;
    }, t.prototype.getOptions = function() {
      return this.options;
    }, t.prototype.render = function(e) {
      var r = this;
      this.buffer = [];
      for (var n = e.walker(), a = null, i = function() {
        var u = a.node, m = a.entering, y = o.convertors[u.type];
        if (!y)
          return "continue";
        var C = !1, T = {
          entering: m,
          leaf: !zc(u),
          options: o.options,
          getChildrenText: lHe,
          skipChildren: function() {
            C = !0;
          }
        }, x = em(u) || nFe(u) ? y(u, T, o.convertors) : y(u, T);
        if (x) {
          var M = Array.isArray(x) ? x : [x];
          M.forEach(function(P, q) {
            P.type === "openTag" && r.options.nodeId && q === 0 && (P.attributes || (P.attributes = {}), P.attributes["data-nodeid"] = String(u.id)), r.renderHTMLNode(P);
          }), C && (n.resumeAt(u, !1), n.next());
        }
      }, o = this; a = n.next(); )
        i();
      return this.addNewLine(), this.buffer.join("");
    }, t.prototype.renderHTMLNode = function(e) {
      switch (e.type) {
        case "openTag":
        case "closeTag":
          this.renderElementNode(e);
          break;
        case "text":
          this.renderTextNode(e);
          break;
        case "html":
          this.renderRawHtmlNode(e);
          break;
      }
    }, t.prototype.generateOpenTagString = function(e) {
      var r = this, n = e.tagName, a = e.classNames, i = e.attributes;
      this.buffer.push("<" + n), a && a.length > 0 && this.buffer.push(' class="' + a.join(" ") + '"'), i && Object.keys(i).forEach(function(o) {
        var u = i[o];
        r.buffer.push(" " + o + '="' + u + '"');
      }), e.selfClose && this.buffer.push(" /"), this.buffer.push(">");
    }, t.prototype.generateCloseTagString = function(e) {
      var r = e.tagName;
      this.buffer.push("</" + r + ">");
    }, t.prototype.addNewLine = function() {
      this.buffer.length && Es(Es(this.buffer)) !== `
` && this.buffer.push(`
`);
    }, t.prototype.addOuterNewLine = function(e) {
      e.outerNewLine && this.addNewLine();
    }, t.prototype.addInnerNewLine = function(e) {
      e.innerNewLine && this.addNewLine();
    }, t.prototype.renderTextNode = function(e) {
      this.buffer.push(yi(e.content));
    }, t.prototype.renderRawHtmlNode = function(e) {
      this.addOuterNewLine(e), this.buffer.push(e.content), this.addOuterNewLine(e);
    }, t.prototype.renderElementNode = function(e) {
      e.type === "openTag" ? (this.addOuterNewLine(e), this.generateOpenTagString(e), e.selfClose ? this.addOuterNewLine(e) : this.addInnerNewLine(e)) : (this.addInnerNewLine(e), this.generateCloseTagString(e), this.addOuterNewLine(e));
    }, t;
  }()
);
/*! @license DOMPurify 2.3.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.3/LICENSE */
function uHe(t) {
  if (Array.isArray(t)) {
    for (var e = 0, r = Array(t.length); e < t.length; e++)
      r[e] = t[e];
    return r;
  } else
    return Array.from(t);
}
var cHe = Object.hasOwnProperty, Ad = Object.setPrototypeOf, fHe = Object.isFrozen, vHe = Object.getPrototypeOf, dHe = Object.getOwnPropertyDescriptor, Br = Object.freeze, oa = Object.seal, pHe = Object.create, ym = typeof Reflect < "u" && Reflect, As = ym.apply, ac = ym.construct;
As || (As = function(e, r, n) {
  return e.apply(r, n);
});
Br || (Br = function(e) {
  return e;
});
oa || (oa = function(e) {
  return e;
});
ac || (ac = function(e, r) {
  return new (Function.prototype.bind.apply(e, [null].concat(uHe(r))))();
});
var hHe = wn(Array.prototype.forEach), Md = wn(Array.prototype.pop), ji = wn(Array.prototype.push), ls = wn(String.prototype.toLowerCase), Ld = wn(String.prototype.match), ba = wn(String.prototype.replace), mHe = wn(String.prototype.indexOf), gHe = wn(String.prototype.trim), Qn = wn(RegExp.prototype.test), Od = yHe(TypeError);
function wn(t) {
  return function(e) {
    for (var r = arguments.length, n = Array(r > 1 ? r - 1 : 0), a = 1; a < r; a++)
      n[a - 1] = arguments[a];
    return As(t, e, n);
  };
}
function yHe(t) {
  return function() {
    for (var e = arguments.length, r = Array(e), n = 0; n < e; n++)
      r[n] = arguments[n];
    return ac(t, r);
  };
}
function gt(t, e) {
  Ad && Ad(t, null);
  for (var r = e.length; r--; ) {
    var n = e[r];
    if (typeof n == "string") {
      var a = ls(n);
      a !== n && (fHe(e) || (e[r] = a), n = a);
    }
    t[n] = !0;
  }
  return t;
}
function Ga(t) {
  var e = pHe(null), r = void 0;
  for (r in t)
    As(cHe, t, [r]) && (e[r] = t[r]);
  return e;
}
function es(t, e) {
  for (; t !== null; ) {
    var r = dHe(t, e);
    if (r) {
      if (r.get)
        return wn(r.get);
      if (typeof r.value == "function")
        return wn(r.value);
    }
    t = vHe(t);
  }
  function n(a) {
    return console.warn("fallback value for", a), null;
  }
  return n;
}
var Dd = Br(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), Ou = Br(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), Du = Br(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), bHe = Br(["animate", "color-profile", "cursor", "discard", "fedropshadow", "feimage", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), Nu = Br(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), kHe = Br(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), Nd = Br(["#text"]), Rd = Br(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), Ru = Br(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), Id = Br(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), ts = Br(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), wHe = oa(/\{\{[\s\S]*|[\s\S]*\}\}/gm), CHe = oa(/<%[\s\S]*|[\s\S]*%>/gm), THe = oa(/^data-[\-\w.\u00B7-\uFFFF]/), SHe = oa(/^aria-[\-\w]+$/), EHe = oa(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), xHe = oa(/^(?:\w+script|data):/i), AHe = oa(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), Qi = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
  return typeof t;
} : function(t) {
  return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
};
function xn(t) {
  if (Array.isArray(t)) {
    for (var e = 0, r = Array(t.length); e < t.length; e++)
      r[e] = t[e];
    return r;
  } else
    return Array.from(t);
}
var MHe = function() {
  return typeof window > "u" ? null : window;
}, LHe = function(e, r) {
  if ((typeof e > "u" ? "undefined" : Qi(e)) !== "object" || typeof e.createPolicy != "function")
    return null;
  var n = null, a = "data-tt-policy-suffix";
  r.currentScript && r.currentScript.hasAttribute(a) && (n = r.currentScript.getAttribute(a));
  var i = "dompurify" + (n ? "#" + n : "");
  try {
    return e.createPolicy(i, {
      createHTML: function(u) {
        return u;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + i + " could not be created."), null;
  }
};
function bm() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : MHe(), e = function(ne) {
    return bm(ne);
  };
  if (e.version = "2.3.3", e.removed = [], !t || !t.document || t.document.nodeType !== 9)
    return e.isSupported = !1, e;
  var r = t.document, n = t.document, a = t.DocumentFragment, i = t.HTMLTemplateElement, o = t.Node, u = t.Element, m = t.NodeFilter, y = t.NamedNodeMap, C = y === void 0 ? t.NamedNodeMap || t.MozNamedAttrMap : y, T = t.Text, x = t.Comment, M = t.DOMParser, P = t.trustedTypes, q = u.prototype, _ = es(q, "cloneNode"), K = es(q, "nextSibling"), X = es(q, "childNodes"), ie = es(q, "parentNode");
  if (typeof i == "function") {
    var ee = n.createElement("template");
    ee.content && ee.content.ownerDocument && (n = ee.content.ownerDocument);
  }
  var oe = LHe(P, r), ue = oe && Ut ? oe.createHTML("") : "", pe = n, Se = pe.implementation, Re = pe.createNodeIterator, Me = pe.createDocumentFragment, ze = pe.getElementsByTagName, vt = r.importNode, je = {};
  try {
    je = Ga(n).documentMode ? n.documentMode : {};
  } catch {
  }
  var rt = {};
  e.isSupported = typeof ie == "function" && Se && typeof Se.createHTMLDocument < "u" && je !== 9;
  var at = wHe, St = CHe, pt = THe, Pt = SHe, Ft = xHe, Je = AHe, Nt = EHe, yt = null, At = gt({}, [].concat(xn(Dd), xn(Ou), xn(Du), xn(Nu), xn(Nd))), lt = null, Rt = gt({}, [].concat(xn(Rd), xn(Ru), xn(Id), xn(ts))), he = null, le = null, te = !0, ae = !0, Z = !1, de = !1, Te = !1, Pe = !1, ft = !1, ht = !1, wt = !1, Ot = !0, Ut = !1, Kt = !0, qr = !0, Jt = !1, _t = {}, pr = null, hr = gt({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), Fr = null, _r = gt({}, ["audio", "video", "img", "source", "image", "track"]), He = null, _e = gt({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Xe = "http://www.w3.org/1998/Math/MathML", st = "http://www.w3.org/2000/svg", Ct = "http://www.w3.org/1999/xhtml", rr = Ct, lr = !1, Yt = void 0, Zt = ["application/xhtml+xml", "text/html"], Rr = "text/html", Cr = void 0, Qt = null, Hr = n.createElement("form"), Tr = function(ne) {
    Qt && Qt === ne || ((!ne || (typeof ne > "u" ? "undefined" : Qi(ne)) !== "object") && (ne = {}), ne = Ga(ne), yt = "ALLOWED_TAGS" in ne ? gt({}, ne.ALLOWED_TAGS) : At, lt = "ALLOWED_ATTR" in ne ? gt({}, ne.ALLOWED_ATTR) : Rt, He = "ADD_URI_SAFE_ATTR" in ne ? gt(Ga(_e), ne.ADD_URI_SAFE_ATTR) : _e, Fr = "ADD_DATA_URI_TAGS" in ne ? gt(Ga(_r), ne.ADD_DATA_URI_TAGS) : _r, pr = "FORBID_CONTENTS" in ne ? gt({}, ne.FORBID_CONTENTS) : hr, he = "FORBID_TAGS" in ne ? gt({}, ne.FORBID_TAGS) : {}, le = "FORBID_ATTR" in ne ? gt({}, ne.FORBID_ATTR) : {}, _t = "USE_PROFILES" in ne ? ne.USE_PROFILES : !1, te = ne.ALLOW_ARIA_ATTR !== !1, ae = ne.ALLOW_DATA_ATTR !== !1, Z = ne.ALLOW_UNKNOWN_PROTOCOLS || !1, de = ne.SAFE_FOR_TEMPLATES || !1, Te = ne.WHOLE_DOCUMENT || !1, ht = ne.RETURN_DOM || !1, wt = ne.RETURN_DOM_FRAGMENT || !1, Ot = ne.RETURN_DOM_IMPORT !== !1, Ut = ne.RETURN_TRUSTED_TYPE || !1, ft = ne.FORCE_BODY || !1, Kt = ne.SANITIZE_DOM !== !1, qr = ne.KEEP_CONTENT !== !1, Jt = ne.IN_PLACE || !1, Nt = ne.ALLOWED_URI_REGEXP || Nt, rr = ne.NAMESPACE || Ct, Yt = // eslint-disable-next-line unicorn/prefer-includes
    Zt.indexOf(ne.PARSER_MEDIA_TYPE) === -1 ? Yt = Rr : Yt = ne.PARSER_MEDIA_TYPE, Cr = Yt === "application/xhtml+xml" ? function(Ee) {
      return Ee;
    } : ls, de && (ae = !1), wt && (ht = !0), _t && (yt = gt({}, [].concat(xn(Nd))), lt = [], _t.html === !0 && (gt(yt, Dd), gt(lt, Rd)), _t.svg === !0 && (gt(yt, Ou), gt(lt, Ru), gt(lt, ts)), _t.svgFilters === !0 && (gt(yt, Du), gt(lt, Ru), gt(lt, ts)), _t.mathMl === !0 && (gt(yt, Nu), gt(lt, Id), gt(lt, ts))), ne.ADD_TAGS && (yt === At && (yt = Ga(yt)), gt(yt, ne.ADD_TAGS)), ne.ADD_ATTR && (lt === Rt && (lt = Ga(lt)), gt(lt, ne.ADD_ATTR)), ne.ADD_URI_SAFE_ATTR && gt(He, ne.ADD_URI_SAFE_ATTR), ne.FORBID_CONTENTS && (pr === hr && (pr = Ga(pr)), gt(pr, ne.FORBID_CONTENTS)), qr && (yt["#text"] = !0), Te && gt(yt, ["html", "head", "body"]), yt.table && (gt(yt, ["tbody"]), delete he.tbody), Br && Br(ne), Qt = ne);
  }, nn = gt({}, ["mi", "mo", "mn", "ms", "mtext"]), W = gt({}, ["foreignobject", "desc", "title", "annotation-xml"]), V = gt({}, Ou);
  gt(V, Du), gt(V, bHe);
  var R = gt({}, Nu);
  gt(R, kHe);
  var D = function(ne) {
    var Ee = ie(ne);
    (!Ee || !Ee.tagName) && (Ee = {
      namespaceURI: Ct,
      tagName: "template"
    });
    var N = ls(ne.tagName), S = ls(Ee.tagName);
    if (ne.namespaceURI === st)
      return Ee.namespaceURI === Ct ? N === "svg" : Ee.namespaceURI === Xe ? N === "svg" && (S === "annotation-xml" || nn[S]) : !!V[N];
    if (ne.namespaceURI === Xe)
      return Ee.namespaceURI === Ct ? N === "math" : Ee.namespaceURI === st ? N === "math" && W[S] : !!R[N];
    if (ne.namespaceURI === Ct) {
      if (Ee.namespaceURI === st && !W[S] || Ee.namespaceURI === Xe && !nn[S])
        return !1;
      var v = gt({}, ["title", "style", "font", "a", "script"]);
      return !R[N] && (v[N] || !V[N]);
    }
    return !1;
  }, I = function(ne) {
    ji(e.removed, { element: ne });
    try {
      ne.parentNode.removeChild(ne);
    } catch {
      try {
        ne.outerHTML = ue;
      } catch {
        ne.remove();
      }
    }
  }, H = function(ne, Ee) {
    try {
      ji(e.removed, {
        attribute: Ee.getAttributeNode(ne),
        from: Ee
      });
    } catch {
      ji(e.removed, {
        attribute: null,
        from: Ee
      });
    }
    if (Ee.removeAttribute(ne), ne === "is" && !lt[ne])
      if (ht || wt)
        try {
          I(Ee);
        } catch {
        }
      else
        try {
          Ee.setAttribute(ne, "");
        } catch {
        }
  }, J = function(ne) {
    var Ee = void 0, N = void 0;
    if (ft)
      ne = "<remove></remove>" + ne;
    else {
      var S = Ld(ne, /^[\r\n\t ]+/);
      N = S && S[0];
    }
    Yt === "application/xhtml+xml" && (ne = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + ne + "</body></html>");
    var v = oe ? oe.createHTML(ne) : ne;
    if (rr === Ct)
      try {
        Ee = new M().parseFromString(v, Yt);
      } catch {
      }
    if (!Ee || !Ee.documentElement) {
      Ee = Se.createDocument(rr, "template", null);
      try {
        Ee.documentElement.innerHTML = lr ? "" : v;
      } catch {
      }
    }
    var b = Ee.body || Ee.documentElement;
    return ne && N && b.insertBefore(n.createTextNode(N), b.childNodes[0] || null), rr === Ct ? ze.call(Ee, Te ? "html" : "body")[0] : Te ? Ee.documentElement : b;
  }, ve = function(ne) {
    return Re.call(ne.ownerDocument || ne, ne, m.SHOW_ELEMENT | m.SHOW_COMMENT | m.SHOW_TEXT, null, !1);
  }, me = function(ne) {
    return ne instanceof T || ne instanceof x ? !1 : typeof ne.nodeName != "string" || typeof ne.textContent != "string" || typeof ne.removeChild != "function" || !(ne.attributes instanceof C) || typeof ne.removeAttribute != "function" || typeof ne.setAttribute != "function" || typeof ne.namespaceURI != "string" || typeof ne.insertBefore != "function";
  }, be = function(ne) {
    return (typeof o > "u" ? "undefined" : Qi(o)) === "object" ? ne instanceof o : ne && (typeof ne > "u" ? "undefined" : Qi(ne)) === "object" && typeof ne.nodeType == "number" && typeof ne.nodeName == "string";
  }, Oe = function(ne, Ee, N) {
    rt[ne] && hHe(rt[ne], function(S) {
      S.call(e, Ee, N, Qt);
    });
  }, Ye = function(ne) {
    var Ee = void 0;
    if (Oe("beforeSanitizeElements", ne, null), me(ne) || Ld(ne.nodeName, /[\u0080-\uFFFF]/))
      return I(ne), !0;
    var N = Cr(ne.nodeName);
    if (Oe("uponSanitizeElement", ne, {
      tagName: N,
      allowedTags: yt
    }), !be(ne.firstElementChild) && (!be(ne.content) || !be(ne.content.firstElementChild)) && Qn(/<[/\w]/g, ne.innerHTML) && Qn(/<[/\w]/g, ne.textContent) || N === "select" && Qn(/<template/i, ne.innerHTML))
      return I(ne), !0;
    if (!yt[N] || he[N]) {
      if (qr && !pr[N]) {
        var S = ie(ne) || ne.parentNode, v = X(ne) || ne.childNodes;
        if (v && S)
          for (var b = v.length, A = b - 1; A >= 0; --A)
            S.insertBefore(_(v[A], !0), K(ne));
      }
      return I(ne), !0;
    }
    return ne instanceof u && !D(ne) || (N === "noscript" || N === "noembed") && Qn(/<\/no(script|embed)/i, ne.innerHTML) ? (I(ne), !0) : (de && ne.nodeType === 3 && (Ee = ne.textContent, Ee = ba(Ee, at, " "), Ee = ba(Ee, St, " "), ne.textContent !== Ee && (ji(e.removed, { element: ne.cloneNode() }), ne.textContent = Ee)), Oe("afterSanitizeElements", ne, null), !1);
  }, We = function(ne, Ee, N) {
    if (Kt && (Ee === "id" || Ee === "name") && (N in n || N in Hr))
      return !1;
    if (!(ae && !le[Ee] && Qn(pt, Ee))) {
      if (!(te && Qn(Pt, Ee))) {
        if (!lt[Ee] || le[Ee])
          return !1;
        if (!He[Ee]) {
          if (!Qn(Nt, ba(N, Je, ""))) {
            if (!((Ee === "src" || Ee === "xlink:href" || Ee === "href") && ne !== "script" && mHe(N, "data:") === 0 && Fr[ne])) {
              if (!(Z && !Qn(Ft, ba(N, Je, "")))) {
                if (N)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, ut = function(ne) {
    var Ee = void 0, N = void 0, S = void 0, v = void 0;
    Oe("beforeSanitizeAttributes", ne, null);
    var b = ne.attributes;
    if (b) {
      var A = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: lt
      };
      for (v = b.length; v--; ) {
        Ee = b[v];
        var B = Ee, z = B.name, G = B.namespaceURI;
        if (N = gHe(Ee.value), S = Cr(z), A.attrName = S, A.attrValue = N, A.keepAttr = !0, A.forceKeepAttr = void 0, Oe("uponSanitizeAttribute", ne, A), N = A.attrValue, !A.forceKeepAttr && (H(z, ne), !!A.keepAttr)) {
          if (Qn(/\/>/i, N)) {
            H(z, ne);
            continue;
          }
          de && (N = ba(N, at, " "), N = ba(N, St, " "));
          var fe = Cr(ne.nodeName);
          if (We(fe, S, N))
            try {
              G ? ne.setAttributeNS(G, z, N) : ne.setAttribute(z, N), Md(e.removed);
            } catch {
            }
        }
      }
      Oe("afterSanitizeAttributes", ne, null);
    }
  }, ct = function Ae(ne) {
    var Ee = void 0, N = ve(ne);
    for (Oe("beforeSanitizeShadowDOM", ne, null); Ee = N.nextNode(); )
      Oe("uponSanitizeShadowNode", Ee, null), !Ye(Ee) && (Ee.content instanceof a && Ae(Ee.content), ut(Ee));
    Oe("afterSanitizeShadowDOM", ne, null);
  };
  return e.sanitize = function(Ae, ne) {
    var Ee = void 0, N = void 0, S = void 0, v = void 0, b = void 0;
    if (lr = !Ae, lr && (Ae = "<!-->"), typeof Ae != "string" && !be(Ae)) {
      if (typeof Ae.toString != "function")
        throw Od("toString is not a function");
      if (Ae = Ae.toString(), typeof Ae != "string")
        throw Od("dirty is not a string, aborting");
    }
    if (!e.isSupported) {
      if (Qi(t.toStaticHTML) === "object" || typeof t.toStaticHTML == "function") {
        if (typeof Ae == "string")
          return t.toStaticHTML(Ae);
        if (be(Ae))
          return t.toStaticHTML(Ae.outerHTML);
      }
      return Ae;
    }
    if (Pe || Tr(ne), e.removed = [], typeof Ae == "string" && (Jt = !1), !Jt)
      if (Ae instanceof o)
        Ee = J("<!---->"), N = Ee.ownerDocument.importNode(Ae, !0), N.nodeType === 1 && N.nodeName === "BODY" || N.nodeName === "HTML" ? Ee = N : Ee.appendChild(N);
      else {
        if (!ht && !de && !Te && // eslint-disable-next-line unicorn/prefer-includes
        Ae.indexOf("<") === -1)
          return oe && Ut ? oe.createHTML(Ae) : Ae;
        if (Ee = J(Ae), !Ee)
          return ht ? null : ue;
      }
    Ee && ft && I(Ee.firstChild);
    for (var A = ve(Jt ? Ae : Ee); S = A.nextNode(); )
      S.nodeType === 3 && S === v || Ye(S) || (S.content instanceof a && ct(S.content), ut(S), v = S);
    if (v = null, Jt)
      return Ae;
    if (ht) {
      if (wt)
        for (b = Me.call(Ee.ownerDocument); Ee.firstChild; )
          b.appendChild(Ee.firstChild);
      else
        b = Ee;
      return Ot && (b = vt.call(r, b, !0)), b;
    }
    var B = Te ? Ee.outerHTML : Ee.innerHTML;
    return de && (B = ba(B, at, " "), B = ba(B, St, " ")), oe && Ut ? oe.createHTML(B) : B;
  }, e.setConfig = function(Ae) {
    Tr(Ae), Pe = !0;
  }, e.clearConfig = function() {
    Qt = null, Pe = !1;
  }, e.isValidAttribute = function(Ae, ne, Ee) {
    Qt || Tr({});
    var N = Cr(Ae), S = Cr(ne);
    return We(N, S, Ee);
  }, e.addHook = function(Ae, ne) {
    typeof ne == "function" && (rt[Ae] = rt[Ae] || [], ji(rt[Ae], ne));
  }, e.removeHook = function(Ae) {
    rt[Ae] && Md(rt[Ae]);
  }, e.removeHooks = function(Ae) {
    rt[Ae] && (rt[Ae] = []);
  }, e.removeAllHooks = function() {
    rt = {};
  }, e;
}
var OHe = bm(), DHe = ["iframe", "embed"], km = [];
function wm(t) {
  Ar(DHe, t) && km.push(t.toLowerCase());
}
function ti(t, e) {
  return OHe.sanitize(t, ge({ ADD_TAGS: km, ADD_ATTR: ["rel", "target", "hreflang", "type"], FORBID_TAGS: [
    "input",
    "script",
    "textarea",
    "form",
    "button",
    "select",
    "meta",
    "style",
    "link",
    "title",
    "object",
    "base"
  ] }, e));
}
function Cm(t, e) {
  return t.literal.replace(new RegExp("(<\\s*" + e + "[^>]*>)|(</" + e + "\\s*[>])", "ig"), "").trim();
}
function ic(t) {
  t = t.match(Ei)[0];
  var e = t.match(new RegExp(gh, "g"));
  return e ? e.reduce(function(r, n) {
    var a = n.trim().split("="), i = a[0], o = a.slice(1);
    return o.length && (r[i] = o.join("=").replace(/'|"/g, "").trim()), r;
  }, {}) : {};
}
function oc(t) {
  return Nn(t.attributes).reduce(function(e, r) {
    return e[r.nodeName] = r.nodeValue, e;
  }, {});
}
function Pd(t, e, r, n) {
  var a = n.getToDOMNode(e)(t), i = r(a.outerHTML), o = document.createElement("div");
  o.innerHTML = i, a = o.firstChild;
  var u = oc(a);
  return { dom: a, htmlAttrs: u };
}
var NHe = {
  htmlBlock: function(t, e, r) {
    return {
      atom: !0,
      content: "block+",
      group: "block",
      attrs: {
        htmlAttrs: { default: {} },
        childrenHTML: { default: "" },
        htmlBlock: { default: !0 }
      },
      parseDOM: [
        {
          tag: t,
          getAttrs: function(n) {
            return {
              htmlAttrs: oc(n),
              childrenHTML: n.innerHTML
            };
          }
        }
      ],
      toDOM: function(n) {
        var a = Pd(n, t, e, r), i = a.dom, o = a.htmlAttrs;
        return o.class = o.class ? o.class + " html-block" : "html-block", Wr([t, o], Nn(i.childNodes));
      }
    };
  },
  htmlInline: function(t, e, r) {
    return {
      attrs: {
        htmlAttrs: { default: {} },
        htmlInline: { default: !0 }
      },
      parseDOM: [
        {
          tag: t,
          getAttrs: function(n) {
            return {
              htmlAttrs: oc(n)
            };
          }
        }
      ],
      toDOM: function(n) {
        var a = Pd(n, t, e, r).htmlAttrs;
        return [t, a, 0];
      }
    };
  }
};
function RHe(t, e, r) {
  var n = { nodes: {}, marks: {} };
  return ["htmlBlock", "htmlInline"].forEach(function(a) {
    t[a] && Object.keys(t[a]).forEach(function(i) {
      var o = a === "htmlBlock" ? "nodes" : "marks";
      wm(i), n[o][i] = NHe[a](i, e, r);
    });
  }), n;
}
var IHe = /^\s*<\s*\//, PHe = {
  paragraph: function(t, e) {
    var r = e.entering, n = e.origin, a = e.options;
    return a.nodeId ? {
      type: r ? "openTag" : "closeTag",
      outerNewLine: !0,
      tagName: "p"
    } : n();
  },
  softbreak: function(t) {
    var e = t.prev && t.prev.type === "htmlInline", r = e && /<br ?\/?>/.test(t.prev.literal), n = r ? `
` : `<br>
`;
    return { type: "html", content: n };
  },
  item: function(t, e) {
    var r = e.entering;
    if (r) {
      var n = {}, a = [];
      return t.listData.task && (n["data-task"] = "", a.push("task-list-item"), t.listData.checked && (a.push("checked"), n["data-task-checked"] = "")), {
        type: "openTag",
        tagName: "li",
        classNames: a,
        attributes: n,
        outerNewLine: !0
      };
    }
    return {
      type: "closeTag",
      tagName: "li",
      outerNewLine: !0
    };
  },
  code: function(t) {
    var e = { "data-backticks": String(t.tickCount) };
    return [
      { type: "openTag", tagName: "code", attributes: e },
      { type: "text", content: t.literal },
      { type: "closeTag", tagName: "code" }
    ];
  },
  codeBlock: function(t) {
    var e = t, r = e.fenceLength, n = e.info, a = n ? n.split(/\s+/) : [], i = [], o = {};
    if (r > 3 && (o["data-backticks"] = r), a.length > 0 && a[0].length > 0) {
      var u = a[0];
      i.push("lang-" + u), o["data-language"] = u;
    }
    return [
      { type: "openTag", tagName: "pre", classNames: i },
      { type: "openTag", tagName: "code", attributes: o },
      { type: "text", content: t.literal },
      { type: "closeTag", tagName: "code" },
      { type: "closeTag", tagName: "pre" }
    ];
  },
  customInline: function(t, e) {
    var r = e.origin, n = e.entering, a = e.skipChildren, i = t.info;
    if (i.indexOf("widget") !== -1 && n) {
      a();
      var o = dh(t), u = vh(i, o).outerHTML;
      return [
        { type: "openTag", tagName: "span", classNames: ["tui-widget"] },
        { type: "html", content: u },
        { type: "closeTag", tagName: "span" }
      ];
    }
    return r();
  }
};
function Vc(t, e) {
  var r = ge({}, PHe);
  return t && (r.link = function(n, a) {
    var i = a.entering, o = a.origin, u = o();
    return i && (u.attributes = ge(ge({}, u.attributes), t)), u;
  }), e && Object.keys(e).forEach(function(n) {
    var a = r[n], i = e[n];
    a && un(i) ? r[n] = function(o, u) {
      var m = ge({}, u);
      return m.origin = function() {
        return a(o, u);
      }, i(o, m);
    } : Ar(["htmlBlock", "htmlInline"], n) && !un(i) ? r[n] = function(o, u) {
      var m = o.literal.match(Ei);
      if (m) {
        var y = m[0], C = m[1], T = m[3], x = (C || T).toLowerCase(), M = i[x], P = Cm(o, x);
        if (M) {
          var q = ge({}, o);
          return q.attrs = ic(y), q.childrenHTML = P, q.type = x, u.entering = !IHe.test(o.literal), M(q, u);
        }
      }
      return u.origin();
    } : r[n] = i;
  }), r;
}
var BHe = ["list", "item", "blockQuote"], qHe = ["UL", "OL", "BLOCKQUOTE"];
function FHe(t, e) {
  var r, n = t.child(e);
  return !n.childCount || n.childCount === 1 && !(!((r = n.firstChild.text) === null || r === void 0) && r.trim());
}
function Bd(t, e, r) {
  var n = lo(e) - 1, a = Bs(e) - 1, i = r[n].getBoundingClientRect(), o = r[a].offsetTop - r[n].offsetTop + r[a].clientHeight;
  return {
    height: o <= 0 ? r[n].clientHeight : o + _He(t, r, Math.min(a + 1, t.childCount - 1)),
    rect: i
  };
}
function _He(t, e, r) {
  for (var n = t.childCount - 1, a = 0; r <= n && FHe(t, r); )
    a += e[r].clientHeight, r += 1;
  return a;
}
function HHe(t, e) {
  for (; !t.getAttribute("data-nodeid") && t.parentElement !== e; )
    t = t.parentElement;
  return t;
}
function Ms(t, e) {
  for (var r = 0; t && t !== e && (Ar(qHe, t.tagName) || (r += t.offsetTop), t.offsetParent !== e.offsetParent); )
    t = t.parentElement;
  return r;
}
function UHe(t, e) {
  for (var r = e, n = null; r; ) {
    var a = r.firstElementChild;
    if (!a)
      break;
    var i = Tm(a, t, Ms(r, e));
    n = r, r = i;
  }
  var o = r || n;
  return o === e ? null : o;
}
function Tm(t, e, r) {
  return t && e > r + t.offsetTop ? Tm(t.nextElementSibling, e, r) || t : null;
}
function zHe(t, e, r, n) {
  var a = Math.min((t - e) / r, 1);
  return a * n;
}
function Iu(t, e) {
  for (var r = t.querySelector('[data-nodeid="' + e.id + '"]'); !r || OY(e); )
    e = e.parent, r = t.querySelector('[data-nodeid="' + e.id + '"]');
  return $He({ mdNode: e, el: r });
}
function $He(t) {
  for (var e = t.mdNode, r = t.el; (Ar(BHe, e.type) || e.type === "table") && e.firstChild; )
    e = e.firstChild, r = r.firstElementChild;
  return { mdNode: e, el: r };
}
var yn = {};
function VHe(t, e) {
  yn[t] = yn[t] || {}, yn[t].height = e;
}
function WHe(t, e) {
  yn[t] = yn[t] || {}, yn[t].offsetTop = e;
}
function jHe(t) {
  return yn[t] && yn[t].height;
}
function GHe(t) {
  return yn[t] && yn[t].offsetTop;
}
function sc(t) {
  t && (delete yn[Number(t.getAttribute("data-nodeid"))], Nn(t.children).forEach(function(e) {
    sc(e);
  }));
}
function KHe(t, e, r) {
  var n = jHe(r), a = GHe(r), i = n || t.clientHeight, o = a || Ms(t, e) || t.offsetTop;
  return n || VHe(r, i), a || WHe(r, o), { nodeHeight: i, offsetTop: o };
}
var Pu = Ke("md-preview-highlight");
function JHe(t, e) {
  for (var r = t.firstChild; r && r.next && !(qs(r.next) > e + 1); )
    r = r.next;
  return r;
}
var Sm = (
  /** @class */
  function() {
    function t(e, r) {
      var n = document.createElement("div");
      this.el = n, this.eventEmitter = e, this.isViewer = !!r.isViewer, this.el.className = Ke("md-preview");
      var a = r.linkAttributes, i = r.customHTMLRenderer, o = r.sanitizer, u = r.highlight, m = u === void 0 ? !1 : u;
      this.renderer = new $c({
        gfm: !0,
        nodeId: !0,
        convertors: Vc(a, i)
      }), this.cursorNodeId = null, this.sanitizer = o, this.initEvent(m), this.initContentSection(), this.isViewer && (this.previewContent.style.overflowWrap = "break-word");
    }
    return t.prototype.initContentSection = function() {
      this.previewContent = Ch('<div class="' + Ke("contents") + '"></div>'), this.isViewer || this.el.appendChild(this.previewContent);
    }, t.prototype.toggleActive = function(e) {
      Lc(this.el, "active", e);
    }, t.prototype.initEvent = function(e) {
      var r = this;
      this.eventEmitter.listen("updatePreview", this.update.bind(this)), !this.isViewer && (e && (this.eventEmitter.listen("changeToolbarState", function(n) {
        var a = n.mdNode, i = n.cursorPos;
        r.updateCursorNode(a, i);
      }), this.eventEmitter.listen("blur", function() {
        r.removeHighlight();
      })), _h(this.el, "scroll", function(n) {
        r.eventEmitter.emit("scroll", "preview", UHe(n.target.scrollTop, r.previewContent));
      }), this.eventEmitter.listen("changePreviewTabPreview", function() {
        return r.toggleActive(!0);
      }), this.eventEmitter.listen("changePreviewTabWrite", function() {
        return r.toggleActive(!1);
      }));
    }, t.prototype.removeHighlight = function() {
      if (this.cursorNodeId) {
        var e = this.getElementByNodeId(this.cursorNodeId);
        e && gn(e, Pu);
      }
    }, t.prototype.updateCursorNode = function(e, r) {
      e && (e = Si(e, function(o) {
        return !RY(o);
      }), e.type === "tableRow" ? e = JHe(e, r[1]) : e.type === "tableBody" && (e = null));
      var n = e ? e.id : null;
      if (this.cursorNodeId !== n) {
        var a = this.getElementByNodeId(this.cursorNodeId), i = this.getElementByNodeId(n);
        a && gn(a, Pu), i && Ln(i, Pu), this.cursorNodeId = n;
      }
    }, t.prototype.getElementByNodeId = function(e) {
      return e ? this.previewContent.querySelector('[data-nodeid="' + e + '"]') : null;
    }, t.prototype.update = function(e) {
      var r = this;
      e.forEach(function(n) {
        return r.replaceRangeNodes(n);
      }), this.eventEmitter.emit("afterPreviewRender", this);
    }, t.prototype.replaceRangeNodes = function(e) {
      var r = this, n = e.nodes, a = e.removedNodeRange, i = this.previewContent, o = this.eventEmitter.emitReduce("beforePreviewRender", this.sanitizer(n.map(function(P) {
        return r.renderer.render(P);
      }).join("")));
      if (!a)
        i.insertAdjacentHTML("afterbegin", o);
      else {
        var u = a.id, m = u[0], y = u[1], C = this.getElementByNodeId(m), T = this.getElementByNodeId(y);
        if (C) {
          C.insertAdjacentHTML("beforebegin", o);
          for (var x = C; x && x !== T; ) {
            var M = x.nextElementSibling;
            Qa(x), sc(x), x = M;
          }
          x != null && x.parentNode && (Qa(x), sc(x));
        }
      }
    }, t.prototype.getRenderer = function() {
      return this.renderer;
    }, t.prototype.destroy = function() {
      Fh(this.el, "scroll"), this.el = null;
    }, t.prototype.getElement = function() {
      return this.el;
    }, t.prototype.getHTML = function() {
      return Nc(this.previewContent.innerHTML);
    }, t.prototype.setHTML = function(e) {
      this.previewContent.innerHTML = e;
    }, t.prototype.setHeight = function(e) {
      Dn(this.el, { height: e + "px" });
    }, t.prototype.setMinHeight = function(e) {
      Dn(this.el, { minHeight: e + "px" });
    }, t;
  }()
);
function ta(t, e) {
  for (var r = t.depth; r; ) {
    var n = t.node(r);
    if (e(n, r))
      return {
        node: n,
        depth: r,
        offset: r > 0 ? t.before(r) : 0
      };
    r -= 1;
  }
  return null;
}
function Li(t) {
  return !!ta(t, function(e) {
    var r = e.type;
    return r.name === "listItem" || r.name === "bulletList" || r.name === "orderedList";
  });
}
function Ls(t) {
  return !!ta(t, function(e) {
    var r = e.type;
    return r.name === "tableHeadCell" || r.name === "tableBodyCell";
  });
}
function Oi(t) {
  return ta(t, function(e) {
    var r = e.type;
    return r.name === "listItem";
  });
}
function js(t) {
  return {
    tag: t,
    getAttrs: function(e) {
      var r = e.getAttribute("data-raw-html");
      return ge({}, r && { rawHTML: r });
    }
  };
}
function Em(t) {
  return Object.keys(t).reduce(function(e, r) {
    return r !== "rawHTML" && t[r] && (r = r === "className" ? "class" : r, e[r] = t[r]), e;
  }, {});
}
function xm(t) {
  return {
    tag: t,
    getAttrs: function(e) {
      return ["rawHTML", "colspan", "rowspan", "extended"].reduce(function(r, n) {
        var a = n === "rawHTML" ? "data-raw-html" : n, i = e.getAttribute(a);
        return i && (r[n] = Ar(["rawHTML", "extended"], n) ? i : Number(i)), r;
      }, {});
    }
  };
}
function wr() {
  return {
    htmlAttrs: { default: null },
    classNames: { default: null }
  };
}
function or(t) {
  var e = t.htmlAttrs, r = t.classNames;
  return ge(ge({}, e), { class: r ? r.join(" ") : null });
}
function YHe(t, e) {
  var r = t.parent, n = t.startIndex, a = t.endIndex, i = r.contentMatchAt(n).findWrapping(e);
  if (i) {
    var o = i.length ? i[0] : e;
    return r.canReplaceWith(n, a, o) ? i : null;
  }
  return null;
}
function ZHe(t, e) {
  var r = t.parent, n = t.startIndex, a = t.endIndex, i = r.child(n), o = e.contentMatch.findWrapping(i.type);
  if (o) {
    for (var u = o.length ? o[o.length - 1] : e, m = u.contentMatch, y = n; m && y < a; y += 1)
      m = m.matchType(r.child(y).type);
    if (m && m.validEnd)
      return o;
  }
  return null;
}
function QHe(t, e, r, n) {
  var a = YHe(t, r), i = ZHe(e, r);
  if (a && i) {
    var o = a.map(function(m) {
      return { type: m };
    }), u = i.map(function(m) {
      return { type: m, attrs: n };
    });
    return o.concat({ type: r }).concat(u);
  }
  return null;
}
function XHe(t, e, r, n, a) {
  for (var i = e.start, o = e.end, u = e.startIndex, m = e.endIndex, y = e.parent, C = Qe.Fragment.empty, T = r.length - 1; T >= 0; T -= 1)
    C = Qe.Fragment.from(r[T].type.create(r[T].attrs, C));
  t.step(new zt.ReplaceAroundStep(i - (n ? 2 : 0), o, i, o, new Qe.Slice(C, 0, 0), r.length, !0));
  for (var x = 0, T = 0; T < r.length; T += 1)
    if (r[T].type === a) {
      x = T + 1;
      break;
    }
  for (var M = r.length - x, P = i + r.length - (n ? 2 : 0), T = u, q = m; T < q; T += 1) {
    var _ = T === u;
    !_ && zt.canSplit(t.doc, P, M) && (t.split(P, M), P += M * 2), P += y.child(T).nodeSize;
  }
  return t;
}
function Am(t, e, r, n) {
  var a = e.$from, i = e.$to, o = e.depth, u = e, m = !1;
  if (o >= 2 && a.node(o - 1).type.compatibleContent(r) && e.startIndex === 0 && a.index(o - 1)) {
    var y = t.doc.resolve(e.start - 2);
    u = new Qe.NodeRange(y, y, o), e.endIndex < e.parent.childCount && (e = new Qe.NodeRange(a, t.doc.resolve(i.end(o)), o)), m = !0;
  }
  var C = QHe(u, e, r, n);
  return C ? XHe(t, e, C, m, r) : t;
}
function Mm(t, e) {
  for (var r = t.resolve(e); r.node().type.name !== "paragraph"; )
    e -= 2, r = t.resolve(e);
  return Oi(r);
}
function eUe(t, e) {
  var r = e.$from, n = e.$to, a = Oi(r), i = Oi(n);
  if (a && i)
    for (; i; ) {
      var o = i.offset, u = i.node, m = { task: !u.attrs.task, checked: !1 };
      if (t.setNodeMarkup(o, null, m), o === a.offset)
        break;
      i = Mm(t.doc, o);
    }
  return t;
}
function tUe(t, e, r) {
  var n = e.$from, a = e.$to, i = Oi(n), o = Oi(a);
  if (i && o)
    for (; o; ) {
      var u = o.offset, m = o.node, y = o.depth;
      m.attrs.task && t.setNodeMarkup(u, null, { task: !1, checked: !1 });
      var C = t.doc.resolve(u);
      if (C.parent.type !== r) {
        var T = C.before(y - 1);
        t.setNodeMarkup(T, r);
      }
      if (u === i.offset)
        break;
      o = Mm(t.doc, u);
    }
  return t;
}
function Lm(t) {
  return function(e, r) {
    var n = e.selection, a = e.tr, i = n.$from, o = n.$to, u = i.blockRange(o);
    if (u) {
      var m = Li(i) ? tUe(a, u, t) : Am(a, u, t);
      return r(m), !0;
    }
    return !1;
  };
}
function rUe() {
  return function(t, e) {
    var r = t.selection, n = t.tr, a = t.schema, i = r.$from, o = r.$to, u = i.blockRange(o);
    if (u) {
      var m = Li(i) ? eUe(n, u) : Am(n, u, a.nodes.bulletList, { task: !0 });
      return e(m), !0;
    }
    return !1;
  };
}
function nUe(t) {
  return function(e, r) {
    var n = e.tr, a = e.selection, i = a.$from, o = a.$to, u = i.blockRange(o, function(q) {
      var _ = q.childCount, K = q.firstChild;
      return !!_ && K.type === t;
    });
    if (u && u.startIndex > 0) {
      var m = u.parent, y = m.child(u.startIndex - 1);
      if (y.type !== t)
        return !1;
      var C = y.lastChild && y.lastChild.type === m.type, T = C ? Qe.Fragment.from(t.create()) : null, x = new Qe.Slice(Qe.Fragment.from(t.create(null, Qe.Fragment.from(m.type.create(null, T)))), C ? 3 : 1, 0), M = u.start, P = u.end;
      return n.step(new zt.ReplaceAroundStep(M - (C ? 3 : 1), P, M, P, x, 1, !0)), r(n), !0;
    }
    return !1;
  };
}
function aUe(t, e, r) {
  var n = e.$from, a = e.$to, i = e.end, o = e.depth, u = e.parent, m = a.end(o);
  return i < m && (t.step(new zt.ReplaceAroundStep(i - 1, m, i, m, new Qe.Slice(Qe.Fragment.from(r.create(null, u.copy())), 1, 0), 1, !0)), e = new Qe.NodeRange(t.doc.resolve(n.pos), t.doc.resolve(m), o)), t.lift(e, zt.liftTarget(e)), t;
}
function iUe(t, e) {
  for (var r = e.parent, n = e.end, a = e.endIndex - 1, i = e.startIndex; a > i; a -= 1)
    n -= r.child(a).nodeSize, t.delete(n - 1, n + 1);
  var o = t.doc.resolve(e.start), u = o.nodeAfter, m = e.startIndex === 0, y = e.endIndex === r.childCount, C = o.node(-1), T = o.index(-1), x = C.canReplace(T + (m ? 0 : 1), T + 1, u == null ? void 0 : u.content.append(y ? Qe.Fragment.empty : Qe.Fragment.from(r)));
  if (u && x) {
    var M = o.pos, P = M + u.nodeSize;
    t.step(new zt.ReplaceAroundStep(M - (m ? 1 : 0), P + (y ? 1 : 0), M + 1, P - 1, new Qe.Slice((m ? Qe.Fragment.empty : Qe.Fragment.from(r.copy(Qe.Fragment.empty))).append(y ? Qe.Fragment.empty : Qe.Fragment.from(r.copy(Qe.Fragment.empty))), m ? 0 : 1, y ? 0 : 1), m ? 0 : 1));
  }
  return t;
}
function oUe(t) {
  return function(e, r) {
    var n = e.tr, a = e.selection, i = a.$from, o = a.$to, u = i.blockRange(o, function(C) {
      var T = C.childCount, x = C.firstChild;
      return !!T && x.type === t;
    });
    if (u) {
      var m = i.node(u.depth - 1).type === t, y = m ? aUe(n, u, t) : iUe(n, u);
      return r(y), !0;
    }
    return !1;
  };
}
function sUe(t) {
  return function(e, r) {
    var n = e.tr, a = e.selection, i = a.$from, o = a.$to;
    if (i.depth < 2 || !i.sameParent(o))
      return !1;
    var u = i.node(-1);
    if (u.type !== t)
      return !1;
    if (i.parent.content.size === 0 && i.node(-1).childCount === i.indexAfter(-1)) {
      if (i.depth === 2 || i.node(-3).type !== t || i.index(-2) !== i.node(-2).childCount - 1)
        return !1;
      for (var m = i.index(-1) > 0, y = Qe.Fragment.empty, C = i.depth - (m ? 1 : 2); C >= i.depth - 3; C -= 1)
        y = Qe.Fragment.from(i.node(C).copy(y));
      return y = y.append(Qe.Fragment.from(t.createAndFill())), n.replace(m ? i.before() : i.before(-1), i.after(-3), new Qe.Slice(y, m ? 3 : 2, 2)), n.setSelection(nt.Selection.near(n.doc.resolve(i.pos + (m ? 3 : 2)))), r(n), !0;
    }
    var T = o.pos === i.end() ? u.contentMatchAt(0).defaultType : null, x = T && [null, { type: T }];
    return n.delete(i.pos, o.pos), zt.canSplit(n.doc, i.pos, 2, x) ? (n.split(i.pos, 2, x), r(n), !0) : !1;
  };
}
function lUe() {
  return function() {
    return function(t, e) {
      var r = t.selection, n = t.schema, a = r.$from, i = r.$to, o = a.blockRange(i);
      return o && Li(a) ? nUe(n.nodes.listItem)(t, e) : !1;
    };
  };
}
function uUe() {
  return function() {
    return function(t, e) {
      var r = t.selection, n = t.schema, a = r.$from, i = r.$to, o = a.blockRange(i);
      return o && Li(a) ? oUe(n.nodes.listItem)(t, e) : !1;
    };
  };
}
function Wc() {
  return {
    indent: lUe(),
    outdent: uUe()
  };
}
var qd = /* @__PURE__ */ new Map(), Sr = (
  /** @class */
  function() {
    function t(e, r, n, a) {
      this.table = e, this.tableRows = r, this.tableStartPos = n, this.rowInfo = a;
    }
    return t.create = function(e) {
      var r = ta(e, function(P) {
        var q = P.type;
        return q.name === "table";
      });
      if (r) {
        var n = r.node, a = r.depth, i = r.offset, o = qd.get(n);
        if ((o == null ? void 0 : o.tableStartPos) === i + 1)
          return o;
        var u = [], m = e.start(a), y = n.child(0), C = n.child(1), T = lc(y, m), x = lc(C, m + y.nodeSize);
        y.forEach(function(P) {
          return u.push(P);
        }), C.forEach(function(P) {
          return u.push(P);
        });
        var M = new t(n, u, m, T.concat(x));
        return qd.set(n, M), M;
      }
      return null;
    }, Object.defineProperty(t.prototype, "totalRowCount", {
      get: function() {
        return this.rowInfo.length;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "totalColumnCount", {
      get: function() {
        return this.rowInfo[0].length;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tableStartOffset", {
      get: function() {
        return this.tableStartPos;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tableEndOffset", {
      get: function() {
        return this.tableStartPos + this.table.nodeSize - 1;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.getCellInfo = function(e, r) {
      return this.rowInfo[e][r];
    }, t.prototype.posAt = function(e, r) {
      for (var n = 0, a = this.tableStartPos; ; n += 1) {
        var i = a + this.tableRows[n].nodeSize;
        if (n === e) {
          for (var o = r; o < this.totalColumnCount && this.rowInfo[n][o].offset < a; )
            o += 1;
          return o === this.totalColumnCount ? i : this.rowInfo[n][o].offset;
        }
        a = i;
      }
    }, t.prototype.getNodeAndPos = function(e, r) {
      var n = this.rowInfo[e][r];
      return {
        node: this.table.nodeAt(n.offset - this.tableStartOffset),
        pos: n.offset
      };
    }, t.prototype.extendedRowspan = function(e, r) {
      return !1;
    }, t.prototype.extendedColspan = function(e, r) {
      return !1;
    }, t.prototype.getRowspanCount = function(e, r) {
      return 0;
    }, t.prototype.getColspanCount = function(e, r) {
      return 0;
    }, t.prototype.decreaseColspanCount = function(e, r) {
      return 0;
    }, t.prototype.decreaseRowspanCount = function(e, r) {
      return 0;
    }, t.prototype.getColspanStartInfo = function(e, r) {
      return null;
    }, t.prototype.getRowspanStartInfo = function(e, r) {
      return null;
    }, t.prototype.getCellStartOffset = function(e, r) {
      var n = this.rowInfo[e][r].offset;
      return this.extendedRowspan(e, r) ? this.posAt(e, r) : n;
    }, t.prototype.getCellEndOffset = function(e, r) {
      var n = this.rowInfo[e][r], a = n.offset, i = n.nodeSize;
      return this.extendedRowspan(e, r) ? this.posAt(e, r) : a + i;
    }, t.prototype.getCellIndex = function(e) {
      for (var r = 0; r < this.totalRowCount; r += 1)
        for (var n = this.rowInfo[r], a = 0; a < this.totalColumnCount; a += 1)
          if (n[a].offset + 1 > e.pos)
            return [r, a];
      return [0, 0];
    }, t.prototype.getRectOffsets = function(e, r) {
      var n, a, i;
      r === void 0 && (r = e), e.pos > r.pos && (n = [r, e], e = n[0], r = n[1]);
      var o = this.getCellIndex(e), u = o[0], m = o[1], y = this.getCellIndex(r), C = y[0], T = y[1];
      return a = Fv(u, C), u = a[0], C = a[1], i = Fv(m, T), m = i[0], T = i[1], this.getSpannedOffsets({ startRowIdx: u, startColIdx: m, endRowIdx: C, endColIdx: T });
    }, t.prototype.getSpannedOffsets = function(e) {
      return e;
    }, t;
  }()
), lc = function(t, e) {
  var r = [];
  return t.forEach(function(n, a) {
    var i = { rowspanMap: {}, colspanMap: {}, length: 0 };
    n.forEach(function(o, u) {
      for (var m = o.nodeSize, y = 0; i[y]; )
        y += 1;
      i[y] = {
        // 2 is the sum of the front and back positions of the tag
        offset: e + a + u + 2,
        nodeSize: m
      }, i.length += 1;
    }), r.push(i);
  }), r;
};
function cUe(t, e) {
  return Ec(Sr.prototype, t), lc = e, Sr;
}
function fUe(t, e, r) {
  for (var n = r.startRowIdx, a = r.startColIdx, i = r.endRowIdx, o = r.endColIdx, u = [], m = n; m <= i; m += 1)
    for (var y = a; y <= o; y += 1) {
      var C = e.getCellInfo(m, y), T = C.offset, x = C.nodeSize;
      u.push(new nt.SelectionRange(t.resolve(T + 1), t.resolve(T + x - 1)));
    }
  return u;
}
function vUe(t, e) {
  var r = [];
  return t.childCount && r.push(t), e.childCount && r.push(e), Qe.Fragment.from(r);
}
var jc = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e(r, n) {
      n === void 0 && (n = r);
      var a = this, i = r.node(0), o = Sr.create(r), u = o.getRectOffsets(r, n), m = fUe(i, o, u);
      return a = t.call(this, m[0].$from, m[0].$to, m) || this, a.startCell = r, a.endCell = n, a.offsetMap = o, a.isCellSelection = !0, a.visible = !1, a;
    }
    return e.prototype.map = function(r, n) {
      var a = this.startCell.pos, i = this.endCell.pos, o = r.resolve(n.map(a)), u = r.resolve(n.map(i)), m = Sr.create(o);
      if (this.offsetMap.totalColumnCount > m.totalColumnCount || this.offsetMap.totalRowCount > m.totalRowCount) {
        var y = { tableBody: 1, tableRow: 2, tableCell: 3, paragraph: 4 }, C = y[u.parent.type.name], T = u.end(u.depth - C), x = Math.min(T - 4, u.pos);
        return nt.TextSelection.create(r, x);
      }
      return new e(o, u);
    }, e.prototype.eq = function(r) {
      return r instanceof e && r.startCell.pos === this.startCell.pos && r.endCell.pos === this.endCell.pos;
    }, e.prototype.content = function() {
      for (var r = this.startCell.node(-2), n = this.startCell.start(-2), a = r.child(1).firstChild, i = r.child(0).type.create(), o = r.child(1).type.create(), u = Sr.create(this.startCell), m = u.getRectOffsets(this.startCell, this.endCell), y = m.startRowIdx, C = m.startColIdx, T = m.endRowIdx, x = m.endColIdx, M = !1, P = y; P <= T; P += 1) {
        for (var q = [], _ = C; _ <= x; _ += 1) {
          var K = u.getCellInfo(P, _).offset, X = r.nodeAt(K - n);
          X && (M = X.type.name === "tableHeadCell", u.extendedRowspan(P, _) || u.extendedColspan(P, _) ? q.push(X.type.create({ extended: !0 })) : q.push(X.copy(X.content)));
        }
        var ie = a.copy(Qe.Fragment.from(q)), ee = M ? i : o;
        ee.content = ee.content.append(Qe.Fragment.from(ie));
      }
      return new Qe.Slice(vUe(i, o), 1, 1);
    }, e.prototype.toJSON = function() {
      return JSON.stringify(this);
    }, e;
  }(nt.Selection)
);
function dUe(t, e, r) {
  for (var n = e.nodes, a = n.tableRow, i = n.tableHeadCell, o = n.paragraph, u = [], m = 0; m < t; m += 1) {
    var y = r && r[m], C = o.create(null, y ? e.text(y) : []);
    u.push(i.create(null, C));
  }
  return [a.create(null, u)];
}
function Om(t, e, r, n) {
  for (var a = r.nodes, i = a.tableRow, o = a.tableBodyCell, u = a.paragraph, m = [], y = 0; y < t; y += 1) {
    for (var C = [], T = 0; T < e; T += 1) {
      var x = n && n[y * e + T], M = u.create(null, x ? r.text(x) : []);
      C.push(o.create(null, M));
    }
    m.push(i.create(null, C));
  }
  return m;
}
function us(t, e, r, n) {
  n === void 0 && (n = null);
  for (var a = r.nodes, i = a.tableHeadCell, o = a.tableBodyCell, u = a.paragraph, m = e === 0 ? i : o, y = [], C = 0; C < t; C += 1)
    y.push(m.create(n, u.create()));
  return y;
}
function Dm(t, e) {
  for (; t && t !== e; ) {
    if (t.nodeName === "TD" || t.nodeName === "TH")
      return t;
    t = t.parentNode;
  }
  return null;
}
function Nm(t) {
  return ta(t, function(e) {
    var r = e.type;
    return r.name === "tableHeadCell" || r.name === "tableBodyCell";
  });
}
function An(t) {
  if (t instanceof nt.TextSelection) {
    var e = t.$anchor, r = Nm(e);
    if (r) {
      var n = e.node(0).resolve(e.before(r.depth));
      return { anchor: n, head: n };
    }
  }
  var a = t, i = a.startCell, o = a.endCell;
  return { anchor: i, head: o };
}
function Rm(t) {
  var e;
  if (t.size) {
    var r = t.content, n = t.openStart, a = t.openEnd;
    if (r.childCount !== 1)
      return null;
    for (; r.childCount === 1 && (n > 0 && a > 0 || ((e = r.firstChild) === null || e === void 0 ? void 0 : e.type.name) === "table"); )
      n -= 1, a -= 1, r = r.firstChild.content;
    if (r.firstChild.type.name === "tableHead" || r.firstChild.type.name === "tableBody")
      return r;
  }
  return null;
}
function ki(t) {
  var e = t.startRowIdx, r = t.startColIdx, n = t.endRowIdx, a = t.endColIdx, i = n - e + 1, o = a - r + 1;
  return { rowCount: i, columnCount: o };
}
function pUe(t, e) {
  return ge(ge({}, t.attrs), e);
}
var wa = new nt.PluginKey("cellSelection"), hUe = 2, mUe = (
  /** @class */
  function() {
    function t(e) {
      this.view = e, this.handlers = {
        mousedown: this.handleMousedown.bind(this),
        mousemove: this.handleMousemove.bind(this),
        mouseup: this.handleMouseup.bind(this)
      }, this.startCellPos = null, this.init();
    }
    return t.prototype.init = function() {
      this.view.dom.addEventListener("mousedown", this.handlers.mousedown);
    }, t.prototype.handleMousedown = function(e) {
      var r = Dm(e.target, this.view.dom);
      if (e.button === hUe) {
        e.preventDefault();
        return;
      }
      if (r) {
        var n = this.getCellPos(e);
        n && (this.startCellPos = n), this.bindEvent();
      }
    }, t.prototype.handleMousemove = function(e) {
      var r = wa.getState(this.view.state), n = this.getCellPos(e), a = this.startCellPos, i;
      r ? i = this.view.state.doc.resolve(r) : a !== n && (i = a), i && a && n && this.setCellSelection(a, n);
    }, t.prototype.handleMouseup = function() {
      this.startCellPos = null, this.unbindEvent(), wa.getState(this.view.state) !== null && this.view.dispatch(this.view.state.tr.setMeta(wa, -1));
    }, t.prototype.bindEvent = function() {
      var e = this.view.dom;
      e.addEventListener("mousemove", this.handlers.mousemove), e.addEventListener("mouseup", this.handlers.mouseup);
    }, t.prototype.unbindEvent = function() {
      var e = this.view.dom;
      e.removeEventListener("mousemove", this.handlers.mousemove), e.removeEventListener("mouseup", this.handlers.mouseup);
    }, t.prototype.getCellPos = function(e) {
      var r = e.clientX, n = e.clientY, a = this.view.posAtCoords({ left: r, top: n });
      if (a) {
        var i = this.view.state.doc, o = i.resolve(a.pos), u = Nm(o);
        if (u) {
          var m = o.before(u.depth);
          return i.resolve(m);
        }
      }
      return null;
    }, t.prototype.setCellSelection = function(e, r) {
      var n = this.view.state, a = n.selection, i = n.tr, o = wa.getState(this.view.state) === null, u = new jc(e, r);
      if (o || !a.eq(u)) {
        var m = i.setSelection(u);
        o && m.setMeta(wa, r.pos), this.view.dispatch(m);
      }
    }, t.prototype.destroy = function() {
      this.view.dom.removeEventListener("mousedown", this.handlers.mousedown);
    }, t;
  }()
), gUe = Ke("cell-selected");
function yUe(t) {
  var e = t.selection, r = t.doc;
  if (e instanceof jc) {
    var n = [], a = e.ranges;
    return a.forEach(function(i) {
      var o = i.$from, u = i.$to;
      n.push(ia.Decoration.node(o.pos - 1, u.pos + 1, { class: gUe }));
    }), ia.DecorationSet.create(r, n);
  }
  return null;
}
function bUe() {
  return new nt.Plugin({
    key: wa,
    state: {
      init: function() {
        return null;
      },
      apply: function(t, e) {
        var r = t.getMeta(wa);
        if (r)
          return r === -1 ? null : r;
        if (hs(e) || !t.docChanged)
          return e;
        var n = t.mapping.mapResult(e), a = n.deleted, i = n.pos;
        return a ? null : i;
      }
    },
    props: {
      decorations: yUe,
      createSelectionBetween: function(t) {
        var e = t.state;
        return hs(wa.getState(e)) ? null : e.selection;
      }
    },
    view: function(t) {
      return new mUe(t);
    }
  });
}
var Im = (
  /** @class */
  function() {
    function t() {
      this.keys = [], this.values = [];
    }
    return t.prototype.getKeyIndex = function(e) {
      return Ya(e, this.keys);
    }, t.prototype.get = function(e) {
      return this.values[this.getKeyIndex(e)];
    }, t.prototype.set = function(e, r) {
      var n = this.getKeyIndex(e);
      return n > -1 ? this.values[n] = r : (this.keys.push(e), this.values.push(r)), this;
    }, t.prototype.has = function(e) {
      return this.getKeyIndex(e) > -1;
    }, t.prototype.delete = function(e) {
      var r = this.getKeyIndex(e);
      return r > -1 ? (this.keys.splice(r, 1), this.values.splice(r, 1), !0) : !1;
    }, t.prototype.forEach = function(e, r) {
      var n = this;
      r === void 0 && (r = this), this.values.forEach(function(a, i) {
        a && n.keys[i] && e.call(r, a, n.keys[i], n);
      });
    }, t.prototype.clear = function() {
      this.keys = [], this.values = [];
    }, t;
  }()
), Bu = "en-US", kUe = (
  /** @class */
  function() {
    function t() {
      this.code = Bu, this.langs = new Im();
    }
    return t.prototype.setCode = function(e) {
      this.code = e || Bu;
    }, t.prototype.setLanguage = function(e, r) {
      var n = this;
      e = [].concat(e), e.forEach(function(a) {
        if (!n.langs.has(a))
          n.langs.set(a, r);
        else {
          var i = n.langs.get(a);
          n.langs.set(a, bc(i, r));
        }
      });
    }, t.prototype.get = function(e, r) {
      r || (r = this.code);
      var n = this.langs.get(r);
      n || (n = this.langs.get(Bu));
      var a = n[e];
      if (!a)
        throw new Error('There is no text key "' + e + '" in ' + r);
      return a;
    }, t;
  }()
), dt = new kUe(), wUe = [
  [
    {
      action: "Add row to up",
      command: "addRowToUp",
      disableInThead: !0,
      className: "add-row-up"
    },
    {
      action: "Add row to down",
      command: "addRowToDown",
      disableInThead: !0,
      className: "add-row-down"
    },
    { action: "Remove row", command: "removeRow", disableInThead: !0, className: "remove-row" }
  ],
  [
    { action: "Add column to left", command: "addColumnToLeft", className: "add-column-left" },
    { action: "Add column to right", command: "addColumnToRight", className: "add-column-right" },
    { action: "Remove column", command: "removeColumn", className: "remove-column" }
  ],
  [
    {
      action: "Align column to left",
      command: "alignColumn",
      payload: { align: "left" },
      className: "align-column-left"
    },
    {
      action: "Align column to center",
      command: "alignColumn",
      payload: { align: "center" },
      className: "align-column-center"
    },
    {
      action: "Align column to right",
      command: "alignColumn",
      payload: { align: "right" },
      className: "align-column-right"
    }
  ],
  [{ action: "Remove table", command: "removeTable", className: "remove-table" }]
];
function CUe(t, e) {
  return wUe.map(function(r) {
    return r.map(function(n) {
      var a = n.action, i = n.command, o = n.payload, u = n.disableInThead, m = n.className;
      return {
        label: dt.get(a),
        onClick: function() {
          t.emit("command", i, o);
        },
        disabled: e && !!u,
        className: m
      };
    });
  }).concat();
}
function TUe(t) {
  return new nt.Plugin({
    props: {
      handleDOMEvents: {
        contextmenu: function(e, r) {
          var n = Dm(r.target, e.dom);
          if (n) {
            r.preventDefault();
            var a = r, i = a.clientX, o = a.clientY, u = e.dom.parentNode.getBoundingClientRect(), m = u.left, y = u.top, C = n.nodeName === "TH";
            return t.emit("contextmenu", {
              pos: { left: i - m + 10 + "px", top: o - y + 30 + "px" },
              menuGroups: CUe(t, C),
              tableCell: n
            }), !0;
          }
          return !1;
        }
      }
    }
  });
}
function SUe() {
  return new nt.Plugin({
    props: {
      handleDOMEvents: {
        mousedown: function(t, e) {
          var r = e, n = r.clientX, a = r.clientY, i = t.posAtCoords({ left: n, top: a });
          if (i) {
            var o = t.state, u = o.doc, m = o.tr, y = u.resolve(i.pos), C = Oi(y), T = e.target, x = getComputedStyle(T, ":before"), M = e, P = M.offsetX, q = M.offsetY;
            if (!C || !Mc(x, P, q))
              return !1;
            e.preventDefault();
            var _ = y.before(C.depth), K = C.node.attrs;
            return m.setNodeMarkup(_, null, ge(ge({}, K), { checked: !K.checked })), t.dispatch(m), !0;
          }
          return !1;
        }
      }
    }
  });
}
var EUe = ["image", "link", "customBlock", "frontMatter"], xUe = ["strong", "strike", "emph", "code"], Pm = ["bulletList", "orderedList", "taskList"];
function AUe(t, e) {
  var r = t.type.name;
  return r === "listItem" ? t.attrs.task ? "taskList" : e.type.name : r.indexOf("table") !== -1 ? "table" : r;
}
function MUe(t, e) {
  e[t] = { active: !0 }, Pm.filter(function(r) {
    return r !== t;
  }).forEach(function(r) {
    e[r] && delete e[r];
  });
}
function LUe(t, e, r, n) {
  xUe.forEach(function(a) {
    var i = r.marks[a], o = t.marksAcross(e) || [], u = !!i.isInSet(o);
    u && (n[a] = { active: !0 });
  });
}
function OUe(t, e, r) {
  var n = t.$from, a = t.$to, i = t.from, o = t.to, u = {
    indent: { active: !1, disabled: !0 },
    outdent: { active: !1, disabled: !0 }
  };
  return e.nodesBetween(i, o, function(m, y, C) {
    var T = AUe(m, C);
    Ar(EUe, T) || (Ar(Pm, T) ? (MUe(T, u), u.indent.disabled = !1, u.outdent.disabled = !1) : T === "paragraph" || T === "text" ? LUe(n, a, r, u) : u[T] = { active: !0 });
  }), u;
}
function DUe(t) {
  return new nt.Plugin({
    view: function() {
      return {
        update: function(e) {
          var r = e.state, n = r.selection, a = r.doc, i = r.schema;
          t.emit("changeToolbarState", {
            toolbarState: OUe(n, a, i)
          });
        }
      };
    }
  });
}
var NUe = (
  /** @class */
  function() {
    function t(e, r, n, a) {
      var i = this;
      this.openEditor = function() {
        if (i.innerEditorView)
          throw new Error("The editor is already opened.");
        i.dom.draggable = !1, i.wrapper.style.display = "none", i.innerViewContainer.style.display = "block", i.innerEditorView = new ia.EditorView(i.innerViewContainer, {
          state: nt.EditorState.create({
            doc: i.node,
            plugins: [
              ro.keymap({
                "Mod-z": function() {
                  return eo(i.innerEditorView.state, i.innerEditorView.dispatch);
                },
                "Shift-Mod-z": function() {
                  return yc(i.innerEditorView.state, i.innerEditorView.dispatch);
                },
                Tab: function(o, u) {
                  return u(o.tr.insertText("	")), !0;
                },
                Enter: Qp,
                Escape: function() {
                  return i.cancelEditing(), !0;
                },
                "Ctrl-Enter": function() {
                  return i.saveAndFinishEditing(), !0;
                }
              }),
              oh()
            ]
          }),
          dispatchTransaction: function(o) {
            return i.dispatchInner(o);
          },
          handleDOMEvents: {
            mousedown: function() {
              return i.editorView.hasFocus() && i.innerEditorView.focus(), !0;
            },
            blur: function() {
              return i.saveAndFinishEditing(), !0;
            }
          }
        }), i.innerEditorView.focus();
      }, this.node = e, this.editorView = r, this.getPos = n, this.toDOMAdaptor = a, this.innerEditorView = null, this.canceled = !1, this.dom = document.createElement("div"), this.dom.className = Ke("custom-block"), this.wrapper = document.createElement("div"), this.wrapper.className = Ke("custom-block-view"), this.createInnerViewContainer(), this.renderCustomBlock(), this.dom.appendChild(this.innerViewContainer), this.dom.appendChild(this.wrapper);
    }
    return t.prototype.renderToolArea = function() {
      var e = this, r = document.createElement("div"), n = document.createElement("span"), a = document.createElement("button");
      r.className = "tool", n.textContent = this.node.attrs.info, n.className = "info", a.type = "button", a.addEventListener("click", function() {
        return e.openEditor();
      }), r.appendChild(n), r.appendChild(a), this.wrapper.appendChild(r);
    }, t.prototype.renderCustomBlock = function() {
      var e = this.toDOMAdaptor.getToDOMNode(this.node.attrs.info);
      if (e) {
        for (var r = e(this.node); this.wrapper.hasChildNodes(); )
          this.wrapper.removeChild(this.wrapper.lastChild);
        r && this.wrapper.appendChild(r), this.renderToolArea();
      }
    }, t.prototype.createInnerViewContainer = function() {
      this.innerViewContainer = document.createElement("div"), this.innerViewContainer.className = Ke("custom-block-editor"), this.innerViewContainer.style.display = "none";
    }, t.prototype.closeEditor = function() {
      this.innerEditorView && (this.innerEditorView.destroy(), this.innerEditorView = null, this.innerViewContainer.style.display = "none"), this.wrapper.style.display = "block";
    }, t.prototype.saveAndFinishEditing = function() {
      var e = this.editorView.state.selection.to, r = this.editorView.state;
      this.editorView.dispatch(r.tr.setSelection(Wt(r.tr, e))), this.editorView.focus(), this.renderCustomBlock(), this.closeEditor();
    }, t.prototype.cancelEditing = function() {
      var e = MJ(this.innerEditorView.state);
      for (this.canceled = !0; e--; )
        eo(this.innerEditorView.state, this.innerEditorView.dispatch), eo(this.editorView.state, this.editorView.dispatch);
      this.canceled = !1;
      var r = this.editorView.state.selection.to, n = this.editorView.state;
      this.editorView.dispatch(n.tr.setSelection(nt.TextSelection.create(n.doc, r))), this.editorView.focus(), this.closeEditor();
    }, t.prototype.dispatchInner = function(e) {
      var r = this.innerEditorView.state.applyTransaction(e), n = r.state, a = r.transactions;
      if (this.innerEditorView.updateState(n), !this.canceled && un(this.getPos)) {
        for (var i = this.editorView.state.tr, o = zt.StepMap.offset(this.getPos() + 1), u = 0; u < a.length; u += 1)
          for (var m = a[u].steps, y = 0; y < m.length; y += 1)
            i.step(m[y].map(o));
        i.docChanged && this.editorView.dispatch(i);
      }
    }, t.prototype.update = function(e) {
      return e.sameMarkup(this.node) ? (this.node = e, this.innerEditorView || this.renderCustomBlock(), !0) : !1;
    }, t.prototype.stopEvent = function(e) {
      return !!this.innerEditorView && !!e.target && this.innerEditorView.dom.contains(e.target);
    }, t.prototype.ignoreMutation = function() {
      return !0;
    }, t.prototype.destroy = function() {
      this.dom.removeEventListener("dblclick", this.openEditor), this.closeEditor();
    }, t;
  }()
), Fd = "image-link", RUe = (
  /** @class */
  function() {
    function t(e, r, n, a) {
      var i = this, o;
      this.handleMousedown = function(u) {
        u.preventDefault();
        var m = u.target, y = u.offsetX, C = u.offsetY;
        if (i.imageLink && un(i.getPos) && hh(m, Fd)) {
          var T = getComputedStyle(m, ":before");
          if (u.stopPropagation(), Mc(T, y, C)) {
            var x = i.view.state.tr, M = i.getPos();
            x.setSelection(Wt(x, M, M + 1)), i.view.dispatch(x), i.eventEmitter.emit("openPopup", "link", i.imageLink.attrs);
          }
        }
      }, this.node = e, this.view = r, this.getPos = n, this.eventEmitter = a, this.imageLink = (o = e.marks.filter(function(u) {
        var m = u.type;
        return m.name === "link";
      })[0]) !== null && o !== void 0 ? o : null, this.dom = this.createElement(), this.bindEvent();
    }
    return t.prototype.createElement = function() {
      var e = this.createImageElement(this.node);
      if (this.imageLink) {
        var r = document.createElement("span");
        return r.className = Fd, r.appendChild(e), r;
      }
      return e;
    }, t.prototype.createImageElement = function(e) {
      var r = document.createElement("img"), n = e.attrs, a = n.imageUrl, i = n.altText, o = or(e.attrs);
      return r.src = a, i && (r.alt = i), Dc(o, r), r;
    }, t.prototype.bindEvent = function() {
      this.imageLink && this.dom.addEventListener("mousedown", this.handleMousedown);
    }, t.prototype.stopEvent = function() {
      return !0;
    }, t.prototype.destroy = function() {
      this.imageLink && this.dom.removeEventListener("mousedown", this.handleMousedown);
    }, t;
  }()
), IUe = "toastui-editor-ww-code-block", PUe = "toastui-editor-ww-code-block-language", BUe = (
  /** @class */
  function() {
    function t(e, r, n, a) {
      var i = this;
      this.contentDOM = null, this.input = null, this.timer = null, this.handleMousedown = function(o) {
        var u = o.target, m = getComputedStyle(u, ":after");
        if (m.backgroundImage !== "none" && un(i.getPos)) {
          var y = i.view.coordsAtPos(i.getPos()), C = y.top, T = y.right;
          i.createLanguageEditor({ top: C, right: T });
        }
      }, this.handleKeydown = function(o) {
        o.key === "Enter" && i.input && (o.preventDefault(), i.changeLanguage());
      }, this.node = e, this.view = r, this.getPos = n, this.eventEmitter = a, this.createElement(), this.bindDOMEvent(), this.bindEvent();
    }
    return t.prototype.createElement = function() {
      var e = this.node.attrs.language, r = document.createElement("div");
      r.setAttribute("data-language", e || "text"), r.className = IUe;
      var n = this.createCodeBlockElement(), a = n.firstChild;
      r.appendChild(n), this.dom = r, this.contentDOM = a;
    }, t.prototype.createCodeBlockElement = function() {
      var e = document.createElement("pre"), r = document.createElement("code"), n = this.node.attrs.language, a = or(this.node.attrs);
      return n && r.setAttribute("data-language", n), Dc(a, e), e.appendChild(r), e;
    }, t.prototype.createLanguageEditor = function(e) {
      var r = this, n = e.top, a = e.right, i = document.createElement("span");
      i.className = PUe;
      var o = document.createElement("input");
      o.type = "text", o.value = this.node.attrs.language, i.appendChild(o), this.view.dom.parentElement.appendChild(i);
      var u = i.clientWidth;
      Dn(i, {
        top: n + 10 + "px",
        left: a - u - 10 + "px",
        width: u + "px"
      }), this.input = o, this.input.addEventListener("blur", function() {
        return r.changeLanguage();
      }), this.input.addEventListener("keydown", this.handleKeydown), this.clearTimer(), this.timer = setTimeout(function() {
        r.input.focus();
      });
    }, t.prototype.bindDOMEvent = function() {
      this.dom && this.dom.addEventListener("click", this.handleMousedown);
    }, t.prototype.bindEvent = function() {
      var e = this;
      this.eventEmitter.listen("scroll", function() {
        e.input && e.reset();
      });
    }, t.prototype.changeLanguage = function() {
      if (this.input && un(this.getPos)) {
        var e = this.input.value;
        this.reset();
        var r = this.getPos(), n = this.view.state.tr;
        n.setNodeMarkup(r, null, { language: e }), this.view.dispatch(n);
      }
    }, t.prototype.reset = function() {
      var e;
      if (!((e = this.input) === null || e === void 0) && e.parentElement) {
        var r = this.input.parentElement;
        this.input = null, Qa(r);
      }
    }, t.prototype.clearTimer = function() {
      this.timer && (clearTimeout(this.timer), this.timer = null);
    }, t.prototype.stopEvent = function() {
      return !0;
    }, t.prototype.update = function(e) {
      return e.sameMarkup(this.node) ? (this.node = e, !0) : !1;
    }, t.prototype.destroy = function() {
      this.reset(), this.clearTimer(), this.dom && this.dom.removeEventListener("click", this.handleMousedown);
    }, t;
  }()
), qUe = /MsoListParagraph/, Bm = /style=(.|\n)*mso-/, qm = /mso-list:(.*)/, FUe = /O:P/, _Ue = /^(n|u|l)/, HUe = "p.MsoListParagraph";
function UUe(t) {
  return Bm.test(t);
}
function zUe(t) {
  for (var e = [], r = document.createTreeWalker(t, 1, null, !1); r.nextNode(); ) {
    var n = r.currentNode;
    if (_s(n)) {
      var a = n, i = a.outerHTML, o = a.textContent, u = Bm.test(i), m = qm.test(i);
      u && !m && o ? e.push([n, !0]) : (FUe.test(n.nodeName) || u && !o || m) && e.push([n, !1]);
    }
  }
  return e.forEach(function(y) {
    var C = y[0], T = y[1];
    T ? s7(C) : Qa(C);
  }), t.innerHTML.trim();
}
function $Ue(t, e) {
  var r = t.getAttribute("style");
  if (r) {
    var n = r.match(qm), a = n[1], i = a.trim().split(" "), o = i[1], u = parseInt(o.replace("level", ""), 10), m = _Ue.test(t.textContent || "");
    return {
      id: e,
      level: u,
      prev: null,
      parent: null,
      children: [],
      unordered: m,
      contents: zUe(t)
    };
  }
  return null;
}
function VUe(t, e) {
  if (e.level < t.level)
    e.children.push(t), t.parent = e;
  else {
    for (; e && e.level !== t.level; )
      e = e.parent;
    e && (t.prev = e, t.parent = e.parent, t.parent && t.parent.children.push(t));
  }
}
function WUe(t) {
  var e = [];
  return t.forEach(function(r, n) {
    var a = e[n - 1], i = $Ue(r, n);
    i && (a && VUe(i, a), e.push(i));
  }), e;
}
function Fm(t) {
  var e = t[0].unordered ? "ul" : "ol", r = document.createElement(e);
  return t.forEach(function(n) {
    var a = n.children, i = n.contents, o = document.createElement("li");
    o.innerHTML = i, r.appendChild(o), a.length && r.appendChild(Fm(a));
  }), r;
}
function jUe(t) {
  var e = WUe(t), r = e.filter(function(n) {
    var a = n.parent;
    return !a;
  });
  return Fm(r);
}
function GUe(t) {
  for (; t && !_s(t); )
    t = t.nextSibling;
  return t ? !qUe.test(t.className) : !0;
}
function KUe(t) {
  var e = document.createElement("div");
  e.innerHTML = t;
  var r = [], n = a7(e, HUe);
  n.forEach(function(i) {
    var o = GUe(i.nextSibling);
    if (r.push(i), o) {
      var u = jUe(r), m = i.nextSibling;
      m ? o7(u, m) : i7(e, u), r = [];
    }
    Qa(i);
  });
  var a = n.length ? "<p></p>" : "";
  return "" + a + e.innerHTML;
}
var _d = "<!--StartFragment-->", JUe = "<!--EndFragment-->";
function YUe(t) {
  var e = t.indexOf(_d), r = t.lastIndexOf(JUe);
  return e > -1 && r > -1 && (t = t.slice(e + _d.length, r)), t.replace(/<br[^>]*>/g, kh);
}
function ZUe(t) {
  return /<\/td>((?!<\/tr>)[\s\S])*$/i.test(t) && (t = "<tr>" + t + "</tr>"), /<\/tr>((?!<\/table>)[\s\S])*$/i.test(t) && (t = "<table>" + t + "</table>"), t;
}
function QUe(t) {
  return t = YUe(t), t = ZUe(t), UUe(t) && (t = KUe(t)), t;
}
function XUe(t) {
  var e = t.reduce(function(r, n) {
    return r.childCount > n.childCount ? r : n;
  });
  return e.childCount;
}
function _m(t, e, r) {
  for (var n = [], a = t.childCount, i = 0; i < a; i += 1)
    if (!t.child(i).attrs.extended) {
      var o = i < a ? r.create(t.child(i).attrs, t.child(i).content) : r.createAndFill();
      n.push(o);
    }
  return n;
}
function Hm(t, e, r) {
  var n = r.nodes, a = n.tableRow, i = n.tableHeadCell, o = _m(t, e, i);
  return a.create(null, o);
}
function Um(t, e, r) {
  var n = r.nodes, a = n.tableRow, i = n.tableBodyCell, o = _m(t, e, i);
  return a.create(null, o);
}
function eze(t, e) {
  for (var r = e.nodes, n = r.tableRow, a = r.tableBodyCell, i = [], o = 0; o < t; o += 1) {
    var u = a.createAndFill();
    i.push(u);
  }
  return n.create({ dummyRowForPasting: !0 }, i);
}
function zm(t) {
  var e = [], r = [];
  if (t.firstChild.type.name === "tableHead") {
    var n = t.firstChild;
    n.forEach(function(i) {
      return e.push(i);
    });
  }
  if (t.lastChild.type.name === "tableBody") {
    var a = t.lastChild;
    a.forEach(function(i) {
      return r.push(i);
    });
  }
  return Wr(Wr([], e), r);
}
function tze(t, e, r) {
  var n = Hm(t, e, r);
  return r.nodes.tableHead.create(null, n);
}
function Hd(t, e, r) {
  var n = t.map(function(i) {
    return Um(i, e, r);
  });
  if (!t.length) {
    var a = eze(e, r);
    n.push(a);
  }
  return r.nodes.tableBody.create(null, n);
}
function rze(t, e, r, n) {
  var a = XUe(t);
  if (r && n)
    return e.nodes.table.create(null, [Hd(t, a, e)]);
  var i = t[0], o = t.slice(1), u = [tze(i, a, e)];
  return o.length && u.push(Hd(o, a, e)), e.nodes.table.create(null, u);
}
function nze(t, e, r) {
  var n = [], a = t.content, i = t.openStart, o = t.openEnd;
  return a.forEach(function(u) {
    if (u.type.name === "table") {
      var m = Rm(new Qe.Slice(Qe.Fragment.from(u), 0, 0));
      if (m) {
        var y = zm(m), C = m.firstChild.type.name === "tableBody", T = rze(y, e, C, r);
        n.push(T);
      }
    } else
      n.push(u);
  }), new Qe.Slice(Qe.Fragment.from(n), i, o);
}
var aze = 4, ize = 2;
function cs(t) {
  return t * aze;
}
function oze(t, e, r) {
  var n = [], a = zm(t), i = a[0].childCount, o = a.length, u = e.startRowIdx === 0, m = a.slice(0, o);
  if (u) {
    var y = m.shift();
    if (y) {
      var C = Hm(y, i, r).content;
      n.push(C);
    }
  }
  return m.forEach(function(T) {
    if (!T.attrs.dummyRowForPasting) {
      var x = Um(T, i, r).content;
      n.push(x);
    }
  }), n;
}
function sze(t, e, r) {
  for (var n = e.startRowIdx, a = e.startColIdx, i = r.length, o = 0, u = function(M) {
    var P = r[M].childCount;
    r[M].forEach(function(q) {
      var _ = q.attrs, K = _.colspan;
      K > 1 && (P += K - 1);
    }), o = Math.max(o, P);
  }, m = 0; m < i; m += 1)
    u(m);
  var y = n + i - 1, C = a + o - 1, T = Math.max(y + 1 - t.totalRowCount, 0), x = Math.max(C + 1 - t.totalColumnCount, 0);
  return {
    startRowIdx: n,
    startColIdx: a,
    endRowIdx: y,
    endColIdx: C,
    addedRowCount: T,
    addedColumnCount: x
  };
}
function lze(t, e) {
  for (var r = t.startRowIdx, n = t.startColIdx, a = t.endRowIdx, i = t.endColIdx, o = t.addedRowCount, u = t.addedColumnCount, m = r; m <= a - o; m += 1)
    e.push({
      rowIdx: m,
      startColIdx: n,
      endColIdx: i - u
    });
}
function uze(t, e, r, n, a) {
  for (var i = n.startRowIdx, o = n.startColIdx, u = n.endRowIdx, m = n.endColIdx, y = n.addedRowCount, C = n.addedColumnCount, T = r.totalRowCount, x = 0, M = 0; M < T; M += 1) {
    var P = r.getCellInfo(M, m - C), q = P.offset, _ = P.nodeSize, K = t.mapping.map(q + _), X = us(C, M, e);
    if (t.insert(K, X), M >= i && M <= u - y) {
      var ie = r.getCellInfo(M, m - C), ee = t.mapping.map(ie.offset), oe = K + cs(C);
      a[x] = {
        rowIdx: M,
        startColIdx: o,
        endColIdx: m,
        dummyOffsets: [ee, oe]
      }, x += 1;
    }
  }
}
function cze(t, e, r, n, a) {
  var i = n.addedRowCount, o = n.addedColumnCount, u = n.startColIdx, m = n.endColIdx, y = t.mapping.maps.length, C = r.tableEndOffset - 2, T = Om(i, r.totalColumnCount + o, e), x = C;
  t.insert(t.mapping.slice(y).map(x), T);
  for (var M = 0; M < i; M += 1) {
    var P = x + cs(u) + 1, q = x + cs(m + 1) + 1, _ = x + cs(r.totalColumnCount + o) + ize;
    a.push({
      rowIdx: M + r.totalRowCount,
      startColIdx: u,
      endColIdx: m,
      dummyOffsets: [P, q]
    }), x = _;
  }
}
function fze(t, e, r, n) {
  var a = t.mapping.maps.length;
  r.forEach(function(i, o) {
    var u = i.rowIdx, m = i.startColIdx, y = i.endColIdx, C = i.dummyOffsets, T = t.mapping.slice(a), x = new Qe.Slice(e[o], 0, 0), M = C ? C[0] : n.getCellStartOffset(u, m), P = C ? C[1] : n.getCellEndOffset(u, y);
    t.replace(T.map(M), T.map(P), x);
  });
}
function vze(t, e) {
  var r = t.state, n = r.selection, a = r.schema, i = r.tr, o = An(n), u = o.anchor, m = o.head;
  if (u && m) {
    var y = Rm(e);
    if (!y)
      return !1;
    var C = Sr.create(u), T = C.getRectOffsets(u, m), x = oze(y, T, a), M = sze(C, T, x), P = [];
    return pze(C, M) && (lze(M, P), M.addedColumnCount && uze(i, a, C, M, P), M.addedRowCount && cze(i, a, C, M, P), fze(i, x, P, C), t.dispatch(i), dze(t, P, C.getCellInfo(0, 0).offset)), !0;
  }
  return !1;
}
function dze(t, e, r) {
  var n = t.state, a = n.tr, i = n.doc, o = Sr.create(i.resolve(r)), u = e[0], m = u.rowIdx, y = u.startColIdx, C = Dr(e), T = C.rowIdx, x = C.endColIdx, M = o.getCellInfo(m, y).offset, P = o.getCellInfo(T, x).offset;
  t.dispatch(a.setSelection(new jc(i.resolve(M), i.resolve(P))));
}
function pze(t, e) {
  var r = t.getSpannedOffsets(e), n = ki(r), a = n.rowCount, i = n.columnCount, o = ki(e), u = o.rowCount, m = o.columnCount;
  return a === u && i === m;
}
var hze = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "doc";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "block+"
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }($t)
), mze = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "paragraph";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "inline*",
          group: "block",
          attrs: ge({}, wr()),
          parseDOM: [{ tag: "p" }],
          toDOM: function(r) {
            var n = r.attrs;
            return ["p", or(n), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }($t)
), gze = /\s{1,4}$/, yze = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "text";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          group: "inline"
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.addSpaces = function() {
      return function(r, n) {
        var a = r.selection, i = r.tr, o = a.$from, u = a.$to, m = o.blockRange(u);
        return m && !Li(o) && !Ls(o) ? (n(i.insertText("    ", o.pos, u.pos)), !0) : !1;
      };
    }, e.prototype.removeSpaces = function() {
      return function(r, n) {
        var a = r.selection, i = r.tr, o = a.$from, u = a.$to, m = a.from, y = o.blockRange(u);
        if (y && !Li(o) && !Ls(o)) {
          var C = o.nodeBefore;
          if (C && C.isText) {
            var T = C.text, x = T.replace(gze, ""), M = T.length - x.length;
            return n(i.delete(m - M, m)), !0;
          }
        }
        return !1;
      };
    }, e.prototype.keymaps = function() {
      return {
        Tab: this.addSpaces(),
        "Shift-Tab": this.removeSpaces()
      };
    }, e;
  }($t)
), bze = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "heading";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "levels", {
      get: function() {
        return [1, 2, 3, 4, 5, 6];
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        var r = this.levels.map(function(n) {
          return {
            tag: "h" + n,
            getAttrs: function(a) {
              var i = a.getAttribute("data-raw-html");
              return ge({ level: n }, i && { rawHTML: i });
            }
          };
        });
        return {
          attrs: ge({ level: { default: 1 }, headingType: { default: "atx" }, rawHTML: { default: null } }, wr()),
          content: "inline*",
          group: "block",
          defining: !0,
          parseDOM: r,
          toDOM: function(n) {
            var a = n.attrs;
            return ["h" + a.level, or(a), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return function(r) {
        return function(n, a) {
          var i = n.schema.nodes[r.level ? "heading" : "paragraph"];
          return gc(i, r)(n, a);
        };
      };
    }, e;
  }($t)
), kze = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "codeBlock";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "text*",
          group: "block",
          attrs: ge({ language: { default: null }, rawHTML: { default: null } }, wr()),
          code: !0,
          defining: !0,
          marks: "",
          parseDOM: [
            {
              tag: "pre",
              preserveWhitespace: "full",
              getAttrs: function(r) {
                var n = r.getAttribute("data-raw-html"), a = r.firstElementChild;
                return ge({ language: (a == null ? void 0 : a.getAttribute("data-language")) || null }, n && { rawHTML: n });
              }
            }
          ],
          toDOM: function(r) {
            var n = r.attrs;
            return [
              n.rawHTML || "pre",
              ["code", ge({ "data-language": n.language }, or(n)), 0]
            ];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return function() {
        return function(r, n) {
          return gc(r.schema.nodes.codeBlock)(r, n);
        };
      };
    }, e.prototype.moveCursor = function(r) {
      var n = this;
      return function(a, i) {
        var o = a.tr, u = a.doc, m = a.schema, y = a.selection.$from, C = n.context.view;
        if (C.endOfTextblock(r) && y.node().type.name === "codeBlock") {
          var T = y.parent.textContent.split(`
`), x = r === "up" ? y.start() : y.end(), M = r === "up" ? [x, T[0].length + x] : [x - Dr(T).length, x], P = u.resolve(r === "up" ? y.before() : y.after()), q = r === "up" ? P.nodeBefore : P.nodeAfter;
          if (xY(y.pos, M[0], M[1]) && !q) {
            var _ = xc(o, P, m);
            if (_)
              return i(_), !0;
          }
        }
        return !1;
      };
    }, e.prototype.keymaps = function() {
      var r = this.commands()();
      return {
        "Shift-Mod-p": r,
        "Shift-Mod-P": r,
        ArrowUp: this.moveCursor("up"),
        ArrowDown: this.moveCursor("down")
      };
    }, e;
  }($t)
), wze = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "bulletList";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "listItem+",
          group: "block",
          attrs: ge({ rawHTML: { default: null } }, wr()),
          parseDOM: [js("ul")],
          toDOM: function(r) {
            var n = r.attrs;
            return ["ul", or(n), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.changeList = function() {
      return function(r, n) {
        return Lm(r.schema.nodes.bulletList)(r, n);
      };
    }, e.prototype.commands = function() {
      return {
        bulletList: this.changeList,
        taskList: rUe
      };
    }, e.prototype.keymaps = function() {
      var r = this.changeList(), n = Wc(), a = n.indent, i = n.outdent;
      return {
        "Mod-u": r,
        "Mod-U": r,
        Tab: a(),
        "Shift-Tab": i()
      };
    }, e;
  }($t)
), Cze = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "orderedList";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "listItem+",
          group: "block",
          attrs: ge({ order: { default: 1 }, rawHTML: { default: null } }, wr()),
          parseDOM: [
            {
              tag: "ol",
              getAttrs: function(r) {
                var n = r.getAttribute("start"), a = r.getAttribute("data-raw-html");
                return ge({ order: r.hasAttribute("start") ? Number(n) : 1 }, a && { rawHTML: a });
              }
            }
          ],
          toDOM: function(r) {
            var n = r.attrs;
            return [
              n.rawHTML || "ol",
              ge({ start: n.order === 1 ? null : n.order }, or(n)),
              0
            ];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return function() {
        return function(r, n) {
          return Lm(r.schema.nodes.orderedList)(r, n);
        };
      };
    }, e.prototype.keymaps = function() {
      var r = this.commands()(), n = Wc(), a = n.indent, i = n.outdent;
      return {
        "Mod-o": r,
        "Mod-O": r,
        Tab: a(),
        "Shift-Tab": i()
      };
    }, e;
  }($t)
), Tze = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "listItem";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "paragraph block*",
          selectable: !1,
          attrs: {
            task: { default: !1 },
            checked: { default: !1 },
            rawHTML: { default: null }
          },
          defining: !0,
          parseDOM: [
            {
              tag: "li",
              getAttrs: function(r) {
                var n = r.getAttribute("data-raw-html");
                return ge({ task: r.hasAttribute("data-task"), checked: r.hasAttribute("data-task-checked") }, n && { rawHTML: n });
              }
            }
          ],
          toDOM: function(r) {
            var n = r.attrs, a = n.task, i = n.checked;
            if (!a)
              return [n.rawHTML || "li", 0];
            var o = ["task-list-item"];
            return i && o.push("checked"), [
              n.rawHTML || "li",
              ge({ class: o.join(" "), "data-task": a }, i && { "data-task-checked": i }),
              0
            ];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.liftToPrevListItem = function() {
      return function(r, n) {
        var a = r.selection, i = r.tr, o = r.schema, u = a.$from, m = a.empty, y = o.nodes.listItem, C = u.parent, T = u.node(-1);
        if (m && !C.childCount && T.type === y) {
          if (u.index(-2) >= 1)
            return i.delete(u.start(-1) - 1, u.end(-1)), n(i), !0;
          var x = u.node(-3);
          if (x.type === y)
            return i.delete(u.start(-2) - 1, u.end(-1)), n(i), !0;
        }
        return !1;
      };
    }, e.prototype.keymaps = function() {
      var r = function(n, a) {
        return sUe(n.schema.nodes.listItem)(n, a);
      };
      return {
        Backspace: this.liftToPrevListItem(),
        Enter: r
      };
    }, e;
  }($t)
), Sze = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "blockQuote";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          attrs: ge({ rawHTML: { default: null } }, wr()),
          content: "block+",
          group: "block",
          parseDOM: [js("blockquote")],
          toDOM: function(r) {
            var n = r.attrs;
            return ["blockquote", or(n), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return function() {
        return function(r, n) {
          return yJ(r.schema.nodes.blockQuote)(r, n);
        };
      };
    }, e.prototype.keymaps = function() {
      var r = this.commands()();
      return {
        "Alt-q": r,
        "Alt-Q": r
      };
    }, e;
  }($t)
), Eze = {
  left: Rze,
  right: Nze,
  up: Ize,
  down: Pze
};
function xze(t, e, r) {
  var n = r[0], a = r[1], i = e.resolve(t.before(n - 1));
  return a === n && !i.nodeBefore;
}
function Aze(t) {
  for (var e, r = t.depth, n; r && (n = t.node(r), n.type.name !== "tableBodyCell"); ) {
    if (n.type.name === "listItem") {
      var a = t.node(r - 1), i = a.lastChild === n, o = ((e = n.lastChild) === null || e === void 0 ? void 0 : e.type.name) !== "paragraph";
      return i ? !o : !1;
    }
    r -= 1;
  }
  return !1;
}
function Mze(t, e, r, n, a) {
  var i = e[0], o = e[1], u = e[2];
  if (t === "left" || t === "up") {
    if (a && !xze(r, n, [i, o]))
      return !1;
    var m = r.before(u), y = n.resolve(m).nodeBefore;
    if (y)
      return !1;
  }
  return !0;
}
function Lze(t, e, r, n, a) {
  if (t === "right" || t === "down") {
    if (a && !Aze(r))
      return !1;
    var i = r.after(e), o = n.resolve(i).nodeAfter;
    if (o)
      return !1;
  }
  return !0;
}
function Oze(t, e, r, n) {
  var a = e[0], i = e[1], o = a + 3, u = i >= o, m = u ? a + 1 : i, y = Mze(t, [i, o, m], r, n, u), C = Lze(t, m, r, n, u);
  return y && C;
}
function Ud(t, e, r) {
  var n = r[0], a = r[1], i = e.getRowspanStartInfo(n, a), o = t === "up" && n === 0, u = t === "down" && ((i == null ? void 0 : i.count) > 1 ? n + i.count - 1 : n) === e.totalRowCount - 1;
  return o || u;
}
function Dze(t, e, r) {
  var n = t.doc.resolve(e.tableStartOffset - 1);
  return n.nodeBefore ? t.setSelection(nt.Selection.near(n, -1)) : xc(t, n, r);
}
function qu(t, e, r, n) {
  n === void 0 && (n = !1);
  var a = t.doc.resolve(e.tableEndOffset);
  return n || !a.nodeAfter ? xc(t, a, r) : t.setSelection(nt.Selection.near(a, 1));
}
function Nze(t, e) {
  var r = t[0], n = t[1], a = e.totalRowCount, i = e.totalColumnCount, o = n === i - 1, u = r === a - 1 && o;
  if (!u) {
    var m = n + 1, y = e.getColspanStartInfo(r, n);
    (y == null ? void 0 : y.count) > 1 && (m += y.count - 1), (o || m === i) && (r += 1, m = 0);
    var C = e.getCellInfo(r, m).offset;
    return C + 2;
  }
  return null;
}
function Rze(t, e) {
  var r = t[0], n = t[1], a = e.totalColumnCount, i = n === 0, o = r === 0 && i;
  if (!o) {
    n -= 1, i && (r -= 1, n = a - 1);
    var u = e.getCellInfo(r, n), m = u.offset, y = u.nodeSize;
    return m + y - 2;
  }
  return null;
}
function Ize(t, e) {
  var r = t[0], n = t[1];
  if (r > 0) {
    var a = e.getCellInfo(r - 1, n), i = a.offset, o = a.nodeSize;
    return i + o - 2;
  }
  return null;
}
function Pze(t, e) {
  var r = t[0], n = t[1], a = e.totalRowCount;
  if (r < a - 1) {
    var i = r + 1, o = e.getRowspanStartInfo(r, n);
    (o == null ? void 0 : o.count) > 1 && (i += o.count - 1);
    var u = e.getCellInfo(i, n).offset;
    return u + 2;
  }
  return null;
}
function zd(t, e, r, n) {
  var a = Eze[t], i = a(r, n);
  if (i) {
    var o = t === "right" || t === "down" ? 1 : -1;
    return e.setSelection(nt.Selection.near(e.doc.resolve(i), o));
  }
  return null;
}
function Bze(t, e, r) {
  var n = r[0], a = r[1];
  if (t === "up" || t === "down")
    return !1;
  var i = e.tableStartOffset, o = e.tableEndOffset, u = e.getCellInfo(n, a), m = u.offset, y = u.nodeSize, C = t === "left" ? i : o, T = t === "left" ? m - 2 : m + y + 3;
  return C === T;
}
function qze(t, e, r) {
  var n = t.doc.resolve(e.before(r - 3));
  return t.setSelection(new nt.NodeSelection(n));
}
function Fze(t, e, r) {
  var n, a, i;
  return t === "up" ? (n = r.startRowIdx, a = 0, i = -1) : (n = r.endRowIdx, a = e.totalColumnCount - 1, i = e.getCellInfo(n, a).nodeSize + 1), { targetRowIdx: n, insertColIdx: a, nodeSize: i };
}
function _ze(t, e, r) {
  var n = t.getCellInfo(e, 0).offset, a = t.getCellInfo(e, r - 1), i = a.offset, o = a.nodeSize;
  return { from: n, to: i + o };
}
var Hze = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "table";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "tableHead{1} tableBody{1}",
          group: "block",
          attrs: ge({ rawHTML: { default: null } }, wr()),
          parseDOM: [js("table")],
          toDOM: function(r) {
            var n = r.attrs;
            return ["table", or(n), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.addTable = function() {
      return function(r) {
        return r === void 0 && (r = { rowCount: 2, columnCount: 1, data: [] }), function(n, a) {
          var i = r.rowCount, o = r.columnCount, u = r.data, m = n.schema, y = n.selection, C = n.tr, T = y.from, x = y.to, M = y.$from, P = T === x;
          if (P && !Ls(M)) {
            var q = m.nodes, _ = q.tableHead, K = q.tableBody, X = u == null ? void 0 : u.slice(0, o), ie = u == null ? void 0 : u.slice(o, u.length), ee = dUe(o, m, X), oe = Om(i - 1, o, m, ie), ue = m.nodes.table.create(null, [
              _.create(null, ee),
              K.create(null, oe)
            ]);
            return a(C.replaceSelectionWith(ue)), !0;
          }
          return !1;
        };
      };
    }, e.prototype.removeTable = function() {
      return function() {
        return function(r, n) {
          var a = r.selection, i = r.tr, o = Sr.create(a.$anchor);
          if (o) {
            var u = o.tableStartOffset, m = o.tableEndOffset, y = u - 1, C = Wt(i.delete(y, m), y);
            return n(i.setSelection(C)), !0;
          }
          return !1;
        };
      };
    }, e.prototype.addColumn = function(r) {
      return function() {
        return function(n, a) {
          var i = n.selection, o = n.tr, u = n.schema, m = An(i), y = m.anchor, C = m.head;
          if (y && C) {
            for (var T = Sr.create(y), x = T.getRectOffsets(y, C), M = r === "left" ? x.startColIdx : x.endColIdx + 1, P = ki(x).columnCount, q = T.totalRowCount, _ = 0; _ < q; _ += 1) {
              var K = us(P, _, u);
              o.insert(o.mapping.map(T.posAt(_, M)), K);
            }
            return a(o), !0;
          }
          return !1;
        };
      };
    }, e.prototype.removeColumn = function() {
      return function() {
        return function(r, n) {
          var a = r.selection, i = r.tr, o = An(a), u = o.anchor, m = o.head;
          if (u && m) {
            var y = Sr.create(u), C = y.getRectOffsets(u, m), T = y.totalColumnCount, x = y.totalRowCount, M = ki(C).columnCount, P = M === T;
            if (P)
              return !1;
            for (var q = C.startColIdx, _ = C.endColIdx, K = i.mapping.maps.length, X = 0; X < x; X += 1)
              for (var ie = _; ie >= q; ie -= 1) {
                var ee = y.getCellInfo(X, ie), oe = ee.offset, ue = ee.nodeSize, pe = i.mapping.slice(K).map(oe), Se = pe + ue;
                i.delete(pe, Se);
              }
            return n(i), !0;
          }
          return !1;
        };
      };
    }, e.prototype.addRow = function(r) {
      return function() {
        return function(n, a) {
          var i = n.selection, o = n.schema, u = n.tr, m = An(i), y = m.anchor, C = m.head;
          if (y && C) {
            var T = Sr.create(y), x = T.totalColumnCount, M = T.getRectOffsets(y, C), P = ki(M).rowCount, q = Fze(r, T, M), _ = q.targetRowIdx, K = q.insertColIdx, X = q.nodeSize, ie = _ === 0;
            if (!ie) {
              for (var ee = [], oe = u.mapping.map(T.posAt(_, K)) + X, ue = [], pe = 0; pe < x; pe += 1)
                ue = ue.concat(us(1, _, o));
              for (var Se = 0; Se < P; Se += 1)
                ee.push(o.nodes.tableRow.create(null, ue));
              return a(u.insert(oe, ee)), !0;
            }
          }
          return !1;
        };
      };
    }, e.prototype.removeRow = function() {
      return function() {
        return function(r, n) {
          var a = r.selection, i = r.tr, o = An(a), u = o.anchor, m = o.head;
          if (u && m) {
            var y = Sr.create(u), C = y.totalRowCount, T = y.totalColumnCount, x = y.getRectOffsets(u, m), M = ki(x).rowCount, P = x.startRowIdx, q = x.endRowIdx, _ = P === 0, K = M === C - 1;
            if (K || _)
              return !1;
            for (var X = q; X >= P; X -= 1) {
              var ie = _ze(y, X, T), ee = ie.from, oe = ie.to;
              i.delete(ee - 1, oe + 1);
            }
            return n(i), !0;
          }
          return !1;
        };
      };
    }, e.prototype.alignColumn = function() {
      return function(r) {
        return r === void 0 && (r = { align: "center" }), function(n, a) {
          var i = r.align, o = n.selection, u = n.tr, m = An(o), y = m.anchor, C = m.head;
          if (y && C) {
            for (var T = Sr.create(y), x = T.totalRowCount, M = T.getRectOffsets(y, C), P = M.startColIdx, q = M.endColIdx, _ = 0; _ < x; _ += 1)
              for (var K = P; K <= q; K += 1)
                if (!T.extendedRowspan(_, K) && !T.extendedColspan(_, K)) {
                  var X = T.getNodeAndPos(_, K), ie = X.node, ee = X.pos, oe = pUe(ie, { align: i });
                  u.setNodeMarkup(ee, null, oe);
                }
            return a(u), !0;
          }
          return !1;
        };
      };
    }, e.prototype.moveToCell = function(r) {
      return function(n, a) {
        var i = n.selection, o = n.tr, u = n.schema, m = An(i), y = m.anchor, C = m.head;
        if (y && C) {
          var T = Sr.create(y), x = T.getCellIndex(y), M = void 0;
          if (Ud(r, T, x) ? M = qu(o, T, u) : M = zd(r, o, x, T), M)
            return a(M), !0;
        }
        return !1;
      };
    }, e.prototype.moveInCell = function(r) {
      var n = this;
      return function(a, i) {
        var o = a.selection, u = a.tr, m = a.doc, y = a.schema, C = o.$from, T = n.context.view;
        if (!T.endOfTextblock(r))
          return !1;
        var x = ta(C, function(ie) {
          var ee = ie.type;
          return ee.name === "tableHeadCell" || ee.name === "tableBodyCell";
        });
        if (x) {
          var M = ta(C, function(ie) {
            var ee = ie.type;
            return ee.name === "paragraph";
          }), P = x.depth;
          if (M && Oze(r, [P, M.depth], C, m)) {
            var q = An(o).anchor, _ = Sr.create(q), K = _.getCellIndex(q), X = void 0;
            if (Bze(r, _, K) ? X = qze(u, C, P) : Ud(r, _, K) ? r === "up" ? X = Dze(u, _, y) : r === "down" && (X = qu(u, _, y)) : X = zd(r, u, K, _), X)
              return i(X), !0;
          }
        }
        return !1;
      };
    }, e.prototype.deleteCells = function() {
      return function(r, n) {
        var a = r.schema, i = r.selection, o = r.tr, u = An(i), m = u.anchor, y = u.head, C = i instanceof nt.TextSelection;
        if (m && y && !C) {
          for (var T = Sr.create(m), x = T.getRectOffsets(m, y), M = x.startRowIdx, P = x.startColIdx, q = x.endRowIdx, _ = x.endColIdx, K = M; K <= q; K += 1)
            for (var X = P; X <= _; X += 1)
              if (!T.extendedRowspan(K, X) && !T.extendedColspan(K, X)) {
                var ie = T.getNodeAndPos(K, X), ee = ie.node, oe = ie.pos, ue = us(1, K, a, ee.attrs);
                o.replaceWith(o.mapping.map(oe), o.mapping.map(oe + ee.nodeSize), ue);
              }
          return n(o), !0;
        }
        return !1;
      };
    }, e.prototype.exitTable = function() {
      return function(r, n) {
        var a = r.selection, i = r.tr, o = r.schema, u = a.$from, m = ta(u, function(x) {
          var M = x.type;
          return M.name === "tableHeadCell" || M.name === "tableBodyCell";
        });
        if (m) {
          var y = ta(u, function(x) {
            var M = x.type;
            return M.name === "paragraph";
          });
          if (y) {
            var C = An(a).anchor, T = Sr.create(C);
            return n(qu(i, T, o, !0)), !0;
          }
        }
        return !1;
      };
    }, e.prototype.commands = function() {
      return {
        addTable: this.addTable(),
        removeTable: this.removeTable(),
        addColumnToLeft: this.addColumn(
          "left"
          /* LEFT */
        ),
        addColumnToRight: this.addColumn(
          "right"
          /* RIGHT */
        ),
        removeColumn: this.removeColumn(),
        addRowToUp: this.addRow(
          "up"
          /* UP */
        ),
        addRowToDown: this.addRow(
          "down"
          /* DOWN */
        ),
        removeRow: this.removeRow(),
        alignColumn: this.alignColumn()
      };
    }, e.prototype.keymaps = function() {
      var r = this.deleteCells();
      return {
        Tab: this.moveToCell(
          "right"
          /* RIGHT */
        ),
        "Shift-Tab": this.moveToCell(
          "left"
          /* LEFT */
        ),
        ArrowUp: this.moveInCell(
          "up"
          /* UP */
        ),
        ArrowDown: this.moveInCell(
          "down"
          /* DOWN */
        ),
        ArrowLeft: this.moveInCell(
          "left"
          /* LEFT */
        ),
        ArrowRight: this.moveInCell(
          "right"
          /* RIGHT */
        ),
        Backspace: r,
        "Mod-Backspace": r,
        Delete: r,
        "Mod-Delete": r,
        "Mod-Enter": this.exitTable()
      };
    }, e;
  }($t)
), Uze = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "tableHead";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "tableRow{1}",
          attrs: ge({ rawHTML: { default: null } }, wr()),
          parseDOM: [js("thead")],
          toDOM: function(r) {
            var n = r.attrs;
            return ["thead", or(n), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }($t)
), zze = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "tableBody";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "tableRow+",
          attrs: ge({ rawHTML: { default: null } }, wr()),
          parseDOM: [
            {
              tag: "tbody",
              getAttrs: function(r) {
                var n = r.querySelectorAll("tr"), a = n[0].children.length, i = r.getAttribute("data-raw-html");
                return a ? ge({}, i && { rawHTML: i }) : !1;
              }
            }
          ],
          toDOM: function(r) {
            var n = r.attrs;
            return ["tbody", or(n), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }($t)
), $ze = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "tableRow";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "(tableHeadCell | tableBodyCell)*",
          attrs: ge({ rawHTML: { default: null } }, wr()),
          parseDOM: [
            {
              tag: "tr",
              getAttrs: function(r) {
                var n = r.children.length, a = r.getAttribute("data-raw-html");
                return n ? ge({}, a && { rawHTML: a }) : !1;
              }
            }
          ],
          toDOM: function(r) {
            var n = r.attrs;
            return ["tr", or(n), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }($t)
), Vze = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "tableHeadCell";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "paragraph+",
          attrs: ge({ align: { default: null }, className: { default: null }, rawHTML: { default: null }, colspan: { default: null }, extended: { default: null } }, wr()),
          isolating: !0,
          parseDOM: [xm("th")],
          toDOM: function(r) {
            var n = r.attrs, a = Em(n);
            return ["th", ge(ge({}, a), or(n)), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }($t)
), Wze = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "tableBodyCell";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "(paragraph | bulletList | orderedList)+",
          attrs: {
            align: { default: null },
            className: { default: null },
            rawHTML: { default: null },
            colspan: { default: null },
            rowspan: { default: null },
            extended: { default: null }
          },
          isolating: !0,
          parseDOM: [xm("td")],
          toDOM: function(r) {
            var n = r.attrs, a = Em(n);
            return ["td", a, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }($t)
), jze = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "image";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          inline: !0,
          attrs: ge({ imageUrl: { default: "" }, altText: { default: null }, rawHTML: { default: null } }, wr()),
          group: "inline",
          selectable: !1,
          parseDOM: [
            {
              tag: "img[src]",
              getAttrs: function(r) {
                var n = ti(r, { RETURN_DOM_FRAGMENT: !0 }).firstChild, a = n.getAttribute("src") || "", i = n.getAttribute("data-raw-html"), o = n.getAttribute("alt");
                return ge({
                  imageUrl: a,
                  altText: o
                }, i && { rawHTML: i });
              }
            }
          ],
          toDOM: function(r) {
            var n = r.attrs;
            return [
              n.rawHTML || "img",
              ge(ge({ src: bi(n.imageUrl) }, n.altText && { alt: n.altText }), or(n))
            ];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.addImage = function() {
      return function(r) {
        return function(n, a) {
          var i = n.schema, o = n.tr, u = r, m = u.imageUrl, y = u.altText;
          if (!m)
            return !1;
          var C = i.nodes.image.createAndFill(ge({ imageUrl: m }, y && { altText: y }));
          return a(o.replaceSelectionWith(C).scrollIntoView()), !0;
        };
      };
    }, e.prototype.commands = function() {
      return {
        addImage: this.addImage()
      };
    }, e;
  }($t)
), $d = 1, Gze = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "thematicBreak";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          attrs: ge({ rawHTML: { default: null } }, wr()),
          group: "block",
          parseDOM: [{ tag: "hr" }],
          selectable: !1,
          toDOM: function(r) {
            var n = r.attrs;
            return ["div", or(n), [n.rawHTML || "hr"]];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.hr = function() {
      var r = this;
      return function() {
        return function(n, a) {
          var i, o = n.selection, u = o.$from, m = o.$to;
          if (u === m) {
            var y = n.doc, C = n.schema.nodes, T = C.thematicBreak, x = C.paragraph, M = [T.create()], P = u.node($d), q = y.child(y.childCount - 1) === P, _ = y.resolve(u.after($d)), K = ((i = u.nodeAfter) === null || i === void 0 ? void 0 : i.type.name) === r.name;
            return (q || K) && M.push(x.create()), a(n.tr.insert(_.pos, M).scrollIntoView()), !0;
          }
          return !1;
        };
      };
    }, e.prototype.commands = function() {
      return { hr: this.hr() };
    }, e.prototype.keymaps = function() {
      var r = this.hr()();
      return {
        "Mod-l": r,
        "Mod-L": r
      };
    }, e;
  }($t)
), Kze = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "strong";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        var r = ["b", "strong"].map(function(n) {
          return {
            tag: n,
            getAttrs: function(a) {
              var i = a.getAttribute("data-raw-html");
              return ge({}, i && { rawHTML: i });
            }
          };
        });
        return {
          attrs: ge({ rawHTML: { default: null } }, wr()),
          parseDOM: r,
          toDOM: function(n) {
            var a = n.attrs;
            return [a.rawHTML || "strong", or(a)];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.bold = function() {
      return function() {
        return function(r, n) {
          return so(r.schema.marks.strong)(r, n);
        };
      };
    }, e.prototype.commands = function() {
      return { bold: this.bold() };
    }, e.prototype.keymaps = function() {
      var r = this.bold()();
      return {
        "Mod-b": r,
        "Mod-B": r
      };
    }, e;
  }(jt)
), Jze = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "emph";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        var r = ["i", "em"].map(function(n) {
          return {
            tag: n,
            getAttrs: function(a) {
              var i = a.getAttribute("data-raw-html");
              return ge({}, i && { rawHTML: i });
            }
          };
        });
        return {
          attrs: ge({ rawHTML: { default: null } }, wr()),
          parseDOM: r,
          toDOM: function(n) {
            var a = n.attrs;
            return [a.rawHTML || "em", or(a)];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.italic = function() {
      return function() {
        return function(r, n) {
          return so(r.schema.marks.emph)(r, n);
        };
      };
    }, e.prototype.commands = function() {
      return { italic: this.italic() };
    }, e.prototype.keymaps = function() {
      var r = this.italic()();
      return {
        "Mod-i": r,
        "Mod-I": r
      };
    }, e;
  }(jt)
), Yze = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "strike";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        var r = ["s", "del"].map(function(n) {
          return {
            tag: n,
            getAttrs: function(a) {
              var i = a.getAttribute("data-raw-html");
              return ge({}, i && { rawHTML: i });
            }
          };
        });
        return {
          attrs: ge({ rawHTML: { default: null } }, wr()),
          parseDOM: r,
          toDOM: function(n) {
            var a = n.attrs;
            return [a.rawHTML || "del", or(a)];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return function() {
        return function(r, n) {
          return so(r.schema.marks.strike)(r, n);
        };
      };
    }, e.prototype.keymaps = function() {
      var r = this.commands()();
      return {
        "Mod-s": r,
        "Mod-S": r
      };
    }, e;
  }(jt)
), Zze = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e(r) {
      var n = t.call(this) || this;
      return n.linkAttributes = r, n;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "link";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        var r = this;
        return {
          attrs: ge({ linkUrl: { default: "" }, title: { default: null }, rawHTML: { default: null } }, wr()),
          inclusive: !1,
          parseDOM: [
            {
              tag: "a[href]",
              getAttrs: function(n) {
                var a = ti(n, { RETURN_DOM_FRAGMENT: !0 }).firstChild, i = a.getAttribute("href") || "", o = a.getAttribute("title") || "", u = a.getAttribute("data-raw-html");
                return ge({ linkUrl: i, title: o }, u && { rawHTML: u });
              }
            }
          ],
          toDOM: function(n) {
            var a = n.attrs;
            return [
              a.rawHTML || "a",
              ge(ge({ href: bi(a.linkUrl) }, r.linkAttributes), or(a))
            ];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.addLink = function() {
      return function(r) {
        return function(n, a) {
          var i = r, o = i.linkUrl, u = i.linkText, m = u === void 0 ? "" : u, y = n.schema, C = n.tr, T = n.selection, x = T.empty, M = T.from, P = T.to;
          if (M && P && o) {
            var q = { linkUrl: o }, _ = y.mark("link", q);
            if (x && m) {
              var K = xr(y, m, _);
              C.replaceRangeWith(M, P, K);
            } else
              C.addMark(M, P, _);
            return a(C.scrollIntoView()), !0;
          }
          return !1;
        };
      };
    }, e.prototype.toggleLink = function() {
      return function(r) {
        return function(n, a) {
          return so(n.schema.marks.link, r)(n, a);
        };
      };
    }, e.prototype.commands = function() {
      return {
        addLink: this.addLink(),
        toggleLink: this.toggleLink()
      };
    }, e;
  }(jt)
), Qze = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "code";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          attrs: ge({ rawHTML: { default: null } }, wr()),
          parseDOM: [
            {
              tag: "code",
              getAttrs: function(r) {
                var n = r.getAttribute("data-raw-html");
                return ge({}, n && { rawHTML: n });
              }
            }
          ],
          toDOM: function(r) {
            var n = r.attrs;
            return [n.rawHTML || "code", or(n)];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return function() {
        return function(r, n) {
          return so(r.schema.marks.code)(r, n);
        };
      };
    }, e.prototype.keymaps = function() {
      var r = this.commands()();
      return {
        "Shift-Mod-c": r,
        "Shift-Mod-C": r
      };
    }, e;
  }(jt)
), Xze = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "customBlock";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "text*",
          group: "block",
          attrs: {
            info: { default: null }
          },
          atom: !0,
          code: !0,
          defining: !0,
          parseDOM: [
            {
              tag: "div[data-custom-info]",
              getAttrs: function(r) {
                var n = r.getAttribute("data-custom-info");
                return { info: n };
              }
            }
          ],
          toDOM: function(r) {
            var n = r.attrs;
            return ["div", { "data-custom-info": n.info || null }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return function(r) {
        return function(n, a) {
          return r != null && r.info ? gc(n.schema.nodes.customBlock, r)(n, a) : !1;
        };
      };
    }, e;
  }($t)
), e$e = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "frontMatter";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "text*",
          group: "block",
          code: !0,
          defining: !0,
          parseDOM: [
            {
              preserveWhitespace: "full",
              tag: "div[data-front-matter]"
            }
          ],
          toDOM: function() {
            return ["div", { "data-front-matter": "true" }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return function() {
        return function(r, n, a) {
          var i = r.selection.$from;
          return a.endOfTextblock("down") && i.node().type.name === "frontMatter" ? mc(r, n) : !1;
        };
      };
    }, e.prototype.keymaps = function() {
      return {
        Enter: this.commands()()
      };
    }, e;
  }($t)
), t$e = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "htmlComment";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "text*",
          group: "block",
          code: !0,
          defining: !0,
          parseDOM: [{ preserveWhitespace: "full", tag: "div[data-html-comment]" }],
          toDOM: function() {
            return ["div", { "data-html-comment": "true" }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return function() {
        return function(r, n, a) {
          var i = r.selection.$from;
          return a.endOfTextblock("down") && i.node().type.name === "htmlComment" ? mc(r, n) : !1;
        };
      };
    }, e.prototype.keymaps = function() {
      return {
        Enter: this.commands()()
      };
    }, e;
  }($t)
);
function r$e(t) {
  return new Lh([
    new hze(),
    new mze(),
    new yze(),
    new bze(),
    new kze(),
    new wze(),
    new Cze(),
    new Tze(),
    new Sze(),
    new Hze(),
    new Uze(),
    new zze(),
    new $ze(),
    new Vze(),
    new Wze(),
    new jze(),
    new Gze(),
    new Kze(),
    new Jze(),
    new Yze(),
    new Zze(t),
    new Qze(),
    new Xze(),
    new e$e(),
    new Ah(),
    new t$e()
  ]);
}
var n$e = Ke("contents"), a$e = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e(r, n) {
      var a = t.call(this, r) || this, i = n.toDOMAdaptor, o = n.htmlSchemaMap, u = o === void 0 ? {} : o, m = n.linkAttributes, y = m === void 0 ? {} : m, C = n.useCommandShortcut, T = C === void 0 ? !0 : C, x = n.wwPlugins, M = x === void 0 ? [] : x, P = n.wwNodeViews, q = P === void 0 ? {} : P;
      return a.editorType = "wysiwyg", a.el.classList.add("ww-mode"), a.toDOMAdaptor = i, a.linkAttributes = y, a.extraPlugins = M, a.pluginNodeViews = q, a.specs = a.createSpecs(), a.schema = a.createSchema(u), a.context = a.createContext(), a.keymaps = a.createKeymaps(T), a.view = a.createView(), a.commands = a.createCommands(), a.specs.setContext(ge(ge({}, a.context), { view: a.view })), a.initEvent(), a;
    }
    return e.prototype.createSpecs = function() {
      return r$e(this.linkAttributes);
    }, e.prototype.createContext = function() {
      return {
        schema: this.schema,
        eventEmitter: this.eventEmitter
      };
    }, e.prototype.createSchema = function(r) {
      return new Qe.Schema({
        nodes: ge(ge({}, this.specs.nodes), r.nodes),
        marks: ge(ge({}, this.specs.marks), r.marks)
      });
    }, e.prototype.createPlugins = function() {
      return Wr([
        bUe(),
        TUe(this.eventEmitter),
        SUe(),
        DUe(this.eventEmitter)
      ], this.createPluginProps()).concat(this.defaultPlugins);
    }, e.prototype.createPluginNodeViews = function() {
      var r = this, n = r.eventEmitter, a = r.pluginNodeViews, i = {};
      return a && Object.keys(a).forEach(function(o) {
        i[o] = function(u, m, y) {
          return a[o](u, m, y, n);
        };
      }), i;
    }, e.prototype.createView = function() {
      var r = this, n = this, a = n.toDOMAdaptor, i = n.eventEmitter;
      return new ia.EditorView(this.el, {
        state: this.createState(),
        attributes: {
          class: n$e
        },
        nodeViews: ge({
          customBlock: function(o, u, m) {
            return new NUe(o, u, m, a);
          },
          image: function(o, u, m) {
            return new RUe(o, u, m, i);
          },
          codeBlock: function(o, u, m) {
            return new BUe(o, u, m, i);
          },
          widget: xh
        }, this.createPluginNodeViews()),
        dispatchTransaction: function(o) {
          var u = r.view.state.applyTransaction(o).state;
          r.view.updateState(u), r.emitChangeEvent(o.scrollIntoView()), r.eventEmitter.emit("setFocusedNode", u.selection.$from.node(1));
        },
        transformPastedHTML: QUe,
        transformPasted: function(o) {
          return nze(o, r.schema, Ls(r.view.state.selection.$from));
        },
        handlePaste: function(o, u, m) {
          return vze(o, m);
        },
        handleKeyDown: function(o, u) {
          return r.eventEmitter.emit("keydown", r.editorType, u), !1;
        },
        handleDOMEvents: {
          paste: function(o, u) {
            var m = u.clipboardData || window.clipboardData, y = m == null ? void 0 : m.items;
            if (y) {
              var C = Nn(y).some(function(x) {
                return x.kind === "string" && x.type === "text/rtf";
              });
              if (!C) {
                var T = Eh(y);
                T && (u.preventDefault(), Rc(r.eventEmitter, T, u.type));
              }
            }
            return !1;
          },
          keyup: function(o, u) {
            return r.eventEmitter.emit("keyup", r.editorType, u), !1;
          },
          scroll: function() {
            return r.eventEmitter.emit("scroll", "editor"), !0;
          }
        }
      });
    }, e.prototype.createCommands = function() {
      return this.specs.commands(this.view, Wc());
    }, e.prototype.getHTML = function() {
      return Nc(this.view.dom.innerHTML);
    }, e.prototype.getModel = function() {
      return this.view.state.doc;
    }, e.prototype.getSelection = function() {
      var r = this.view.state.selection, n = r.from, a = r.to;
      return [n, a];
    }, e.prototype.getSchema = function() {
      return this.view.state.schema;
    }, e.prototype.replaceSelection = function(r, n, a) {
      var i = this.view.state, o = i.schema, u = i.tr, m = r.split(`
`), y = m.map(function(x) {
        return bs(o, Ja(x, o));
      }), C = new Qe.Slice(Qe.Fragment.from(y), 1, 1), T = ea(n) && ea(a) ? u.replaceRange(n, a, C) : u.replaceSelection(C);
      this.view.dispatch(T), this.focus();
    }, e.prototype.deleteSelection = function(r, n) {
      var a = this.view.state.tr, i = ea(r) && ea(n) ? a.deleteRange(r, n) : a.deleteSelection();
      this.view.dispatch(i.scrollIntoView());
    }, e.prototype.getSelectedText = function(r, n) {
      var a = this.view.state, i = a.doc, o = a.selection, u = o.from, m = o.to;
      return ea(r) && ea(n) && (u = r, m = n), i.textBetween(u, m, `
`);
    }, e.prototype.setModel = function(r, n) {
      n === void 0 && (n = !1);
      var a = this.view.state, i = a.tr, o = a.doc;
      this.view.dispatch(i.replaceWith(0, o.content.size, r)), n && this.moveCursorToEnd(!0);
    }, e.prototype.setSelection = function(r, n) {
      n === void 0 && (n = r);
      var a = this.view.state.tr, i = Wt(a, r, n);
      this.view.dispatch(a.setSelection(i).scrollIntoView());
    }, e.prototype.addWidget = function(r, n, a) {
      var i = this.view, o = i.dispatch, u = i.state;
      o(u.tr.setMeta("widget", { pos: a ?? u.selection.to, node: r, style: n }));
    }, e.prototype.replaceWithWidget = function(r, n, a) {
      var i = this.view.state, o = i.tr, u = i.schema, m = Ja(a, u);
      this.view.dispatch(o.replaceWith(r, n, m));
    }, e.prototype.getRangeInfoOfNode = function(r) {
      var n = this.view.state, a = n.doc, i = n.selection, o = r ? a.resolve(r) : i.$from, u = o.marks(), m = o.node(), y = o.start(), C = o.end(), T = m.type.name;
      if (u.length || T === "paragraph") {
        var x = u[u.length - 1], M = function(P) {
          return P.length ? Ar(P, x) : !0;
        };
        T = x ? x.type.name : "text", m.forEach(function(P, q) {
          var _ = P.isText, K = P.nodeSize, X = P.marks, ie = o.pos - y;
          _ && q <= ie && q + K >= ie && M(X) && (y = y + q, C = y + K);
        });
      }
      return { range: [y, C], type: T };
    }, e;
  }(Mh)
), i$e = kn, o$e = hs;
function s$e(t) {
  return !i$e(t) && !o$e(t);
}
var l$e = s$e, u$e = l$e;
function c$e(t) {
  return u$e(t) && t !== !1;
}
var f$e = c$e, v$e = f$e;
function d$e(t) {
  return !v$e(t);
}
var p$e = d$e, Vd = [
  "afterPreviewRender",
  "updatePreview",
  "changeMode",
  "needChangeMode",
  "command",
  "changePreviewStyle",
  "changePreviewTabPreview",
  "changePreviewTabWrite",
  "scroll",
  "contextmenu",
  "show",
  "hide",
  "changeLanguage",
  "changeToolbarState",
  "toggleScrollSync",
  "mixinTableOffsetMapPrototype",
  "setFocusedNode",
  "removePopupWidget",
  "query",
  // provide event for user
  "openPopup",
  "closePopup",
  "addImageBlobHook",
  "beforePreviewRender",
  "beforeConvertWysiwygToMarkdown",
  "load",
  "loadUI",
  "change",
  "caretChange",
  "destroy",
  "focus",
  "blur",
  "keydown",
  "keyup"
], $m = (
  /** @class */
  function() {
    function t() {
      var e = this;
      this.events = new Im(), this.eventTypes = Vd.reduce(function(r, n) {
        return ge(ge({}, r), { type: n });
      }, {}), this.hold = !1, Vd.forEach(function(r) {
        e.addEventType(r);
      });
    }
    return t.prototype.listen = function(e, r) {
      var n = this.getTypeInfo(e), a = this.events.get(n.type) || [];
      if (!this.hasEventType(n.type))
        throw new Error("There is no event type " + n.type);
      n.namespace && (r.namespace = n.namespace), a.push(r), this.events.set(n.type, a);
    }, t.prototype.emit = function(e) {
      for (var r = [], n = 1; n < arguments.length; n++)
        r[n - 1] = arguments[n];
      var a = this.getTypeInfo(e), i = this.events.get(a.type), o = [];
      return !this.hold && i && i.forEach(function(u) {
        var m = u.apply(void 0, r);
        kn(m) || o.push(m);
      }), o;
    }, t.prototype.emitReduce = function(e, r) {
      for (var n = [], a = 2; a < arguments.length; a++)
        n[a - 2] = arguments[a];
      var i = this.events.get(e);
      return !this.hold && i && i.forEach(function(o) {
        var u = o.apply(void 0, Wr([r], n));
        p$e(u) || (r = u);
      }), r;
    }, t.prototype.getTypeInfo = function(e) {
      var r = e.split(".");
      return {
        type: r[0],
        namespace: r[1]
      };
    }, t.prototype.hasEventType = function(e) {
      return !kn(this.eventTypes[this.getTypeInfo(e).type]);
    }, t.prototype.addEventType = function(e) {
      if (this.hasEventType(e))
        throw new Error("There is already have event type " + e);
      this.eventTypes[e] = e;
    }, t.prototype.removeEventHandler = function(e, r) {
      var n = this, a = this.getTypeInfo(e), i = a.type, o = a.namespace;
      i && r ? this.removeEventHandlerWithHandler(i, r) : i && !o ? this.events.delete(i) : !i && o ? this.events.forEach(function(u, m) {
        n.removeEventHandlerWithTypeInfo(m, o);
      }) : i && o && this.removeEventHandlerWithTypeInfo(i, o);
    }, t.prototype.removeEventHandlerWithHandler = function(e, r) {
      var n = this.events.get(e);
      if (n) {
        var a = n.indexOf(r);
        n.indexOf(r) >= 0 && n.splice(a, 1);
      }
    }, t.prototype.removeEventHandlerWithTypeInfo = function(e, r) {
      var n = [], a = this.events.get(e);
      a && (a.map(function(i) {
        return i.namespace !== r && n.push(i), null;
      }), this.events.set(e, n));
    }, t.prototype.getEvents = function() {
      return this.events;
    }, t.prototype.holdEventInvoke = function(e) {
      this.hold = !0, e(), this.hold = !1;
    }, t;
  }()
), h$e = (
  /** @class */
  function() {
    function t(e, r, n, a) {
      this.eventEmitter = e, this.mdCommands = r, this.wwCommands = n, this.getEditorType = a, this.initEvent();
    }
    return t.prototype.initEvent = function() {
      var e = this;
      this.eventEmitter.listen("command", function(r, n) {
        e.exec(r, n);
      });
    }, t.prototype.addCommand = function(e, r, n) {
      e === "markdown" ? this.mdCommands[r] = n : this.wwCommands[r] = n;
    }, t.prototype.deleteCommand = function(e, r) {
      e === "markdown" ? delete this.mdCommands[r] : delete this.wwCommands[r];
    }, t.prototype.exec = function(e, r) {
      var n = this.getEditorType();
      n === "markdown" ? this.mdCommands[e](r) : this.wwCommands[e](r);
    }, t;
  }()
);
function fs(t) {
  return t[t.length - 1] === `
` ? t.slice(0, t.length - 1) : t;
}
function uc(t, e) {
  var r = t.schema, n = e.literal, a = n.match(Ei);
  if (a) {
    var i = a[1], o = a[3], u = (i || o).toLowerCase();
    return e.type === "htmlInline" && !!(r.marks[u] || r.nodes[u]);
  }
  return !1;
}
function cc(t) {
  var e = t.type;
  return Ar(["text", "strong", "emph", "strike", "image", "link", "code"], e);
}
function Wd(t) {
  return (t == null ? void 0 : t.type) === "softbreak";
}
function Gi(t) {
  var e = t.type, r = t.literal, n = e === "htmlInline" && r.match(Ei);
  if (n) {
    var a = n[1], i = n[3], o = a || i;
    if (o)
      return Ar(["ul", "ol", "li"], o.toLowerCase());
  }
  return !1;
}
function m$e(t) {
  var e = t.literal, r = /data-task/.test(e), n = /data-task-checked/.test(e);
  return { task: r, checked: n };
}
function jd(t) {
  for (var e = [], r = 1; r < arguments.length; r++)
    e[r - 1] = arguments[r];
  var n = document.createElement("div");
  n.innerHTML = ti(t);
  var a = n.firstChild;
  return e.map(function(i) {
    return a.getAttribute(i) || "";
  });
}
function g$e(t) {
  var e = {};
  return Object.keys(t).forEach(function(r) {
    var n = r.split(", ");
    n.forEach(function(a) {
      var i = a.toLowerCase();
      e[i] = t[r];
    });
  }), e;
}
var y$e = {
  "b, strong": function(t, e, r) {
    var n = t.schema.marks.strong;
    r ? t.openMark(n.create({ rawHTML: r })) : t.closeMark(n);
  },
  "i, em": function(t, e, r) {
    var n = t.schema.marks.emph;
    r ? t.openMark(n.create({ rawHTML: r })) : t.closeMark(n);
  },
  "s, del": function(t, e, r) {
    var n = t.schema.marks.strike;
    r ? t.openMark(n.create({ rawHTML: r })) : t.closeMark(n);
  },
  code: function(t, e, r) {
    var n = t.schema.marks.code;
    r ? t.openMark(n.create({ rawHTML: r })) : t.closeMark(n);
  },
  a: function(t, e, r) {
    var n = e.literal, a = t.schema.marks.link;
    if (r) {
      var i = jd(n, "href")[0];
      t.openMark(a.create({
        linkUrl: i,
        rawHTML: r
      }));
    } else
      t.closeMark(a);
  },
  img: function(t, e, r) {
    var n = e.literal;
    if (r) {
      var a = jd(n, "src", "alt"), i = a[0], o = a[1], u = t.schema.nodes.image;
      t.addNode(u, ge({ rawHTML: r, imageUrl: i }, o && { altText: o }));
    }
  },
  hr: function(t, e, r) {
    t.addNode(t.schema.nodes.thematicBreak, { rawHTML: r });
  },
  br: function(t, e) {
    var r = t.schema.nodes.paragraph, n = e.parent, a = e.prev, i = e.next;
    (n == null ? void 0 : n.type) === "paragraph" ? (Wd(a) && t.openNode(r), Wd(i) ? t.closeNode() : i && (t.closeNode(), t.openNode(r))) : (n == null ? void 0 : n.type) === "tableCell" && (a && (cc(a) || uc(t, a)) && t.closeNode(), i && (cc(i) || uc(t, i)) && t.openNode(r));
  },
  pre: function(t, e, r) {
    var n, a, i = document.createElement("div");
    i.innerHTML = e.literal;
    var o = (a = (n = i.firstChild) === null || n === void 0 ? void 0 : n.firstChild) === null || a === void 0 ? void 0 : a.textContent;
    t.openNode(t.schema.nodes.codeBlock, { rawHTML: r }), t.addText(fs(o)), t.closeNode();
  },
  "ul, ol": function(t, e, r) {
    if (e.parent.type === "tableCell") {
      var n = t.schema.nodes, a = n.bulletList, i = n.orderedList, o = n.paragraph, u = r === "ul" ? a : i;
      r ? (e.prev && !Gi(e.prev) && t.closeNode(), t.openNode(u, { rawHTML: r })) : (t.closeNode(), e.next && !Gi(e.next) && t.openNode(o));
    }
  },
  li: function(t, e, r) {
    var n;
    if (((n = e.parent) === null || n === void 0 ? void 0 : n.type) === "tableCell") {
      var a = t.schema.nodes, i = a.listItem, o = a.paragraph;
      if (r) {
        var u = m$e(e);
        e.prev && !Gi(e.prev) && t.closeNode(), t.openNode(i, ge({ rawHTML: r }, u)), e.next && !Gi(e.next) && t.openNode(o);
      } else
        e.prev && !Gi(e.prev) && t.closeNode(), t.closeNode();
    }
  }
}, b$e = g$e(y$e);
function Gd(t) {
  return t.type === "htmlInline" && Vu.test(t.literal);
}
function Vm(t) {
  Nn(t.childNodes).forEach(function(e) {
    if (_s(e)) {
      var r = e.nodeName.toLowerCase();
      e.setAttribute("data-raw-html", r), e.childNodes && Vm(e);
    }
  });
}
var Kd = {
  text: function(t, e) {
    t.addText(e.literal || "");
  },
  paragraph: function(t, e, r, n) {
    var a, i = r.entering;
    if (i) {
      var o = t.schema.nodes.paragraph;
      ((a = e.prev) === null || a === void 0 ? void 0 : a.type) === "paragraph" && (t.openNode(o, n), t.closeNode()), t.openNode(o, n);
    } else
      t.closeNode();
  },
  heading: function(t, e, r, n) {
    var a = r.entering;
    if (a) {
      var i = e, o = i.level, u = i.headingType;
      t.openNode(t.schema.nodes.heading, ge({ level: o, headingType: u }, n));
    } else
      t.closeNode();
  },
  codeBlock: function(t, e, r) {
    var n = t.schema.nodes.codeBlock, a = e, i = a.info, o = a.literal;
    t.openNode(n, ge({ language: i }, r)), t.addText(fs(o || "")), t.closeNode();
  },
  list: function(t, e, r, n) {
    var a = r.entering;
    if (a) {
      var i = t.schema.nodes, o = i.bulletList, u = i.orderedList, m = e.listData, y = m.type, C = m.start;
      y === "bullet" ? t.openNode(o, n) : t.openNode(u, ge({ order: C }, n));
    } else
      t.closeNode();
  },
  item: function(t, e, r, n) {
    var a = r.entering, i = t.schema.nodes.listItem, o = e.listData, u = o.task, m = o.checked;
    if (a) {
      var y = ge(ge(ge({}, u && { task: u }), m && { checked: m }), n);
      t.openNode(i, y);
    } else
      t.closeNode();
  },
  blockQuote: function(t, e, r, n) {
    var a = r.entering;
    a ? t.openNode(t.schema.nodes.blockQuote, n) : t.closeNode();
  },
  image: function(t, e, r, n) {
    var a = r.entering, i = r.skipChildren, o = t.schema.nodes.image, u = e, m = u.destination, y = u.firstChild;
    a && i && i(), t.addNode(o, ge(ge({ imageUrl: m }, y && { altText: y.literal }), n));
  },
  thematicBreak: function(t, e, r, n) {
    t.addNode(t.schema.nodes.thematicBreak, n);
  },
  strong: function(t, e, r, n) {
    var a = r.entering, i = t.schema.marks.strong;
    a ? t.openMark(i.create(n)) : t.closeMark(i);
  },
  emph: function(t, e, r, n) {
    var a = r.entering, i = t.schema.marks.emph;
    a ? t.openMark(i.create(n)) : t.closeMark(i);
  },
  link: function(t, e, r, n) {
    var a = r.entering, i = t.schema.marks.link, o = e, u = o.destination, m = o.title;
    if (a) {
      var y = ge({ linkUrl: u, title: m }, n);
      t.openMark(i.create(y));
    } else
      t.closeMark(i);
  },
  softbreak: function(t, e) {
    if (e.parent.type === "paragraph") {
      var r = e.prev, n = e.next;
      r && !Gd(r) && t.closeNode(), n && !Gd(n) && t.openNode(t.schema.nodes.paragraph);
    }
  },
  // GFM specifications node
  table: function(t, e, r, n) {
    var a = r.entering;
    a ? t.openNode(t.schema.nodes.table, n) : t.closeNode();
  },
  tableHead: function(t, e, r, n) {
    var a = r.entering;
    a ? t.openNode(t.schema.nodes.tableHead, n) : t.closeNode();
  },
  tableBody: function(t, e, r, n) {
    var a = r.entering;
    a ? t.openNode(t.schema.nodes.tableBody, n) : t.closeNode();
  },
  tableRow: function(t, e, r, n) {
    var a = r.entering;
    a ? t.openNode(t.schema.nodes.tableRow, n) : t.closeNode();
  },
  tableCell: function(t, e, r) {
    var n = r.entering;
    if (!e.ignored) {
      var a = function(P) {
        return P && (cc(P) || uc(t, P));
      };
      if (n) {
        var i = t.schema.nodes, o = i.tableHeadCell, u = i.tableBodyCell, m = i.paragraph, y = e.parent.parent, C = y.type === "tableHead" ? o : u, T = y.parent, x = (T.columns[e.startIdx] || {}).align, M = ge({}, e.attrs);
        x && (M.align = x), t.openNode(C, M), a(e.firstChild) && t.openNode(m);
      } else
        a(e.lastChild) && t.closeNode(), t.closeNode();
    }
  },
  strike: function(t, e, r, n) {
    var a = r.entering, i = t.schema.marks.strike;
    a ? t.openMark(i.create(n)) : t.closeMark(i);
  },
  code: function(t, e, r, n) {
    var a = t.schema.marks.code;
    t.openMark(a.create(n)), t.addText(fs(e.literal || "")), t.closeMark(a);
  },
  customBlock: function(t, e) {
    var r = t.schema.nodes, n = r.customBlock, a = r.paragraph, i = e, o = i.info, u = i.literal;
    t.openNode(n, { info: o }), t.addText(fs(u || "")), t.closeNode(), e.next || (t.openNode(a), t.closeNode());
  },
  frontMatter: function(t, e) {
    t.openNode(t.schema.nodes.frontMatter), t.addText(e.literal), t.closeNode();
  },
  htmlInline: function(t, e) {
    var r = e.literal, n = r.match(Ei), a = n[1], i = n[3], o = (a || i).toLowerCase(), u = t.schema.marks[o], m = ti(r);
    if (u != null && u.spec.attrs.htmlInline)
      if (a) {
        var y = ic(m);
        t.openMark(u.create({ htmlAttrs: y }));
      } else
        t.closeMark(u);
    else {
      var C = b$e[o];
      C && C(t, e, a);
    }
  },
  htmlBlock: function(t, e) {
    var r = e.literal, n = document.createElement("div"), a = r7.test(r);
    if (a)
      t.openNode(t.schema.nodes.htmlComment), t.addText(e.literal), t.closeNode();
    else {
      var i = r.match(Ei), o = i[1], u = i[3], m = (o || u).toLowerCase(), y = t.schema.nodes[m], C = ti(r);
      if (y != null && y.spec.attrs.htmlBlock) {
        var T = ic(C), x = Cm(e, m);
        t.addNode(y, { htmlAttrs: T, childrenHTML: x });
      } else
        n.innerHTML = C, Vm(n), t.convertByDOMParser(n);
    }
  },
  customInline: function(t, e, r) {
    var n = r.entering, a = r.skipChildren, i = e, o = i.info, u = i.firstChild, m = t.schema;
    if (o.indexOf("widget") !== -1 && n) {
      var y = dh(e);
      a(), t.addNode(m.nodes.widget, { info: o }, [
        m.text(fh(o, y))
      ]);
    } else {
      var C = "$$";
      n && (C += u ? o + " " : o), t.addText(C);
    }
  }
};
function k$e(t) {
  var e = Object.keys(t), r = ge({}, Kd), n = new $c({
    gfm: !0,
    nodeId: !0,
    convertors: t
  }), a = n.getConvertors();
  return e.forEach(function(i) {
    var o = Kd[i];
    o && !Ar(["htmlBlock", "htmlInline"], i) && (r[i] = function(u, m, y) {
      y.origin = function() {
        return a[i](m, y, a);
      };
      var C = t[i](m, y), T;
      if (C) {
        var x = Array.isArray(C) ? C[0] : C, M = x.attributes, P = x.classNames;
        T = { htmlAttrs: M, classNames: P };
      }
      o(u, m, y, T);
    });
  }), r;
}
function w$e(t, e) {
  return t.isText && e.isText && Qe.Mark.sameSet(t.marks, e.marks) ? t.withText(t.text + e.text) : !1;
}
var C$e = (
  /** @class */
  function() {
    function t(e, r) {
      this.schema = e, this.convertors = r, this.stack = [{ type: this.schema.topNodeType, attrs: null, content: [] }], this.marks = Qe.Mark.none;
    }
    return t.prototype.top = function() {
      return Dr(this.stack);
    }, t.prototype.push = function(e) {
      this.stack.length && this.top().content.push(e);
    }, t.prototype.addText = function(e) {
      if (e) {
        var r = this.top().content, n = Dr(r), a = this.schema.text(e, this.marks), i = n && w$e(n, a);
        i ? r[r.length - 1] = i : r.push(a);
      }
    }, t.prototype.openMark = function(e) {
      this.marks = e.addToSet(this.marks);
    }, t.prototype.closeMark = function(e) {
      this.marks = e.removeFromSet(this.marks);
    }, t.prototype.addNode = function(e, r, n) {
      var a = e.createAndFill(r, n, this.marks);
      return a ? (this.push(a), a) : null;
    }, t.prototype.openNode = function(e, r) {
      this.stack.push({ type: e, attrs: r, content: [] });
    }, t.prototype.closeNode = function() {
      this.marks.length && (this.marks = Qe.Mark.none);
      var e = this.stack.pop(), r = e.type, n = e.attrs, a = e.content;
      return this.addNode(r, n, a);
    }, t.prototype.convertByDOMParser = function(e) {
      var r = this, n = Qe.DOMParser.fromSchema(this.schema).parse(e);
      n.content.forEach(function(a) {
        return r.push(a);
      });
    }, t.prototype.closeUnmatchedHTMLInline = function(e, r) {
      var n;
      if (!r && e.type !== "htmlInline")
        for (var a = this.stack.length - 1, i = a; i >= 0; i -= 1) {
          var o = this.stack[i];
          if (!((n = o.attrs) === null || n === void 0) && n.rawHTML)
            o.content.length ? this.closeNode() : this.stack.pop();
          else
            break;
        }
    }, t.prototype.convert = function(e, r) {
      for (var n = e.walker(), a = n.next(), i = function() {
        var u = a.node, m = a.entering, y = o.convertors[u.type], C = !1;
        if (y) {
          var T = {
            entering: m,
            leaf: !BY(u),
            getChildrenText: qY,
            options: { gfm: !0, nodeId: !1, tagFilter: !1, softbreak: `
` },
            skipChildren: function() {
              C = !0;
            }
          };
          if (o.closeUnmatchedHTMLInline(u, m), y(o, u, T), (r == null ? void 0 : r.node) === u) {
            var x = o.stack.reduce(function(M, P) {
              return M + P.content.reduce(function(q, _) {
                return q + _.nodeSize;
              }, 0);
            }, 0) + 1;
            r.setMappedPos(x);
          }
        }
        C && (n.resumeAt(u, !1), n.next()), a = n.next();
      }, o = this; a; )
        i();
    }, t.prototype.convertNode = function(e, r) {
      return this.convert(e, r), this.stack.length ? this.closeNode() : null;
    }, t;
  }()
);
function T$e(t, e, r) {
  var n = r[0], a = r[1];
  t.write(n), t.convertInline(e), t.write(a);
}
function S$e(t, e, r) {
  var n = e.node, a = e.parent, i = r[0], o = r[1];
  t.stopNewline = !0, t.write(i), t.convertNode(n), t.write(o), (a == null ? void 0 : a.type.name) === "doc" && (t.closeBlock(n), t.stopNewline = !1);
}
function E$e(t, e) {
  var r = t.length, n = "", a = "";
  return e === "left" ? (n = ":", r -= 1) : e === "right" ? (a = ":", r -= 1) : e === "center" && (n = ":", a = ":", r -= 2), "" + n + ms("-", Math.max(r, 3)) + a;
}
var fc = {
  text: function(t, e) {
    var r, n = e.node, a = (r = n.text) !== null && r !== void 0 ? r : "";
    (n.marks || []).some(function(i) {
      return i.type.name === "link";
    }) ? t.text(gs(a), !1) : t.text(a);
  },
  paragraph: function(t, e) {
    var r = e.node, n = e.parent, a = e.index, i = a === void 0 ? 0 : a;
    if (t.stopNewline)
      t.convertInline(r);
    else {
      var o = i === 0, u = !o && n.child(i - 1), m = u && u.childCount === 0, y = i < n.childCount - 1 && n.child(i + 1), C = y && y.type.name === "paragraph", T = r.childCount === 0;
      if (T && m)
        t.write(`<br>
`);
      else if (T && !m && !o) {
        if ((n == null ? void 0 : n.type.name) === "listItem") {
          var x = t.getDelim();
          t.setDelim(""), t.write("<br>"), t.setDelim(x);
        }
        t.write(`
`);
      } else
        t.convertInline(r), C ? t.write(`
`) : t.closeBlock(r);
    }
  },
  heading: function(t, e, r) {
    var n = e.node, a = r.delim, i = n.attrs.headingType;
    i === "atx" ? (t.write(a + " "), t.convertInline(n), t.closeBlock(n)) : (t.convertInline(n), t.ensureNewLine(), t.write(a), t.closeBlock(n));
  },
  codeBlock: function(t, e, r) {
    var n = e.node, a = r.delim, i = r.text, o = a, u = o[0], m = o[1];
    t.write(u), t.ensureNewLine(), t.text(i, !1), t.ensureNewLine(), t.write(m), t.closeBlock(n);
  },
  blockQuote: function(t, e, r) {
    var n = e.node, a = e.parent, i = r.delim;
    (a == null ? void 0 : a.type.name) === n.type.name && t.flushClose(1), t.wrapBlock(i, null, n, function() {
      return t.convertNode(n);
    });
  },
  bulletList: function(t, e, r) {
    var n = e.node, a = r.delim;
    t.convertList(n, ms(" ", 4), function() {
      return a + " ";
    });
  },
  orderedList: function(t, e) {
    var r = e.node, n = r.attrs.order || 1;
    t.convertList(r, ms(" ", 4), function(a) {
      var i = String(n + a);
      return i + ". ";
    });
  },
  listItem: function(t, e) {
    var r = e.node, n = r.attrs, a = n.task, i = n.checked;
    a && t.write("[" + (i ? "x" : " ") + "] "), t.convertNode(r);
  },
  image: function(t, e, r) {
    var n = r.attrs;
    t.write("![" + (n == null ? void 0 : n.altText) + "](" + (n == null ? void 0 : n.imageUrl) + ")");
  },
  thematicBreak: function(t, e, r) {
    var n = e.node, a = r.delim;
    t.write(a), t.closeBlock(n);
  },
  table: function(t, e) {
    var r = e.node;
    t.convertNode(r), t.closeBlock(r);
  },
  tableHead: function(t, e, r) {
    var n = e.node, a = r.delim, i = n.firstChild;
    t.convertNode(n);
    var o = a ?? "";
    !a && i && i.forEach(function(u) {
      var m = u.textContent, y = u.attrs, C = E$e(m, y.align);
      o += "| " + C + " ";
    }), t.write(o + "|"), t.ensureNewLine();
  },
  tableBody: function(t, e) {
    var r = e.node;
    t.convertNode(r);
  },
  tableRow: function(t, e) {
    var r = e.node;
    t.convertNode(r), t.write("|"), t.ensureNewLine();
  },
  tableHeadCell: function(t, e, r) {
    var n = e.node, a = r.delim, i = a === void 0 ? "| " : a;
    t.write(i), t.convertTableCell(n), t.write(" ");
  },
  tableBodyCell: function(t, e, r) {
    var n = e.node, a = r.delim, i = a === void 0 ? "| " : a;
    t.write(i), t.convertTableCell(n), t.write(" ");
  },
  customBlock: function(t, e, r) {
    var n = e.node, a = r.delim, i = r.text, o = a, u = o[0], m = o[1];
    t.write(u), t.ensureNewLine(), t.text(i, !1), t.ensureNewLine(), t.write(m), t.closeBlock(n);
  },
  frontMatter: function(t, e, r) {
    var n = e.node, a = r.text;
    t.text(a, !1), t.closeBlock(n);
  },
  widget: function(t, e, r) {
    var n = r.text;
    t.write(n);
  },
  html: function(t, e, r) {
    var n = e.node, a = r.text;
    t.write(a), n.attrs.htmlBlock && t.closeBlock(n);
  },
  htmlComment: function(t, e, r) {
    var n = e.node, a = r.text;
    t.write(a), t.closeBlock(n);
  }
};
function x$e(t, e) {
  var r = e.state, n = e.nodeInfo, a = e.params, i = a.rawHTML;
  i ? Ya(t, ["heading", "codeBlock"]) > -1 ? T$e(r, n.node, i) : Ya(t, ["image", "thematicBreak"]) > -1 ? r.write(i) : S$e(r, n, i) : fc[t](r, n, a);
}
function Jd(t, e) {
  var r = t.text, n = /`+/g, a = 0;
  if (t.isText && r)
    for (var i = n.exec(r); i; )
      a = Math.max(a, i[0].length), i = n.exec(r);
  for (var o = a > 0 && e > 0 ? " `" : "`", u = 0; u < a; u += 1)
    o += "`";
  return a > 0 && e < 0 && (o += " "), o;
}
function hn(t) {
  return t ? ["<" + t + ">", "</" + t + ">"] : null;
}
function Ki(t) {
  return t ? "<" + t + ">" : null;
}
function Ji(t) {
  return t ? "</" + t + ">" : null;
}
var Yi = {
  heading: function(t) {
    var e = t.node, r = e.attrs, n = r.level, a = ms("#", n);
    return r.headingType === "setext" && (a = n === 1 ? "===" : "---"), {
      delim: a,
      rawHTML: hn(r.rawHTML)
    };
  },
  codeBlock: function(t) {
    var e = t.node, r = e, n = r.attrs, a = r.textContent;
    return {
      delim: ["```" + (n.language || ""), "```"],
      rawHTML: hn(n.rawHTML),
      text: a
    };
  },
  blockQuote: function(t) {
    var e = t.node;
    return {
      delim: "> ",
      rawHTML: hn(e.attrs.rawHTML)
    };
  },
  bulletList: function(t, e) {
    var r = t.node, n = e.inTable, a = r.attrs.rawHTML;
    return n && (a = a || "ul"), {
      delim: "*",
      rawHTML: hn(a)
    };
  },
  orderedList: function(t, e) {
    var r = t.node, n = e.inTable, a = r.attrs.rawHTML;
    return n && (a = a || "ol"), {
      rawHTML: hn(a)
    };
  },
  listItem: function(t, e) {
    var r = t.node, n = e.inTable, a = r.attrs, i = a.task, o = a.checked, u = r.attrs.rawHTML;
    n && (u = u || "li");
    var m = i ? ' class="task-list-item' + (o ? " checked" : "") + '"' : "", y = i ? " data-task" + (o ? " data-task-checked" : "") : "";
    return {
      rawHTML: u ? ["<" + u + m + y + ">", "</" + u + ">"] : null
    };
  },
  table: function(t) {
    var e = t.node;
    return {
      rawHTML: hn(e.attrs.rawHTML)
    };
  },
  tableHead: function(t) {
    var e = t.node;
    return {
      rawHTML: hn(e.attrs.rawHTML)
    };
  },
  tableBody: function(t) {
    var e = t.node;
    return {
      rawHTML: hn(e.attrs.rawHTML)
    };
  },
  tableRow: function(t) {
    var e = t.node;
    return {
      rawHTML: hn(e.attrs.rawHTML)
    };
  },
  tableHeadCell: function(t) {
    var e = t.node;
    return {
      rawHTML: hn(e.attrs.rawHTML)
    };
  },
  tableBodyCell: function(t) {
    var e = t.node;
    return {
      rawHTML: hn(e.attrs.rawHTML)
    };
  },
  image: function(t) {
    var e = t.node, r = e.attrs, n = r.rawHTML, a = r.altText, i = r.imageUrl.replace(/&amp;/g, "&"), o = a ? ' alt="' + bi(a) + '"' : "";
    return {
      rawHTML: n ? "<" + n + ' src="' + bi(i) + '"' + o + ">" : null,
      attrs: {
        altText: gs(a || ""),
        imageUrl: i
      }
    };
  },
  thematicBreak: function(t) {
    var e = t.node;
    return {
      delim: "***",
      rawHTML: Ki(e.attrs.rawHTML)
    };
  },
  customBlock: function(t) {
    var e = t.node, r = e, n = r.attrs, a = r.textContent;
    return {
      delim: ["$$" + n.info, "$$"],
      text: a
    };
  },
  frontMatter: function(t) {
    var e = t.node;
    return {
      text: e.textContent
    };
  },
  widget: function(t) {
    var e = t.node;
    return {
      text: e.textContent
    };
  },
  strong: function(t, e) {
    var r = t.node, n = e.entering, a = r.attrs.rawHTML;
    return {
      delim: "**",
      rawHTML: n ? Ki(a) : Ji(a)
    };
  },
  emph: function(t, e) {
    var r = t.node, n = e.entering, a = r.attrs.rawHTML;
    return {
      delim: "*",
      rawHTML: n ? Ki(a) : Ji(a)
    };
  },
  strike: function(t, e) {
    var r = t.node, n = e.entering, a = r.attrs.rawHTML;
    return {
      delim: "~~",
      rawHTML: n ? Ki(a) : Ji(a)
    };
  },
  link: function(t, e) {
    var r = t.node, n = e.entering, a = r.attrs, i = a.title, o = a.rawHTML, u = a.linkUrl.replace(/&amp;/g, "&"), m = i ? ' title="' + bi(i) + '"' : "";
    return n ? {
      delim: "[",
      rawHTML: o ? "<" + o + ' href="' + bi(u) + '"' + m + ">" : null
    } : {
      delim: "](" + u + (i ? " " + EY(gs(i)) : "") + ")",
      rawHTML: Ji(o)
    };
  },
  code: function(t, e) {
    var r = t.node, n = t.parent, a = t.index, i = a === void 0 ? 0 : a, o = e.entering, u = o ? Jd(n.child(i), -1) : Jd(n.child(i - 1), 1), m = o ? Ki(r.attrs.rawHTML) : Ji(r.attrs.rawHTML);
    return {
      delim: u,
      rawHTML: m
    };
  },
  htmlComment: function(t) {
    var e = t.node;
    return {
      text: e.textContent
    };
  },
  // html inline node, html block node
  html: function(t, e) {
    var r = t.node, n = e.entering, a = r.type.name, i = r.attrs.htmlAttrs, o = "<" + a, u = "</" + a + ">";
    return Object.keys(i).forEach(function(m) {
      o += " " + m + '="' + i[m].replace(/"/g, "'") + '"';
    }), o += ">", r.attrs.htmlInline ? {
      rawHTML: n ? o : u
    } : {
      text: "" + o + r.attrs.childrenHTML + u
    };
  }
}, Yd = {
  strong: {
    mixable: !0,
    removedEnclosingWhitespace: !0
  },
  emph: {
    mixable: !0,
    removedEnclosingWhitespace: !0
  },
  strike: {
    mixable: !0,
    removedEnclosingWhitespace: !0
  },
  code: {
    escape: !1
  },
  link: null,
  html: null
};
function A$e(t) {
  var e = {}, r = Object.keys(fc);
  return r.forEach(function(n) {
    e[n] = function(a, i) {
      var o = fc[n];
      if (o) {
        var u = t[n], m = u ? u(i, {
          inTable: a.inTable
        }) : {};
        x$e(n, { state: a, nodeInfo: i, params: m });
      }
    };
  }), e;
}
function M$e(t) {
  var e = {}, r = Object.keys(Yd);
  return r.forEach(function(n) {
    e[n] = function(a, i) {
      var o = Yd[n], u = t[n], m = u && a && !kn(i), y = m ? u(a, { entering: i }) : {};
      return ge(ge({}, y), o);
    };
  }), e;
}
function L$e(t) {
  var e = Object.keys(t);
  e.forEach(function(a) {
    var i = Yi[a], o = t[a];
    i ? Yi[a] = function(u, m) {
      return m.origin = function() {
        return i(u, m);
      }, o(u, m);
    } : Yi[a] = o, delete t[a];
  });
  var r = A$e(Yi), n = M$e(Yi);
  return {
    nodeTypeConvertors: r,
    markTypeConvertors: n
  };
}
var O$e = (
  /** @class */
  function() {
    function t(e) {
      var r = e.nodeTypeConvertors, n = e.markTypeConvertors;
      this.nodeTypeConvertors = r, this.markTypeConvertors = n, this.delim = "", this.result = "", this.closed = !1, this.tightList = !1, this.stopNewline = !1, this.inTable = !1;
    }
    return t.prototype.getMarkConvertor = function(e) {
      var r = e.attrs.htmlInline ? "html" : e.type.name;
      return this.markTypeConvertors[r];
    }, t.prototype.isInBlank = function() {
      return /(^|\n)$/.test(this.result);
    }, t.prototype.markText = function(e, r, n, a) {
      var i = this.getMarkConvertor(e);
      if (i) {
        var o = i({ node: e, parent: n, index: a }, r), u = o.delim, m = o.rawHTML;
        return m || u;
      }
      return "";
    }, t.prototype.setDelim = function(e) {
      this.delim = e;
    }, t.prototype.getDelim = function() {
      return this.delim;
    }, t.prototype.flushClose = function(e) {
      if (!this.stopNewline && this.closed) {
        if (this.isInBlank() || (this.result += `
`), e || (e = 2), e > 1) {
          var r = this.delim, n = /\s+$/.exec(r);
          n && (r = r.slice(0, r.length - n[0].length));
          for (var a = 1; a < e; a += 1)
            this.result += r + `
`;
        }
        this.closed = !1;
      }
    }, t.prototype.wrapBlock = function(e, r, n, a) {
      var i = this.getDelim();
      this.write(r || e), this.setDelim(this.getDelim() + e), a(), this.setDelim(i), this.closeBlock(n);
    }, t.prototype.ensureNewLine = function() {
      this.isInBlank() || (this.result += `
`);
    }, t.prototype.write = function(e) {
      e === void 0 && (e = ""), this.flushClose(), this.delim && this.isInBlank() && (this.result += this.delim), e && (this.result += e);
    }, t.prototype.closeBlock = function(e) {
      this.closed = e;
    }, t.prototype.text = function(e, r) {
      r === void 0 && (r = !0);
      for (var n = e.split(`
`), a = 0; a < n.length; a += 1)
        this.write(), this.result += r ? SY(n[a]) : n[a], a !== n.length - 1 && (this.result += `
`);
    }, t.prototype.convertBlock = function(e, r, n) {
      var a = e.type.name, i = this.nodeTypeConvertors[a], o = { node: e, parent: r, index: n };
      e.attrs.htmlBlock ? this.nodeTypeConvertors.html(this, o) : i && i(this, o);
    }, t.prototype.convertInline = function(e) {
      var r = this, n = [], a = "", i = function(o, u, m) {
        var y = o ? o.marks : [], C = a;
        a = "";
        var T = o && o.isText && y.some(function(Me) {
          var ze = r.getMarkConvertor(Me), vt = ze && ze();
          return vt && vt.removedEnclosingWhitespace;
        });
        if (T && o && o.text) {
          var x = /^(\s*)(.*?)(\s*)$/m.exec(o.text), M = x[1], P = x[2], q = x[3];
          C += M, a = q, (M || q) && (o = P ? o.withText(P) : null, o || (y = n));
        }
        for (var _ = y.length && Dr(y), K = _ && r.getMarkConvertor(_), X = K && K(), ie = X && X.escape === !1, ee = y.length - (ie ? 1 : 0), oe = 0; oe < ee; oe += 1) {
          var P = y[oe];
          if (X && !X.mixable)
            break;
          for (var ue = 0; ue < n.length; ue += 1) {
            var pe = n[ue];
            if (X && !X.mixable)
              break;
            if (P.eq(pe)) {
              oe > ue ? y = y.slice(0, ue).concat(P).concat(y.slice(ue, oe)).concat(y.slice(oe + 1, ee)) : ue > oe && (y = y.slice(0, oe).concat(y.slice(oe + 1, ue)).concat(P).concat(y.slice(ue, ee)));
              break;
            }
          }
        }
        for (var Se = 0; Se < Math.min(n.length, ee) && y[Se].eq(n[Se]); )
          Se += 1;
        for (; Se < n.length; ) {
          var Re = n.pop();
          Re && r.text(r.markText(Re, !1, e, m), !1);
        }
        if (C && r.text(C), o) {
          for (; n.length < ee; ) {
            var P = y[n.length];
            n.push(P), r.text(r.markText(P, !0, e, m), !1);
          }
          ie && o.isText ? r.text(r.markText(_, !0, e, m) + o.text + r.markText(_, !1, e, m + 1), !1) : r.convertBlock(o, e, m);
        }
      };
      e.forEach(i), i(null, null, e.childCount);
    }, t.prototype.convertList = function(e, r, n) {
      var a = this, i;
      this.closed && this.closed.type === e.type ? this.flushClose(3) : this.tightList && this.flushClose(1);
      var o = (i = e.attrs.tight) !== null && i !== void 0 ? i : !0, u = this.tightList;
      this.tightList = o, e.forEach(function(m, y, C) {
        C && o && a.flushClose(1), a.wrapBlock(r, n(C), e, function() {
          return a.convertBlock(m, e, C);
        });
      }), this.tightList = u;
    }, t.prototype.convertTableCell = function(e) {
      var r = this;
      this.stopNewline = !0, this.inTable = !0, e.forEach(function(n, a, i) {
        if (Ar(["bulletList", "orderedList"], n.type.name))
          r.convertBlock(n, e, i), r.closed = !1;
        else if (r.convertInline(n), i < e.childCount - 1) {
          var o = e.child(i + 1);
          o.type.name === "paragraph" && r.write("<br>");
        }
      }), this.stopNewline = !1, this.inTable = !1;
    }, t.prototype.convertNode = function(e, r) {
      var n = this;
      return e.forEach(function(a, i, o) {
        if (n.convertBlock(a, e, o), (r == null ? void 0 : r.node) === a) {
          var u = n.result.split(`
`);
          r.setMappedPos([u.length, Dr(u).length + 1]);
        }
      }), this.result;
    }, t;
  }()
), D$e = (
  /** @class */
  function() {
    function t(e, r, n, a) {
      var i = this;
      this.setMappedPos = function(o) {
        i.mappedPosWhenConverting = o;
      }, this.schema = e, this.eventEmitter = a, this.focusedNode = null, this.mappedPosWhenConverting = null, this.toWwConvertors = k$e(n), this.toMdConvertors = L$e(r || {}), this.eventEmitter.listen("setFocusedNode", function(o) {
        return i.focusedNode = o;
      });
    }
    return t.prototype.getMappedPos = function() {
      return this.mappedPosWhenConverting;
    }, t.prototype.getInfoForPosSync = function() {
      return { node: this.focusedNode, setMappedPos: this.setMappedPos };
    }, t.prototype.toWysiwygModel = function(e) {
      var r = new C$e(this.schema, this.toWwConvertors);
      return r.convertNode(e, this.getInfoForPosSync());
    }, t.prototype.toMarkdownText = function(e) {
      var r = new O$e(this.toMdConvertors), n = r.convertNode(e, this.getInfoForPosSync());
      return n = this.eventEmitter.emitReduce("beforeConvertWysiwygToMarkdown", n), n;
    }, t;
  }()
);
function N$e(t) {
  var e = t.plugin, r = t.eventEmitter, n = t.usageStatistics, a = t.instance, i = { Plugin: nt.Plugin, PluginKey: nt.PluginKey, Selection: nt.Selection, TextSelection: nt.TextSelection }, o = { Decoration: ia.Decoration, DecorationSet: ia.DecorationSet }, u = { Fragment: Qe.Fragment }, m = { InputRule: Xi.InputRule, inputRules: Xi.inputRules, undoInputRule: Xi.undoInputRule }, y = { keymap: ro.keymap }, C = {
    eventEmitter: r,
    usageStatistics: n,
    instance: a,
    pmState: i,
    pmView: o,
    pmModel: u,
    pmRules: m,
    pmKeymap: y,
    i18n: dt
  };
  if (Ni(e)) {
    var T = e[0], x = e[1], M = x === void 0 ? {} : x;
    return T(C, M);
  }
  return e(C);
}
function Wm(t) {
  var e = t.plugins, r = t.eventEmitter, n = t.usageStatistics, a = t.instance;
  return r.listen("mixinTableOffsetMapPrototype", cUe), (e ?? []).reduce(function(i, o) {
    var u = N$e({
      plugin: o,
      eventEmitter: r,
      usageStatistics: n,
      instance: a
    });
    if (!u)
      throw new Error("The return value of the executed plugin is empty.");
    var m = u.markdownParsers, y = u.toHTMLRenderers, C = u.toMarkdownRenderers, T = u.markdownPlugins, x = u.wysiwygPlugins, M = u.wysiwygNodeViews, P = u.markdownCommands, q = u.wysiwygCommands, _ = u.toolbarItems;
    return y && (i.toHTMLRenderers = ys(i.toHTMLRenderers, y)), C && (i.toMarkdownRenderers = ys(i.toMarkdownRenderers, C)), T && (i.mdPlugins = i.mdPlugins.concat(T)), x && (i.wwPlugins = i.wwPlugins.concat(x)), M && (i.wwNodeViews = ge(ge({}, i.wwNodeViews), M)), P && (i.mdCommands = ge(ge({}, i.mdCommands), P)), q && (i.wwCommands = ge(ge({}, i.wwCommands), q)), _ && (i.toolbarItems = i.toolbarItems.concat(_)), m && (i.markdownParsers = ge(ge({}, i.markdownParsers), m)), i;
  }, {
    toHTMLRenderers: {},
    toMarkdownRenderers: {},
    mdPlugins: [],
    wwPlugins: [],
    wwNodeViews: {},
    mdCommands: {},
    wwCommands: {},
    toolbarItems: [],
    markdownParsers: {}
  });
}
var R$e = "data-task", I$e = "data-task-disabled", P$e = "checked";
function B$e(t) {
  ["htmlBlock", "htmlInline"].forEach(function(e) {
    t[e] && Object.keys(t[e]).forEach(function(r) {
      return wm(r);
    });
  });
}
var jm = (
  /** @class */
  function() {
    function t(e) {
      var r = this;
      this.options = bc({
        linkAttributes: null,
        extendedAutolinks: !1,
        customHTMLRenderer: null,
        referenceDefinition: !1,
        customHTMLSanitizer: null,
        frontMatter: !1,
        usageStatistics: !0,
        theme: "light"
      }, e), this.eventEmitter = new $m();
      var n = lh(this.options.linkAttributes), a = Wm({
        plugins: this.options.plugins,
        eventEmitter: this.eventEmitter,
        usageStatistics: this.options.usageStatistics,
        instance: this
      }) || {}, i = a.toHTMLRenderers, o = a.markdownParsers, u = this.options, m = u.customHTMLRenderer, y = u.extendedAutolinks, C = u.referenceDefinition, T = u.frontMatter, x = u.customHTMLSanitizer, M = {
        linkAttributes: n,
        customHTMLRenderer: ge(ge({}, i), m),
        extendedAutolinks: y,
        referenceDefinition: C,
        frontMatter: T,
        sanitizer: x || ti
      };
      B$e(M.customHTMLRenderer), this.options.events && Ci(this.options.events, function(ie, ee) {
        r.on(ee, ie);
      });
      var P = this.options, q = P.el, _ = P.initialValue, K = P.theme, X = q.innerHTML;
      K !== "light" && q.classList.add(Ke(K)), q.innerHTML = "", this.toastMark = new gm("", {
        disallowedHtmlBlockTags: ["br", "img"],
        extendedAutolinks: y,
        referenceDefinition: C,
        disallowDeepHeading: !0,
        frontMatter: T,
        customParser: o
      }), this.preview = new Sm(this.eventEmitter, ge(ge({}, M), { isViewer: !0 })), _h(this.preview.previewContent, "mousedown", this.toggleTask.bind(this)), _ ? this.setMarkdown(_) : X && this.preview.setHTML(X), q.appendChild(this.preview.previewContent), this.eventEmitter.emit("load", this);
    }
    return t.prototype.toggleTask = function(e) {
      var r = e.target, n = getComputedStyle(r, ":before");
      !r.hasAttribute(I$e) && r.hasAttribute(R$e) && Mc(n, e.offsetX, e.offsetY) && (Lc(r, P$e), this.eventEmitter.emit("change", {
        source: "viewer",
        date: e
      }));
    }, t.prototype.setMarkdown = function(e) {
      var r = this.toastMark.getLineTexts(), n = r.length, a = Dr(r), i = [n, a.length + 1], o = this.toastMark.editMarkdown([1, 1], i, e || "");
      this.eventEmitter.emit("updatePreview", o);
    }, t.prototype.on = function(e, r) {
      this.eventEmitter.listen(e, r);
    }, t.prototype.off = function(e) {
      this.eventEmitter.removeEventHandler(e);
    }, t.prototype.addHook = function(e, r) {
      this.eventEmitter.removeEventHandler(e), this.eventEmitter.listen(e, r);
    }, t.prototype.destroy = function() {
      Fh(this.preview.el, "mousedown", this.toggleTask.bind(this)), this.preview.destroy(), this.eventEmitter.emit("destroy");
    }, t.prototype.isViewer = function() {
      return !0;
    }, t.prototype.isMarkdownMode = function() {
      return !1;
    }, t.prototype.isWysiwygMode = function() {
      return !1;
    }, t;
  }()
);
function vs(t) {
  return t instanceof Qe.Node;
}
function Gm(t) {
  var e = [
    "document",
    "blockQuote",
    "bulletList",
    "orderedList",
    "listItem",
    "paragraph",
    "heading",
    "emph",
    "strong",
    "strike",
    "link",
    "image",
    "table",
    "tableHead",
    "tableBody",
    "tableRow",
    "tableHeadCell",
    "tableBodyCell"
  ];
  return Ar(e, t);
}
function q$e(t) {
  var e = t.attrs, r = t.type, n = r.name, a = {
    type: n,
    wysiwygNode: !0,
    literal: !Gm(n) && vs(t) ? t.textContent : null
  }, i = {
    heading: { level: e.level },
    link: { destination: e.linkUrl, title: e.title },
    image: { destination: e.imageUrl },
    codeBlock: { info: e.language },
    bulletList: { type: "list", listData: { type: "bullet" } },
    orderedList: { type: "list", listData: { type: "ordered", start: e.order } },
    listItem: { type: "item", listData: { task: e.task, checked: e.checked } },
    tableHeadCell: { type: "tableCell", cellType: "head", align: e.align },
    tableBodyCell: { type: "tableCell", cellType: "body", align: e.align },
    customBlock: { info: e.info }
  }, o = i[n], u = ge(ge({}, a), o), m = t.attrs, y = m.htmlAttrs, C = m.childrenHTML;
  return y ? ge(ge({}, u), { attrs: y, childrenHTML: C }) : u;
}
var F$e = {
  openTag: function(t, e) {
    var r = t, n = r.tagName, a = r.classNames, i = r.attributes, o = document.createElement(n), u = {};
    a && (o.className = a.join(" ")), i && (u = ge(ge({}, u), i)), Dc(u, o), e.push(o);
  },
  closeTag: function(t, e) {
    if (e.length > 1) {
      var r = e.pop();
      Dr(e).appendChild(r);
    }
  },
  html: function(t, e) {
    Dr(e).insertAdjacentHTML("beforeend", t.content);
  },
  text: function(t, e) {
    var r = document.createTextNode(t.content);
    Dr(e).appendChild(r);
  }
}, _$e = (
  /** @class */
  function() {
    function t(e, r) {
      var n = Vc(e, r), a = ge(ge({}, r.htmlBlock), r.htmlInline);
      this.customConvertorKeys = Object.keys(r).concat(Object.keys(a)), this.renderer = new $c({
        gfm: !0,
        convertors: ge(ge({}, n), a)
      }), this.convertors = this.renderer.getConvertors();
    }
    return t.prototype.generateTokens = function(e) {
      var r = q$e(e), n = {
        entering: !0,
        leaf: vs(e) ? e.isLeaf : !1,
        options: this.renderer.getOptions(),
        getChildrenText: function() {
          return vs(e) ? e.textContent : "";
        },
        skipChildren: function() {
          return !1;
        }
      }, a = this.convertors[e.type.name], i = a(r, n, this.convertors), o = Ni(i) ? i : [i];
      return (Gm(e.type.name) || e.attrs.htmlInline) && (n.entering = !1, o.push({ type: "text", content: vs(e) ? e.textContent : "" }), o = o.concat(a(r, n, this.convertors))), o;
    }, t.prototype.toDOMNode = function(e) {
      var r = this.generateTokens(e), n = [];
      return r.forEach(function(a) {
        return F$e[a.type](a, n);
      }), n[0];
    }, t.prototype.getToDOMNode = function(e) {
      return Ar(this.customConvertorKeys, e) ? this.toDOMNode.bind(this) : null;
    }, t;
  }()
), H$e = 100, U$e = 15, rs = null, Fu = null;
function Zd(t, e) {
  var r = e.syncScrollTop, n = e.releaseEventBlock;
  Fu && clearTimeout(Fu), r(t), Fu = setTimeout(function() {
    n();
  }, U$e);
}
function z$e(t, e, r) {
  var n = e - t, a = Date.now(), i = function() {
    var o = Date.now(), u = (o - a) / H$e, m;
    rs && clearTimeout(rs), u < 1 ? (m = t + n * Math.cos((1 - u) * Math.PI / 2), Zd(Math.ceil(m), r), rs = setTimeout(i, 1)) : (Zd(e, r), rs = null);
  };
  i();
}
var $$e = 18, V$e = (
  /** @class */
  function() {
    function t(e, r, n) {
      this.latestEditorScrollTop = null, this.latestPreviewScrollTop = null, this.blockedScroll = null, this.active = !0, this.timer = null;
      var a = r.previewContent, i = r.el;
      this.previewRoot = a, this.previewEl = i, this.mdEditor = e, this.editorView = e.view, this.toastMark = e.getToastMark(), this.eventEmitter = n, this.addScrollSyncEvent();
    }
    return t.prototype.addScrollSyncEvent = function() {
      var e = this;
      this.eventEmitter.listen("afterPreviewRender", function() {
        e.clearTimer(), e.timer = setTimeout(function() {
          e.syncPreviewScrollTop(!0);
        }, 200);
      }), this.eventEmitter.listen("scroll", function(r, n) {
        e.active && (r === "editor" && e.blockedScroll !== "editor" ? e.syncPreviewScrollTop() : r === "preview" && e.blockedScroll !== "preview" && e.syncEditorScrollTop(n));
      }), this.eventEmitter.listen("toggleScrollSync", function(r) {
        e.active = r;
      });
    }, t.prototype.getMdNodeAtPos = function(e, r) {
      var n = e.content.findIndex(r.pos), a = n.index;
      return this.toastMark.findFirstNodeAtLine(a + 1);
    }, t.prototype.getScrollTopByCaretPos = function() {
      var e = this.mdEditor.getSelection(), r = this.toastMark.findFirstNodeAtLine(e[0][0]), n = this.previewEl.clientHeight, a = Iu(this.previewRoot, r).el, i = Ms(a, this.previewRoot) || a.offsetTop, o = a.clientHeight, u = i + o - n * 0.5;
      this.latestEditorScrollTop = null;
      var m = a.getBoundingClientRect().top - this.previewEl.getBoundingClientRect().top;
      return m < n ? null : u;
    }, t.prototype.syncPreviewScrollTop = function(e) {
      e === void 0 && (e = !1);
      var r = this, n = r.editorView, a = r.previewEl, i = r.previewRoot, o = n.dom.getBoundingClientRect(), u = o.left, m = o.top, y = n.posAtCoords({ left: u, top: m }), C = n.state.doc, T = this.getMdNodeAtPos(C, y);
      if (!(!T || LY(T))) {
        var x = a.scrollTop, M = n.dom, P = M.scrollTop, q = M.scrollHeight, _ = M.clientHeight, K = M.children, X = q - P <= _ + $$e, ie = X ? a.scrollHeight : 0;
        if (P && !X) {
          if (e) {
            var ee = this.getScrollTopByCaretPos();
            if (!ee)
              return;
            ie = ee;
          } else {
            var oe = Iu(this.previewRoot, T), ue = oe.el, pe = oe.mdNode, Se = Bd(C, pe, K), Re = Se.height, Me = Se.rect, ze = Ms(ue, i) || ue.offsetTop, vt = ue.clientHeight, je = m > Me.top ? Math.min((m - Me.top) / Re, 1) : 0;
            ie = ze + vt * je;
          }
          ie = this.getResolvedScrollTop("editor", P, ie, x), this.latestEditorScrollTop = P;
        }
        ie !== x && this.run("editor", ie, x);
      }
    }, t.prototype.syncEditorScrollTop = function(e) {
      var r = this, n = r.toastMark, a = r.editorView, i = r.previewRoot, o = r.previewEl, u = a.dom, m = a.state, y = o.scrollTop, C = o.clientHeight, T = o.scrollHeight, x = T - y <= C, M = u.scrollTop, P = x ? u.scrollHeight : 0;
      if (y && e && !x) {
        if (e = HHe(e, i), !e.getAttribute("data-nodeid"))
          return;
        var q = u.children, _ = Number(e.getAttribute("data-nodeid")), K = Iu(this.previewRoot, n.findNodeById(_)), X = K.mdNode, ie = K.el, ee = lo(X);
        P = q[ee - 1].offsetTop;
        var oe = Bd(m.doc, X, q).height, ue = KHe(ie, i, _), pe = ue.nodeHeight, Se = ue.offsetTop;
        P += zHe(y, Se, pe, oe), P = this.getResolvedScrollTop("preview", y, P, M), this.latestPreviewScrollTop = y;
      }
      P !== M && this.run("preview", P, M);
    }, t.prototype.getResolvedScrollTop = function(e, r, n, a) {
      var i = e === "editor" ? this.latestEditorScrollTop : this.latestPreviewScrollTop;
      return i === null ? n : i < r ? Math.max(n, a) : Math.min(n, a);
    }, t.prototype.run = function(e, r, n) {
      var a = this, i;
      e === "editor" ? (i = this.previewEl, this.blockedScroll = "preview") : (i = this.editorView.dom, this.blockedScroll = "editor");
      var o = {
        syncScrollTop: function(u) {
          return i.scrollTop = u;
        },
        releaseEventBlock: function() {
          return a.blockedScroll = null;
        }
      };
      z$e(n, r, o);
    }, t.prototype.clearTimer = function() {
      this.timer && (clearTimeout(this.timer), this.timer = null);
    }, t.prototype.destroy = function() {
      this.clearTimer(), this.eventEmitter.removeEventHandler("scroll"), this.eventEmitter.removeEventHandler("afterPreviewRender");
    }, t;
  }()
), W$e = {
  getPopupInitialValues: function(t, e) {
    var r = e.popupName;
    return r === "link" ? { linkText: t.getSelectedText() } : {};
  }
};
function j$e(t) {
  t.eventEmitter.listen("query", function(e, r) {
    return W$e[e](t, r);
  });
}
var Km = (
  /** @class */
  function() {
    function t(e) {
      var r = this;
      this.initialHTML = e.el.innerHTML, e.el.innerHTML = "", this.options = bc({
        previewStyle: "tab",
        previewHighlight: !0,
        initialEditType: "markdown",
        height: "300px",
        minHeight: "200px",
        language: "en-US",
        useCommandShortcut: !0,
        usageStatistics: !0,
        toolbarItems: [
          ["heading", "bold", "italic", "strike"],
          ["hr", "quote"],
          ["ul", "ol", "task", "indent", "outdent"],
          ["table", "image", "link"],
          ["code", "codeblock"],
          ["scrollSync"]
        ],
        hideModeSwitch: !1,
        linkAttributes: null,
        extendedAutolinks: !1,
        customHTMLRenderer: null,
        customMarkdownRenderer: null,
        referenceDefinition: !1,
        customHTMLSanitizer: null,
        frontMatter: !1,
        widgetRules: [],
        theme: "light",
        autofocus: !0
      }, e);
      var n = this.options, a = n.customHTMLRenderer, i = n.extendedAutolinks, o = n.referenceDefinition, u = n.frontMatter, m = n.customMarkdownRenderer, y = n.useCommandShortcut, C = n.initialEditType, T = n.widgetRules, x = n.customHTMLSanitizer;
      this.mode = C || "markdown", this.mdPreviewStyle = this.options.previewStyle, this.i18n = dt, this.i18n.setCode(this.options.language), this.eventEmitter = new $m(), _Y(T);
      var M = lh(this.options.linkAttributes);
      this.pluginInfo = Wm({
        plugins: this.options.plugins,
        eventEmitter: this.eventEmitter,
        usageStatistics: this.options.usageStatistics,
        instance: this
      });
      var P = this.pluginInfo, q = P.toHTMLRenderers, _ = P.toMarkdownRenderers, K = P.mdPlugins, X = P.wwPlugins, ie = P.wwNodeViews, ee = P.mdCommands, oe = P.wwCommands, ue = P.markdownParsers, pe = {
        linkAttributes: M,
        customHTMLRenderer: ys(q, a),
        extendedAutolinks: i,
        referenceDefinition: o,
        frontMatter: u,
        sanitizer: x || ti
      }, Se = new _$e(M, pe.customHTMLRenderer), Re = RHe(pe.customHTMLRenderer, pe.sanitizer, Se);
      this.toastMark = new gm("", {
        disallowedHtmlBlockTags: ["br", "img"],
        extendedAutolinks: i,
        referenceDefinition: o,
        disallowDeepHeading: !0,
        frontMatter: u,
        customParser: ue
      }), this.mdEditor = new UZ(this.eventEmitter, {
        toastMark: this.toastMark,
        useCommandShortcut: y,
        mdPlugins: K
      }), this.preview = new Sm(this.eventEmitter, ge(ge({}, pe), { isViewer: !1, highlight: this.options.previewHighlight })), this.wwEditor = new a$e(this.eventEmitter, {
        toDOMAdaptor: Se,
        useCommandShortcut: y,
        htmlSchemaMap: Re,
        linkAttributes: M,
        wwPlugins: X,
        wwNodeViews: ie
      }), this.convertor = new D$e(this.wwEditor.getSchema(), ge(ge({}, _), m), Vc(M, pe.customHTMLRenderer), this.eventEmitter), this.setMinHeight(this.options.minHeight), this.setHeight(this.options.height), this.setMarkdown(this.options.initialValue, !1), this.options.placeholder && this.setPlaceholder(this.options.placeholder), this.options.initialValue || this.setHTML(this.initialHTML, !1), this.commandManager = new h$e(this.eventEmitter, this.mdEditor.commands, this.wwEditor.commands, function() {
        return r.mode;
      }), this.options.usageStatistics && kY(), this.scrollSync = new V$e(this.mdEditor, this.preview, this.eventEmitter), this.addInitEvent(), this.addInitCommand(ee, oe), j$e(this), this.options.hooks && Ci(this.options.hooks, function(Me, ze) {
        return r.addHook(ze, Me);
      }), this.options.events && Ci(this.options.events, function(Me, ze) {
        return r.on(ze, Me);
      }), this.eventEmitter.emit("load", this), this.moveCursorToStart(this.options.autofocus);
    }
    return t.prototype.addInitEvent = function() {
      var e = this;
      this.on("needChangeMode", this.changeMode.bind(this)), this.on("loadUI", function() {
        if (e.height !== "auto") {
          var r = Math.min(parseInt(e.minHeight, 10), parseInt(e.height, 10) - 75) + "px";
          e.setMinHeight(r);
        }
      }), f7(this.eventEmitter);
    }, t.prototype.addInitCommand = function(e, r) {
      var n = this, a = function(i, o) {
        Object.keys(o).forEach(function(u) {
          n.addCommand(i, u, o[u]);
        });
      };
      this.addCommand("markdown", "toggleScrollSync", function(i) {
        return n.eventEmitter.emit("toggleScrollSync", i.active), !0;
      }), a("markdown", e), a("wysiwyg", r);
    }, t.prototype.getCurrentModeEditor = function() {
      return this.isMarkdownMode() ? this.mdEditor : this.wwEditor;
    }, t.factory = function(e) {
      return e.viewer ? new jm(e) : new t(e);
    }, t.setLanguage = function(e, r) {
      dt.setLanguage(e, r);
    }, t.prototype.changePreviewStyle = function(e) {
      this.mdPreviewStyle !== e && (this.mdPreviewStyle = e, this.eventEmitter.emit("changePreviewStyle", e));
    }, t.prototype.exec = function(e, r) {
      this.commandManager.exec(e, r);
    }, t.prototype.addCommand = function(e, r, n) {
      var a = this, i = function(o) {
        o === void 0 && (o = {});
        var u = (e === "markdown" ? a.mdEditor : a.wwEditor).view;
        n(o, u.state, u.dispatch, u);
      };
      this.commandManager.addCommand(e, r, i);
    }, t.prototype.on = function(e, r) {
      this.eventEmitter.listen(e, r);
    }, t.prototype.off = function(e) {
      this.eventEmitter.removeEventHandler(e);
    }, t.prototype.addHook = function(e, r) {
      this.eventEmitter.removeEventHandler(e), this.eventEmitter.listen(e, r);
    }, t.prototype.removeHook = function(e) {
      this.eventEmitter.removeEventHandler(e);
    }, t.prototype.focus = function() {
      this.getCurrentModeEditor().focus();
    }, t.prototype.blur = function() {
      this.getCurrentModeEditor().blur();
    }, t.prototype.moveCursorToEnd = function(e) {
      e === void 0 && (e = !0), this.getCurrentModeEditor().moveCursorToEnd(e);
    }, t.prototype.moveCursorToStart = function(e) {
      e === void 0 && (e = !0), this.getCurrentModeEditor().moveCursorToStart(e);
    }, t.prototype.setMarkdown = function(e, r) {
      if (e === void 0 && (e = ""), r === void 0 && (r = !0), this.mdEditor.setMarkdown(e, r), this.isWysiwygMode()) {
        var n = this.toastMark.getRootNode(), a = this.convertor.toWysiwygModel(n);
        this.wwEditor.setModel(a, r);
      }
    }, t.prototype.setHTML = function(e, r) {
      e === void 0 && (e = ""), r === void 0 && (r = !0);
      var n = document.createElement("div");
      n.innerHTML = l7(e);
      var a = Qe.DOMParser.fromSchema(this.wwEditor.schema).parse(n);
      this.isMarkdownMode() ? this.mdEditor.setMarkdown(this.convertor.toMarkdownText(a), r) : this.wwEditor.setModel(a, r);
    }, t.prototype.getMarkdown = function() {
      return this.isMarkdownMode() ? this.mdEditor.getMarkdown() : this.convertor.toMarkdownText(this.wwEditor.getModel());
    }, t.prototype.getHTML = function() {
      var e = this;
      this.eventEmitter.holdEventInvoke(function() {
        if (e.isMarkdownMode()) {
          var a = e.toastMark.getRootNode(), i = e.convertor.toWysiwygModel(a);
          e.wwEditor.setModel(i);
        }
      });
      var r = Nc(this.wwEditor.view.dom.innerHTML);
      if (this.placeholder) {
        var n = new RegExp('<span class="placeholder[^>]+>' + this.placeholder + "</span>", "i");
        return r.replace(n, "");
      }
      return r;
    }, t.prototype.insertText = function(e) {
      this.getCurrentModeEditor().replaceSelection(e);
    }, t.prototype.setSelection = function(e, r) {
      this.getCurrentModeEditor().setSelection(e, r);
    }, t.prototype.replaceSelection = function(e, r, n) {
      this.getCurrentModeEditor().replaceSelection(e, r, n);
    }, t.prototype.deleteSelection = function(e, r) {
      this.getCurrentModeEditor().deleteSelection(e, r);
    }, t.prototype.getSelectedText = function(e, r) {
      return this.getCurrentModeEditor().getSelectedText(e, r);
    }, t.prototype.getRangeInfoOfNode = function(e) {
      return this.getCurrentModeEditor().getRangeInfoOfNode(e);
    }, t.prototype.addWidget = function(e, r, n) {
      this.getCurrentModeEditor().addWidget(e, r, n);
    }, t.prototype.replaceWithWidget = function(e, r, n) {
      this.getCurrentModeEditor().replaceWithWidget(e, r, n);
    }, t.prototype.setHeight = function(e) {
      var r = this.options.el;
      sa(e) && (e === "auto" ? Ln(r, "auto-height") : gn(r, "auto-height"), this.setMinHeight(this.getMinHeight())), Dn(r, { height: e }), this.height = e;
    }, t.prototype.getHeight = function() {
      return this.height;
    }, t.prototype.setMinHeight = function(e) {
      if (e !== this.minHeight) {
        var r = this.height || this.options.height;
        r !== "auto" && this.options.el.querySelector("." + Ke("main")) && (e = Math.min(parseInt(e, 10), parseInt(r, 10) - 75) + "px");
        var n = parseInt(e, 10);
        this.minHeight = e, this.wwEditor.setMinHeight(n), this.mdEditor.setMinHeight(n), this.preview.setMinHeight(n);
      }
    }, t.prototype.getMinHeight = function() {
      return this.minHeight;
    }, t.prototype.isMarkdownMode = function() {
      return this.mode === "markdown";
    }, t.prototype.isWysiwygMode = function() {
      return this.mode === "wysiwyg";
    }, t.prototype.isViewer = function() {
      return !1;
    }, t.prototype.getCurrentPreviewStyle = function() {
      return this.mdPreviewStyle;
    }, t.prototype.changeMode = function(e, r) {
      if (this.mode !== e) {
        if (this.mode = e, this.isWysiwygMode()) {
          var n = this.toastMark.getRootNode(), a = this.convertor.toWysiwygModel(n);
          this.wwEditor.setModel(a);
        } else {
          var a = this.wwEditor.getModel();
          this.mdEditor.setMarkdown(this.convertor.toMarkdownText(a), !r);
        }
        if (this.eventEmitter.emit("removePopupWidget"), this.eventEmitter.emit("changeMode", e), !r) {
          var i = this.convertor.getMappedPos();
          this.focus(), this.isWysiwygMode() && ea(i) ? this.wwEditor.setSelection(i) : Array.isArray(i) && this.mdEditor.setSelection(i);
        }
      }
    }, t.prototype.destroy = function() {
      var e = this;
      this.wwEditor.destroy(), this.mdEditor.destroy(), this.preview.destroy(), this.scrollSync.destroy(), this.eventEmitter.emit("destroy"), this.eventEmitter.getEvents().forEach(function(r, n) {
        return e.off(n);
      });
    }, t.prototype.hide = function() {
      this.eventEmitter.emit("hide");
    }, t.prototype.show = function() {
      this.eventEmitter.emit("show");
    }, t.prototype.setScrollTop = function(e) {
      this.getCurrentModeEditor().setScrollTop(e);
    }, t.prototype.getScrollTop = function() {
      return this.getCurrentModeEditor().getScrollTop();
    }, t.prototype.reset = function() {
      this.wwEditor.setModel([]), this.mdEditor.setMarkdown("");
    }, t.prototype.getSelection = function() {
      return this.getCurrentModeEditor().getSelection();
    }, t.prototype.setPlaceholder = function(e) {
      this.placeholder = e, this.mdEditor.setPlaceholder(e), this.wwEditor.setPlaceholder(e);
    }, t.prototype.getEditorElements = function() {
      return {
        mdEditor: this.mdEditor.getElement(),
        mdPreview: this.preview.getElement(),
        wwEditor: this.wwEditor.getElement()
      };
    }, t.prototype.convertPosToMatchEditorMode = function(e, r, n) {
      var a, i;
      r === void 0 && (r = e), n === void 0 && (n = this.mode);
      var o = this.mdEditor.view.state.doc, u = Array.isArray(e), m = Array.isArray(r), y = e, C = r;
      if (u !== m)
        throw new Error("Types of arguments must be same");
      return n === "markdown" && !u && !m ? (a = is(o, e, r), y = a[0], C = a[1]) : n === "wysiwyg" && u && m && (i = Ka(o, e, r), y = i[0], C = i[1]), [y, C];
    }, t;
  }()
);
function G$e(t) {
  for (var e, r, n = arguments, a = 1, i = "", o = "", u = [0], m = function(C) {
    a === 1 && (C || (i = i.replace(/^\s*\n\s*|\s*\n\s*$/g, ""))) ? u.push(C ? n[C] : i) : a === 3 && (C || i) ? (u[1] = C ? n[C] : i, a = 2) : a === 2 && i === "..." && C ? u[2] = Ec(u[2] || {}, n[C]) : a === 2 && i && !C ? (u[2] = u[2] || {})[i] = !0 : a >= 5 && (a === 5 ? ((u[2] = u[2] || {})[r] = C ? i ? i + n[C] : n[C] : i, a = 6) : (C || i) && (u[2][r] += C ? i + n[C] : i)), i = "";
  }, y = 0; y < t.length; y++) {
    y && (a === 1 && m(), m(y));
    for (let C = 0; C < t[y].length; C++)
      e = t[y][C], a === 1 ? e === "<" ? (m(), u = [u, "", null], a = 3) : i += e : a === 4 ? i === "--" && e === ">" ? (a = 1, i = "") : i = e + i[0] : o ? e === o ? o = "" : i += e : e === '"' || e === "'" ? o = e : e === ">" ? (m(), a = 1) : a && (e === "=" ? (a = 5, r = i, i = "") : e === "/" && (a < 5 || t[y][C + 1] === ">") ? (m(), a === 3 && (u = u[0]), a = u, (u = u[0]).push(this.apply(null, a.slice(1))), a = 0) : e === " " || e === "	" || e === `
` || e === "\r" ? (m(), a = 2) : i += e), a === 3 && i === "!--" && (a = 4, u = u[0]);
  }
  return m(), u.length > 2 ? u.slice(1) : u[1];
}
function K$e(t) {
  return typeof t == "boolean" || t instanceof Boolean;
}
var J$e = K$e, Y$e = (
  /** @class */
  function() {
    function t(e) {
      this.current = e, this.root = e, this.entering = !0;
    }
    return t.prototype.walk = function() {
      var e = this, r = e.entering, n = e.current;
      return n ? (r ? n.firstChild ? (this.current = n.firstChild, this.entering = !0) : this.entering = !1 : n === this.root ? this.current = null : n.next ? (this.current = n.next, this.entering = !0) : (this.current = n.parent, this.entering = !1), { vnode: n, entering: r }) : null;
    }, t;
  }()
), bn = (
  /** @class */
  function() {
    function t(e, r, n) {
      this.parent = null, this.old = null, this.firstChild = null, this.next = null, this.skip = !1, this.type = e, this.props = r, this.children = n, this.props.children = n, r.ref && (this.ref = r.ref, delete r.ref), r.key && (this.key = r.key, delete r.key);
    }
    return t.prototype.walker = function() {
      return new Y$e(this);
    }, t.removalNodes = [], t;
  }()
);
function Z$e(t) {
  return new bn("TEXT_NODE", { nodeValue: t }, []);
}
function Qd(t, e) {
  var r = t;
  J$e(t) || t == null ? r = null : (sa(t) || ea(t)) && (r = Z$e(String(t))), r && e.push(r);
}
function Q$e(t, e) {
  for (var r = [], n = 2; n < arguments.length; n++)
    r[n - 2] = arguments[n];
  var a = [];
  return r.forEach(function(i) {
    Array.isArray(i) ? i.forEach(function(o) {
      Qd(o, a);
    }) : Qd(i, a);
  }), new bn(t, e || {}, a);
}
var xt = G$e.bind(Q$e);
function X$e(t) {
  return t === Object(t);
}
var e2e = X$e;
function t2e(t) {
  var e;
  return t.type === "TEXT_NODE" ? e = document.createTextNode(t.props.nodeValue) : (e = document.createElement(t.type), Ym(e, {}, t.props)), e;
}
function Jm(t, e) {
  t.node ? e.removeChild(t.node) : Jm(t.firstChild, e);
}
function r2e(t, e, r) {
  Object.keys(e).forEach(function(n) {
    if (/^on/.test(n)) {
      if (!r[n] || e[n] !== r[n]) {
        var a = n.slice(2).toLowerCase();
        t.removeEventListener(a, e[n]);
      }
    } else
      n !== "children" && !r[n] && !n7(t) && t.removeAttribute(n);
  }), Ym(t, e, r, function(n) {
    return !wc(e[n], r[n]);
  });
}
var n2e = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
function Ym(t, e, r, n) {
  Object.keys(r).forEach(function(a) {
    if (!n || n(a))
      if (/^on/.test(a)) {
        var i = a.slice(2).toLowerCase();
        t.addEventListener(i, r[a]);
      } else
        a === "nodeValue" ? t[a] = r[a] : a === "style" && e2e(r[a]) ? a2e(t, e[a], r[a]) : a !== "children" && (r[a] === !1 ? t.removeAttribute(a) : t.setAttribute(a, r[a]));
  });
}
function a2e(t, e, r) {
  e && Object.keys(e).forEach(function(n) {
    t.style[n] = "";
  }), Object.keys(r).forEach(function(n) {
    var a = r[n];
    t.style[n] = ea(a) && !n2e.test(n) ? a + "px" : a;
  });
}
function Gc(t) {
  if (bn.removalNodes.forEach(function(i) {
    return ep(i);
  }), t) {
    for (var e = void 0, r = t.walker(); e = r.walk(); )
      if (t = e.vnode, e.entering)
        ep(t);
      else if (un(t.type)) {
        var n = t.component;
        if (!t.old && n.mounted && n.mounted(), t.old && n.updated) {
          var a = n.prevProps || {};
          n.updated(a);
        }
      }
  }
}
function Xd(t) {
  for (var e = t.parent; !e.node; )
    e = e.parent;
  return e.node;
}
function ep(t) {
  if (!(!t || !t.parent)) {
    if (t.node) {
      var e = Xd(t);
      t.effect === "A" ? e.appendChild(t.node) : t.effect === "U" && r2e(t.node, t.old.props, t.props);
    }
    if (t.effect === "D") {
      for (var r = void 0, n = t.walker(); r = n.walk(); )
        if (t = r.vnode, !r.entering)
          if (un(t.type)) {
            var a = t.component;
            a.beforeDestroy && a.beforeDestroy();
          } else {
            var e = Xd(t);
            Jm(t, e);
          }
    }
    t.ref && (t.component ? t.ref(t.component) : t.node && t.ref(t.node));
  }
}
function i2e(t, e) {
  var r = e.props, n = e.component;
  return n ? (n.prevProps = n.props, n.props = e.props, n) : new t(r);
}
function Zm(t) {
  for (var e = t; t && !t.skip; ) {
    if (un(t.type)) {
      var r = i2e(t.type, t);
      r.vnode = t, t.component = r, t.props.children = t.children = [r.render()], tp(t);
    } else
      t.node || (t.node = t2e(t)), tp(t);
    if (t.firstChild)
      t = t.firstChild;
    else {
      for (; t && t.parent && !t.next && (t = t.parent, t !== e); )
        ;
      t = t.next;
    }
  }
}
function o2e(t, e) {
  return t && e && e.type === t.type && (!e.key || e.key === t.key);
}
function tp(t) {
  var e = t.children, r = t.old ? t.old.firstChild : null, n = null;
  e.forEach(function(i, o) {
    var u = o2e(r, i);
    u && (i.old = r, i.parent = t, i.node = r.node, i.component = r.component, i.effect = "U"), i && !u && (i.old = null, i.parent = t, i.node = null, i.effect = "A"), r && !u && (bn.removalNodes.push(r), r.effect = "D"), r && (r = r.next), o === 0 ? t.firstChild = i : i && (n.next = i), n = i;
  });
  var a = Dr(e);
  if (!e.length)
    for (; r; )
      bn.removalNodes.push(r), r.effect = "D", r = r.next;
  for (; r && a; )
    r && a.old !== r && (bn.removalNodes.push(r), r.effect = "D", r = r.next);
}
function s2e(t) {
  t.effect = "D", bn.removalNodes = [t], Gc(), bn.removalNodes = [];
}
function l2e(t) {
  var e = t.vnode;
  e.effect = "U", e.old = e, e.next && (e.next.skip = !0), bn.removalNodes = [], Zm(e), Gc(e), e.next && (e.next.skip = !1);
}
function u2e(t, e) {
  var r = new bn(t.tagName.toLowerCase(), {}, [e]);
  return r.node = t, bn.removalNodes = [], Zm(r), Gc(r), function() {
    return s2e(r.firstChild);
  };
}
var Nr = (
  /** @class */
  function() {
    function t(e) {
      this.props = e, this.state = {}, this.refs = {};
    }
    return t.prototype.setState = function(e) {
      var r = ge(ge({}, this.state), e);
      wc(this.state, r) || (this.state = r, l2e(this));
    }, t;
  }()
), c2e = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e(r) {
      var n = t.call(this, r) || this;
      return n.state = {
        hide: !1
      }, n;
    }
    return e.prototype.show = function() {
      this.setState({ hide: !1 });
    }, e.prototype.hide = function() {
      this.setState({ hide: !0 });
    }, e.prototype.render = function() {
      var r = this.props, n = r.editorType, a = r.eventEmitter;
      return xt(rp || (rp = Et([`
      <div class="`, '" style="display: ', `">
        <div
          class="tab-item`, `"
          onClick=`, `
        >
          `, `
        </div>
        <div
          class="tab-item`, `"
          onClick=`, `
        >
          `, `
        </div>
      </div>
    `], [
        `
      <div class="`,
        '" style="display: ',
        `">
        <div
          class="tab-item`,
        `"
          onClick=`,
        `
        >
          `,
        `
        </div>
        <div
          class="tab-item`,
        `"
          onClick=`,
        `
        >
          `,
        `
        </div>
      </div>
    `
      ])), Ke("mode-switch"), this.state.hide ? "none" : "block", n === "markdown" ? " active" : "", function() {
        a.emit("needChangeMode", "markdown");
      }, dt.get("Markdown"), n === "wysiwyg" ? " active" : "", function() {
        a.emit("needChangeMode", "wysiwyg");
      }, dt.get("WYSIWYG"));
    }, e;
  }(Nr)
), rp;
function f2e(t, e) {
  var r, n;
  e = e || 0;
  function a() {
    n = Array.prototype.slice.call(arguments), window.clearTimeout(r), r = window.setTimeout(function() {
      t.apply(null, n);
    }, e);
  }
  return a;
}
var v2e = f2e, d2e = v2e;
function p2e(t, e) {
  var r, n = !0, a = function(C) {
    t.apply(null, C), r = null;
  }, i, o, u;
  e = e || 0, i = d2e(a, e);
  function m() {
    if (u = Array.prototype.slice.call(arguments), n) {
      a(u), n = !1;
      return;
    }
    o = Number(/* @__PURE__ */ new Date()), r = r || o, i(u), o - r >= e && a(u);
  }
  function y() {
    n = !0, r = null;
  }
  return m.reset = y, m;
}
var h2e = p2e, Qm = function() {
  if (typeof Map < "u")
    return Map;
  function t(e, r) {
    var n = -1;
    return e.some(function(a, i) {
      return a[0] === r ? (n = i, !0) : !1;
    }), n;
  }
  return (
    /** @class */
    function() {
      function e() {
        this.__entries__ = [];
      }
      return Object.defineProperty(e.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: !0,
        configurable: !0
      }), e.prototype.get = function(r) {
        var n = t(this.__entries__, r), a = this.__entries__[n];
        return a && a[1];
      }, e.prototype.set = function(r, n) {
        var a = t(this.__entries__, r);
        ~a ? this.__entries__[a][1] = n : this.__entries__.push([r, n]);
      }, e.prototype.delete = function(r) {
        var n = this.__entries__, a = t(n, r);
        ~a && n.splice(a, 1);
      }, e.prototype.has = function(r) {
        return !!~t(this.__entries__, r);
      }, e.prototype.clear = function() {
        this.__entries__.splice(0);
      }, e.prototype.forEach = function(r, n) {
        n === void 0 && (n = null);
        for (var a = 0, i = this.__entries__; a < i.length; a++) {
          var o = i[a];
          r.call(n, o[1], o[0]);
        }
      }, e;
    }()
  );
}(), vc = typeof window < "u" && typeof document < "u" && window.document === document, Os = function() {
  return typeof global < "u" && global.Math === Math ? global : typeof self < "u" && self.Math === Math ? self : typeof window < "u" && window.Math === Math ? window : Function("return this")();
}(), m2e = function() {
  return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(Os) : function(t) {
    return setTimeout(function() {
      return t(Date.now());
    }, 1e3 / 60);
  };
}(), g2e = 2;
function y2e(t, e) {
  var r = !1, n = !1, a = 0;
  function i() {
    r && (r = !1, t()), n && u();
  }
  function o() {
    m2e(i);
  }
  function u() {
    var m = Date.now();
    if (r) {
      if (m - a < g2e)
        return;
      n = !0;
    } else
      r = !0, n = !1, setTimeout(o, e);
    a = m;
  }
  return u;
}
var b2e = 20, k2e = ["top", "right", "bottom", "left", "width", "height", "size", "weight"], w2e = typeof MutationObserver < "u", C2e = (
  /** @class */
  function() {
    function t() {
      this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = y2e(this.refresh.bind(this), b2e);
    }
    return t.prototype.addObserver = function(e) {
      ~this.observers_.indexOf(e) || this.observers_.push(e), this.connected_ || this.connect_();
    }, t.prototype.removeObserver = function(e) {
      var r = this.observers_, n = r.indexOf(e);
      ~n && r.splice(n, 1), !r.length && this.connected_ && this.disconnect_();
    }, t.prototype.refresh = function() {
      var e = this.updateObservers_();
      e && this.refresh();
    }, t.prototype.updateObservers_ = function() {
      var e = this.observers_.filter(function(r) {
        return r.gatherActive(), r.hasActive();
      });
      return e.forEach(function(r) {
        return r.broadcastActive();
      }), e.length > 0;
    }, t.prototype.connect_ = function() {
      !vc || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), w2e ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
        attributes: !0,
        childList: !0,
        characterData: !0,
        subtree: !0
      })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0);
    }, t.prototype.disconnect_ = function() {
      !vc || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1);
    }, t.prototype.onTransitionEnd_ = function(e) {
      var r = e.propertyName, n = r === void 0 ? "" : r, a = k2e.some(function(i) {
        return !!~n.indexOf(i);
      });
      a && this.refresh();
    }, t.getInstance = function() {
      return this.instance_ || (this.instance_ = new t()), this.instance_;
    }, t.instance_ = null, t;
  }()
), Xm = function(t, e) {
  for (var r = 0, n = Object.keys(e); r < n.length; r++) {
    var a = n[r];
    Object.defineProperty(t, a, {
      value: e[a],
      enumerable: !1,
      writable: !1,
      configurable: !0
    });
  }
  return t;
}, Di = function(t) {
  var e = t && t.ownerDocument && t.ownerDocument.defaultView;
  return e || Os;
}, eg = Gs(0, 0, 0, 0);
function Ds(t) {
  return parseFloat(t) || 0;
}
function np(t) {
  for (var e = [], r = 1; r < arguments.length; r++)
    e[r - 1] = arguments[r];
  return e.reduce(function(n, a) {
    var i = t["border-" + a + "-width"];
    return n + Ds(i);
  }, 0);
}
function T2e(t) {
  for (var e = ["top", "right", "bottom", "left"], r = {}, n = 0, a = e; n < a.length; n++) {
    var i = a[n], o = t["padding-" + i];
    r[i] = Ds(o);
  }
  return r;
}
function S2e(t) {
  var e = t.getBBox();
  return Gs(0, 0, e.width, e.height);
}
function E2e(t) {
  var e = t.clientWidth, r = t.clientHeight;
  if (!e && !r)
    return eg;
  var n = Di(t).getComputedStyle(t), a = T2e(n), i = a.left + a.right, o = a.top + a.bottom, u = Ds(n.width), m = Ds(n.height);
  if (n.boxSizing === "border-box" && (Math.round(u + i) !== e && (u -= np(n, "left", "right") + i), Math.round(m + o) !== r && (m -= np(n, "top", "bottom") + o)), !A2e(t)) {
    var y = Math.round(u + i) - e, C = Math.round(m + o) - r;
    Math.abs(y) !== 1 && (u -= y), Math.abs(C) !== 1 && (m -= C);
  }
  return Gs(a.left, a.top, u, m);
}
var x2e = function() {
  return typeof SVGGraphicsElement < "u" ? function(t) {
    return t instanceof Di(t).SVGGraphicsElement;
  } : function(t) {
    return t instanceof Di(t).SVGElement && typeof t.getBBox == "function";
  };
}();
function A2e(t) {
  return t === Di(t).document.documentElement;
}
function M2e(t) {
  return vc ? x2e(t) ? S2e(t) : E2e(t) : eg;
}
function L2e(t) {
  var e = t.x, r = t.y, n = t.width, a = t.height, i = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object, o = Object.create(i.prototype);
  return Xm(o, {
    x: e,
    y: r,
    width: n,
    height: a,
    top: r,
    right: e + n,
    bottom: a + r,
    left: e
  }), o;
}
function Gs(t, e, r, n) {
  return { x: t, y: e, width: r, height: n };
}
var O2e = (
  /** @class */
  function() {
    function t(e) {
      this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = Gs(0, 0, 0, 0), this.target = e;
    }
    return t.prototype.isActive = function() {
      var e = M2e(this.target);
      return this.contentRect_ = e, e.width !== this.broadcastWidth || e.height !== this.broadcastHeight;
    }, t.prototype.broadcastRect = function() {
      var e = this.contentRect_;
      return this.broadcastWidth = e.width, this.broadcastHeight = e.height, e;
    }, t;
  }()
), D2e = (
  /** @class */
  function() {
    function t(e, r) {
      var n = L2e(r);
      Xm(this, { target: e, contentRect: n });
    }
    return t;
  }()
), N2e = (
  /** @class */
  function() {
    function t(e, r, n) {
      if (this.activeObservations_ = [], this.observations_ = new Qm(), typeof e != "function")
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      this.callback_ = e, this.controller_ = r, this.callbackCtx_ = n;
    }
    return t.prototype.observe = function(e) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(e instanceof Di(e).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var r = this.observations_;
        r.has(e) || (r.set(e, new O2e(e)), this.controller_.addObserver(this), this.controller_.refresh());
      }
    }, t.prototype.unobserve = function(e) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(e instanceof Di(e).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var r = this.observations_;
        r.has(e) && (r.delete(e), r.size || this.controller_.removeObserver(this));
      }
    }, t.prototype.disconnect = function() {
      this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
    }, t.prototype.gatherActive = function() {
      var e = this;
      this.clearActive(), this.observations_.forEach(function(r) {
        r.isActive() && e.activeObservations_.push(r);
      });
    }, t.prototype.broadcastActive = function() {
      if (this.hasActive()) {
        var e = this.callbackCtx_, r = this.activeObservations_.map(function(n) {
          return new D2e(n.target, n.broadcastRect());
        });
        this.callback_.call(e, r, e), this.clearActive();
      }
    }, t.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    }, t.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    }, t;
  }()
), tg = typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : new Qm(), rg = (
  /** @class */
  function() {
    function t(e) {
      if (!(this instanceof t))
        throw new TypeError("Cannot call a class as a function.");
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      var r = C2e.getInstance(), n = new N2e(e, r, this);
      tg.set(this, n);
    }
    return t;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(t) {
  rg.prototype[t] = function() {
    var e;
    return (e = tg.get(this))[t].apply(e, arguments);
  };
});
var R2e = function() {
  return typeof Os.ResizeObserver < "u" ? Os.ResizeObserver : rg;
}(), I2e = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.execCommand = function(r) {
      var n = On(r.target, "li");
      this.props.execCommand("heading", {
        level: Number(n.getAttribute("data-level"))
      });
    }, e.prototype.render = function() {
      var r = this;
      return xt(ip || (ip = Et([`
      <ul
        onClick=`, `
        aria-role="menu"
        aria-label="`, `"
      >
        `, `
        <li data-type="Paragraph" aria-role="menuitem">
          <div>`, `</div>
        </li>
      </ul>
    `], [
        `
      <ul
        onClick=`,
        `
        aria-role="menu"
        aria-label="`,
        `"
      >
        `,
        `
        <li data-type="Paragraph" aria-role="menuitem">
          <div>`,
        `</div>
        </li>
      </ul>
    `
      ])), function(n) {
        return r.execCommand(n);
      }, dt.get("Headings"), [1, 2, 3, 4, 5, 6].map(function(n) {
        return xt(ap || (ap = Et([`
              <li data-level="`, `" data-type="Heading" aria-role="menuitem">
                <`, ">", " ", `</$>
              </li>
            `], [`
              <li data-level="`, `" data-type="Heading" aria-role="menuitem">
                <`, ">", " ", `</$>
              </li>
            `])), n, "h" + n, dt.get("Heading"), n);
      }), dt.get("Paragraph"));
    }, e;
  }(Nr)
), ap, ip, ng = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.toggleTab = function(r, n) {
      this.props.onClick(r, n);
    }, e.prototype.render = function() {
      var r = this;
      return xt(sp || (sp = Et([`
      <div class="`, `" aria-role="tabpanel">
        `, `
      </div>
    `], [
        `
      <div class="`,
        `" aria-role="tabpanel">
        `,
        `
      </div>
    `
      ])), Ke("tabs"), this.props.tabs.map(function(n) {
        var a = n.name, i = n.text, o = r.props.activeTab === a;
        return xt(op || (op = Et([`
            <div
              class="tab-item`, `"
              onClick=`, `
              aria-role="tab"
              aria-label="`, `"
              aria-selected="`, `"
              tabindex="`, `"
            >
              `, `
            </div>
          `], [`
            <div
              class="tab-item`, `"
              onClick=`, `
              aria-role="tab"
              aria-label="`, `"
              aria-selected="`, `"
              tabindex="`, `"
            >
              `, `
            </div>
          `])), o ? " active" : "", function(u) {
          return r.toggleTab(u, a);
        }, dt.get(i), o ? "true" : "false", o ? "0" : "-1", dt.get(i));
      }));
    }, e;
  }(Nr)
), op, sp, P2e = "ui", B2e = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e(r) {
      var n = t.call(this, r) || this;
      return n.initialize = function(a) {
        a === void 0 && (a = "file");
        var i = n.refs.url;
        i.value = "", n.refs.altText.value = "", n.refs.file.value = "", gn(i, "wrong"), n.setState({ activeTab: a, file: null, fileNameElClassName: "" });
      }, n.execCommand = function() {
        n.state.activeTab === "file" ? n.emitAddImageBlob() : n.emitAddImage();
      }, n.toggleTab = function(a, i) {
        i !== n.state.activeTab && n.initialize(i);
      }, n.showFileSelectBox = function() {
        n.refs.file.click();
      }, n.changeFile = function(a) {
        var i = a.target.files;
        i != null && i.length && n.setState({ file: i[0] });
      }, n.state = { activeTab: "file", file: null, fileNameElClassName: "" }, n.tabs = [
        { name: "file", text: "File" },
        { name: "url", text: "URL" }
      ], n;
    }
    return e.prototype.emitAddImageBlob = function() {
      var r = this, n = this.refs.file.files, a = this.refs.altText, i = " wrong";
      if (n != null && n.length) {
        i = "";
        var o = n.item(0), u = function(m, y) {
          return r.props.execCommand("addImage", { imageUrl: m, altText: y || a.value });
        };
        this.props.eventEmitter.emit("addImageBlobHook", o, u, P2e);
      }
      this.setState({ fileNameElClassName: i });
    }, e.prototype.emitAddImage = function() {
      var r = this.refs.url, n = this.refs.altText, a = r.value, i = n.value || "image";
      if (gn(r, "wrong"), !a.length) {
        Ln(r, "wrong");
        return;
      }
      a && this.props.execCommand("addImage", { imageUrl: a, altText: i });
    }, e.prototype.preventSelectStart = function(r) {
      r.preventDefault();
    }, e.prototype.updated = function() {
      this.props.show || this.initialize();
    }, e.prototype.render = function() {
      var r = this, n = this.state, a = n.activeTab, i = n.file, o = n.fileNameElClassName;
      return xt(lp || (lp = Et([`
      <div aria-label="`, `">
        <`, " tabs=", " activeTab=", " onClick=", ` />
        <div style="display:`, `">
          <label for="toastuiImageUrlInput">`, `</label>
          <input
            id="toastuiImageUrlInput"
            type="text"
            ref=`, `
          />
        </div>
        <div style="display:`, `;position: relative;">
          <label for="toastuiImageFileInput">`, `</label>
          <span
            class="`, "", `"
            onClick=`, `
            onSelectstart=`, `
          >
            `, `
          </span>
          <button
            type="button"
            class="`, `"
            onClick=`, `
          >
            `, `
          </button>
          <input
            id="toastuiImageFileInput"
            type="file"
            accept="image/*"
            onChange=`, `
            ref=`, `
          />
        </div>
        <label for="toastuiAltTextInput">`, `</label>
        <input
          id="toastuiAltTextInput"
          type="text"
          ref=`, `
        />
        <div class="`, `">
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
        </div>
      </div>
    `], [`
      <div aria-label="`, `">
        <`, " tabs=", " activeTab=", " onClick=", ` />
        <div style="display:`, `">
          <label for="toastuiImageUrlInput">`, `</label>
          <input
            id="toastuiImageUrlInput"
            type="text"
            ref=`, `
          />
        </div>
        <div style="display:`, `;position: relative;">
          <label for="toastuiImageFileInput">`, `</label>
          <span
            class="`, "", `"
            onClick=`, `
            onSelectstart=`, `
          >
            `, `
          </span>
          <button
            type="button"
            class="`, `"
            onClick=`, `
          >
            `, `
          </button>
          <input
            id="toastuiImageFileInput"
            type="file"
            accept="image/*"
            onChange=`, `
            ref=`, `
          />
        </div>
        <label for="toastuiAltTextInput">`, `</label>
        <input
          id="toastuiAltTextInput"
          type="text"
          ref=`, `
        />
        <div class="`, `">
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
        </div>
      </div>
    `])), dt.get("Insert image"), ng, this.tabs, a, this.toggleTab, a === "url" ? "block" : "none", dt.get("Image URL"), function(u) {
        return r.refs.url = u;
      }, a === "file" ? "block" : "none", dt.get("Select image file"), Ke("file-name"), i ? " has-file" : o, this.showFileSelectBox, this.preventSelectStart, i ? i.name : dt.get("No file"), Ke("file-select-button"), this.showFileSelectBox, dt.get("Choose a file"), this.changeFile, function(u) {
        return r.refs.file = u;
      }, dt.get("Description"), function(u) {
        return r.refs.altText = u;
      }, Ke("button-container"), Ke("close-button"), this.props.hidePopup, dt.get("Cancel"), Ke("ok-button"), this.execCommand, dt.get("OK"));
    }, e;
  }(Nr)
), lp, q2e = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.execCommand = function() {
        var n = r.refs.url, a = r.refs.text;
        if (gn(n, "wrong"), gn(a, "wrong"), n.value.length < 1) {
          Ln(n, "wrong");
          return;
        }
        var i = kn(r.props.initialValues.linkUrl);
        if (i && a.value.length < 1) {
          Ln(a, "wrong");
          return;
        }
        r.props.execCommand("addLink", {
          linkUrl: n.value,
          linkText: a.value
        });
      }, r;
    }
    return e.prototype.initialize = function() {
      var r = this.props.initialValues, n = r.linkUrl, a = r.linkText, i = this.refs.url, o = this.refs.text;
      gn(i, "wrong"), gn(o, "wrong", "disabled"), o.removeAttribute("disabled"), n && (Ln(o, "disabled"), o.setAttribute("disabled", "disabled")), i.value = n || "", o.value = a || "";
    }, e.prototype.mounted = function() {
      this.initialize();
    }, e.prototype.updated = function(r) {
      !r.show && this.props.show && this.initialize();
    }, e.prototype.render = function() {
      var r = this;
      return xt(up || (up = Et([`
      <div aria-label="`, `">
        <label for="toastuiLinkUrlInput">`, `</label>
        <input
          id="toastuiLinkUrlInput"
          type="text"
          ref=`, `
        />
        <label for="toastuiLinkTextInput">`, `</label>
        <input
          id="toastuiLinkTextInput"
          type="text"
          ref=`, `
        />
        <div class="`, `">
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
        </div>
      </div>
    `], [`
      <div aria-label="`, `">
        <label for="toastuiLinkUrlInput">`, `</label>
        <input
          id="toastuiLinkUrlInput"
          type="text"
          ref=`, `
        />
        <label for="toastuiLinkTextInput">`, `</label>
        <input
          id="toastuiLinkTextInput"
          type="text"
          ref=`, `
        />
        <div class="`, `">
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
        </div>
      </div>
    `])), dt.get("Insert link"), dt.get("URL"), function(n) {
        return r.refs.url = n;
      }, dt.get("Link text"), function(n) {
        return r.refs.text = n;
      }, Ke("button-container"), Ke("close-button"), this.props.hidePopup, dt.get("Cancel"), Ke("ok-button"), this.execCommand, dt.get("OK"));
    }, e;
  }(Nr)
), up, cp = 20, fp = 20, vp = 5, dp = 14, pp = 5, hp = 9, F2e = 1, _2e = 1, mp = 1, H2e = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e(r) {
      var n = t.call(this, r) || this;
      return n.extendSelectionRange = function(a) {
        var i = a.pageX, o = a.pageY, u = i - n.offsetRect.left, m = o - n.offsetRect.top, y = n.getSelectionRangeByOffset(u, m);
        n.setState(ge({}, y));
      }, n.execCommand = function() {
        n.props.execCommand("addTable", {
          rowCount: n.state.rowIdx + 1,
          columnCount: n.state.colIdx + 1
        });
      }, n.state = {
        rowIdx: -1,
        colIdx: -1
      }, n;
    }
    return e.prototype.getDescription = function() {
      return this.state.colIdx === -1 ? "" : this.state.colIdx + 1 + " x " + (this.state.rowIdx + 1);
    }, e.prototype.getBoundByRange = function(r, n) {
      return {
        width: (r + 1) * cp,
        height: (n + 1) * fp
      };
    }, e.prototype.getRangeByOffset = function(r, n) {
      return {
        colIdx: Math.floor(r / cp),
        rowIdx: Math.floor(n / fp)
      };
    }, e.prototype.getTableRange = function() {
      var r = this.state, n = r.colIdx, a = r.rowIdx, i = Math.max(n, pp), o = Math.max(a, vp);
      return n >= pp && i < hp && (i += 1), a >= vp && o < dp && (o += 1), { colIdx: i + 1, rowIdx: o + 1 };
    }, e.prototype.getSelectionAreaBound = function() {
      var r = this.getBoundByRange(this.state.colIdx, this.state.rowIdx), n = r.width, a = r.height;
      return !n && !a ? { display: "none" } : { width: n - mp, height: a - mp, display: "block" };
    }, e.prototype.getSelectionRangeByOffset = function(r, n) {
      var a = this.getRangeByOffset(r, n);
      return a.rowIdx = Math.min(Math.max(a.rowIdx, F2e), dp), a.colIdx = Math.min(Math.max(a.colIdx, _2e), hp), a;
    }, e.prototype.updated = function() {
      if (!this.props.show)
        this.setState({ colIdx: -1, rowIdx: -1 });
      else if (this.state.colIdx === -1 && this.state.rowIdx === -1) {
        var r = this.refs.tableEl.getBoundingClientRect(), n = r.left, a = r.top;
        this.offsetRect = {
          left: window.pageXOffset + n,
          top: window.pageYOffset + a
        };
      }
    }, e.prototype.createTableArea = function(r) {
      for (var n = r.colIdx, a = r.rowIdx, i = [], o = 0; o < a; o += 1) {
        for (var u = [], m = 0; m < n; m += 1) {
          var y = "" + Ke("table-cell") + (o > 0 ? "" : " header");
          u.push(xt(gp || (gp = Et(['<div class="', '"></div>'], ['<div class="', '"></div>'])), y));
        }
        i.push(xt(yp || (yp = Et(['<div class="', '">', "</div>"], ['<div class="', '">', "</div>"])), Ke("table-row"), u));
      }
      return xt(bp || (bp = Et(['<div class="', '">', "</div>"], ['<div class="', '">', "</div>"])), Ke("table"), i);
    }, e.prototype.render = function() {
      var r = this, n = this.getTableRange(), a = this.getSelectionAreaBound();
      return xt(kp || (kp = Et([`
      <div aria-label="`, `">
        <div
          class="`, `"
          ref=`, `
          onMousemove=`, `
          onClick=`, `
        >
          `, `
          <div class="`, '" style=', `></div>
        </div>
        <p class="`, '">', `</p>
      </div>
    `], [`
      <div aria-label="`, `">
        <div
          class="`, `"
          ref=`, `
          onMousemove=`, `
          onClick=`, `
        >
          `, `
          <div class="`, '" style=', `></div>
        </div>
        <p class="`, '">', `</p>
      </div>
    `])), dt.get("Insert table"), Ke("table-selection"), function(i) {
        return r.refs.tableEl = i;
      }, this.extendSelectionRange, this.execCommand, this.createTableArea(n), Ke("table-selection-layer"), a, Ke("table-description"), this.getDescription());
    }, e;
  }(Nr)
), gp, yp, bp, kp, U2e = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.mounted = function() {
      this.refs.el.appendChild(this.props.body);
    }, e.prototype.updated = function(r) {
      this.refs.el.replaceChild(this.props.body, r.body);
    }, e.prototype.render = function() {
      var r = this;
      return xt(wp || (wp = Et(["<div ref=", "></div>"], ["<div ref=", "></div>"])), function(n) {
        return r.refs.el = n;
      });
    }, e;
  }(Nr)
), wp;
function dc(t) {
  return sa(t) ? $2e(t) : t;
}
function z2e() {
  var t = document.createElement("label"), e = document.createElement("input"), r = document.createElement("span");
  t.className = "scroll-sync active", e.type = "checkbox", e.checked = !0, r.className = "switch";
  var n = function(a) {
    return e.addEventListener("change", function(i) {
      var o = i.target.checked;
      o ? Ln(t, "active") : gn(t, "active"), a("toggleScrollSync", { active: o });
    });
  };
  return t.appendChild(e), t.appendChild(r), {
    name: "scrollSync",
    el: t,
    onMounted: n
  };
}
function $2e(t) {
  var e;
  switch (t) {
    case "heading":
      e = {
        name: "heading",
        className: "heading",
        tooltip: dt.get("Headings"),
        state: "heading"
      };
      break;
    case "bold":
      e = {
        name: "bold",
        className: "bold",
        command: "bold",
        tooltip: dt.get("Bold"),
        state: "strong"
      };
      break;
    case "italic":
      e = {
        name: "italic",
        className: "italic",
        command: "italic",
        tooltip: dt.get("Italic"),
        state: "emph"
      };
      break;
    case "strike":
      e = {
        name: "strike",
        className: "strike",
        command: "strike",
        tooltip: dt.get("Strike"),
        state: "strike"
      };
      break;
    case "hr":
      e = {
        name: "hr",
        className: "hrline",
        command: "hr",
        tooltip: dt.get("Line"),
        state: "thematicBreak"
      };
      break;
    case "quote":
      e = {
        name: "quote",
        className: "quote",
        command: "blockQuote",
        tooltip: dt.get("Blockquote"),
        state: "blockQuote"
      };
      break;
    case "ul":
      e = {
        name: "ul",
        className: "bullet-list",
        command: "bulletList",
        tooltip: dt.get("Unordered list"),
        state: "bulletList"
      };
      break;
    case "ol":
      e = {
        name: "ol",
        className: "ordered-list",
        command: "orderedList",
        tooltip: dt.get("Ordered list"),
        state: "orderedList"
      };
      break;
    case "task":
      e = {
        name: "task",
        className: "task-list",
        command: "taskList",
        tooltip: dt.get("Task"),
        state: "taskList"
      };
      break;
    case "table":
      e = {
        name: "table",
        className: "table",
        tooltip: dt.get("Insert table"),
        state: "table"
      };
      break;
    case "image":
      e = {
        name: "image",
        className: "image",
        tooltip: dt.get("Insert image")
      };
      break;
    case "link":
      e = {
        name: "link",
        className: "link",
        tooltip: dt.get("Insert link")
      };
      break;
    case "code":
      e = {
        name: "code",
        className: "code",
        command: "code",
        tooltip: dt.get("Code"),
        state: "code"
      };
      break;
    case "codeblock":
      e = {
        name: "codeblock",
        className: "codeblock",
        command: "codeBlock",
        tooltip: dt.get("Insert CodeBlock"),
        state: "codeBlock"
      };
      break;
    case "indent":
      e = {
        name: "indent",
        className: "indent",
        command: "indent",
        tooltip: dt.get("Indent"),
        state: "indent"
      };
      break;
    case "outdent":
      e = {
        name: "outdent",
        className: "outdent",
        command: "outdent",
        tooltip: dt.get("Outdent"),
        state: "outdent"
      };
      break;
    case "scrollSync":
      e = z2e();
      break;
    case "more":
      e = {
        name: "more",
        className: "more",
        tooltip: dt.get("More")
      };
      break;
  }
  return e.name !== "scrollSync" && (e.className += " " + Ke("toolbar-icons")), e;
}
function Kc(t, e) {
  var r = e.el, n = e.pos, a = e.popup, i = e.initialValues;
  switch (t) {
    case "heading":
      return {
        render: function(o) {
          return xt(Cp || (Cp = Et(["<", " ...", " />"], ["<", " ...", " />"])), I2e, o);
        },
        className: Ke("popup-add-heading"),
        fromEl: r,
        pos: n
      };
    case "link":
      return {
        render: function(o) {
          return xt(Tp || (Tp = Et(["<", " ...", " />"], ["<", " ...", " />"])), q2e, o);
        },
        className: Ke("popup-add-link"),
        fromEl: r,
        pos: n,
        initialValues: i
      };
    case "image":
      return {
        render: function(o) {
          return xt(Sp || (Sp = Et(["<", " ...", " />"], ["<", " ...", " />"])), B2e, o);
        },
        className: Ke("popup-add-image"),
        fromEl: r,
        pos: n
      };
    case "table":
      return {
        render: function(o) {
          return xt(Ep || (Ep = Et(["<", " ...", " />"], ["<", " ...", " />"])), H2e, o);
        },
        className: Ke("popup-add-table"),
        fromEl: r,
        pos: n
      };
    case "customPopupBody":
      return a ? ge({ render: function(o) {
        return xt(xp || (xp = Et(["<", " ...", " body=", " />"], ["<", " ...", " body=", " />"])), U2e, o, a.body);
      }, fromEl: r, pos: n }, a) : null;
    default:
      return null;
  }
}
function Ns(t) {
  t.hidden = t.length === t.filter(function(e) {
    return e.hidden;
  }).length;
}
function V2e(t, e) {
  var r = function(n) {
    return n.hidden = n.name === "scrollSync" && e, n;
  };
  return t.reduce(function(n, a) {
    n.push(a.map(function(o) {
      return r(dc(o));
    }));
    var i = n[(n.length || 1) - 1];
    return i && Ns(i), n;
  }, []);
}
function W2e(t, e) {
  t.forEach(function(r) {
    r.forEach(function(n) {
      return n.hidden = n.name === "scrollSync" && e;
    }), Ns(r);
  });
}
var Cp, Tp, Sp, Ep, xp, j2e = 20, G2e = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.handleMousedown = function(n) {
        !On(n.target, "." + Ke("popup")) && !On(n.target, r.props.info.fromEl) && r.props.hidePopup();
      }, r;
    }
    return e.prototype.mounted = function() {
      document.addEventListener("mousedown", this.handleMousedown), this.props.eventEmitter.listen("closePopup", this.props.hidePopup);
    }, e.prototype.beforeDestroy = function() {
      document.removeEventListener("mousedown", this.handleMousedown);
    }, e.prototype.updated = function(r) {
      var n = this.props, a = n.show, i = n.info;
      if (a && i.pos && r.show !== a) {
        var o = ge({}, i.pos), u = this.refs.el.offsetWidth, m = On(this.refs.el, "." + Ke("toolbar")), y = m.offsetWidth;
        o.left + u >= y && (o.left = y - u - j2e), wc(this.state.popupPos, o) || this.setState({ popupPos: o });
      }
    }, e.prototype.render = function() {
      var r = this, n = this.props, a = n.info, i = n.show, o = n.hidePopup, u = n.eventEmitter, m = n.execCommand, y = a || {}, C = y.className, T = C === void 0 ? "" : C, x = y.style, M = y.render, P = y.initialValues, q = P === void 0 ? {} : P, _ = ge(ge({ display: i ? "block" : "none" }, x), this.state.popupPos);
      return xt(Ap || (Ap = Et([`
      <div
        class="`, " ", `"
        style=`, `
        ref=`, `
        aria-role="dialog"
      >
        <div class="`, `">
          `, `
        </div>
      </div>
    `], [`
      <div
        class="`, " ", `"
        style=`, `
        ref=`, `
        aria-role="dialog"
      >
        <div class="`, `">
          `, `
        </div>
      </div>
    `])), Ke("popup"), T, _, function(K) {
        return r.refs.el = K;
      }, Ke("popup-body"), M && M({ eventEmitter: u, show: i, hidePopup: o, execCommand: m, initialValues: q }));
    }, e;
  }(Nr)
), Ap, Mp = 6;
function Jc(t) {
  return (
    /** @class */
    function(e) {
      Ve(r, e);
      function r(n) {
        var a = e.call(this, n) || this;
        return a.showTooltip = function(i) {
          var o = a.props.item.tooltip;
          if (!a.props.disabled && o) {
            var u = a.getBound(i), m = u.left + Mp + "px", y = u.top + Mp + "px";
            Dn(a.props.tooltipRef.current, { display: "block", left: m, top: y }), a.props.tooltipRef.current.querySelector(".text").textContent = o;
          }
        }, a.hideTooltip = function() {
          Dn(a.props.tooltipRef.current, "display", "none");
        }, a.state = { active: !1, disabled: n.disabled }, a.addEvent(), a;
      }
      return r.prototype.addEvent = function() {
        var n = this, a = this.props, i = a.item, o = a.eventEmitter;
        i.state && o.listen("changeToolbarState", function(u) {
          var m, y = u.toolbarState, C = (m = y[i.state]) !== null && m !== void 0 ? m : {}, T = C.active, x = C.disabled;
          n.setState({ active: !!T, disabled: x ?? n.props.disabled });
        });
      }, r.prototype.getBound = function(n) {
        var a = Th(n, On(n, "." + Ke("toolbar"))), i = a.offsetLeft, o = a.offsetTop;
        return { left: i, top: n.offsetHeight + o };
      }, r.prototype.render = function() {
        return xt(Lp || (Lp = Et([`
        <`, `
          ...`, `
          active=`, `
          showTooltip=`, `
          hideTooltip=`, `
          getBound=`, `
          disabled=`, `
        />
      `], [`
        <`, `
          ...`, `
          active=`, `
          showTooltip=`, `
          hideTooltip=`, `
          getBound=`, `
          disabled=`, `
        />
      `])), t, this.props, this.state.active, this.showTooltip, this.hideTooltip, this.getBound, this.state.disabled || this.props.disabled);
      }, r;
    }(Nr)
  );
}
var Lp, K2e = 80, J2e = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.showTooltip = function() {
        r.props.showTooltip(r.refs.el);
      }, r.execCommand = function() {
        var n = r.props, a = n.item, i = n.execCommand, o = n.setPopupInfo, u = n.getBound, m = n.eventEmitter, y = a.command, C = a.name, T = a.popup;
        if (y)
          i(y);
        else {
          var x = T ? "customPopupBody" : C, M = m.emit("query", "getPopupInitialValues", { popupName: x })[0], P = Kc(x, {
            el: r.refs.el,
            pos: u(r.refs.el),
            popup: T,
            initialValues: M
          });
          P && o(P);
        }
      }, r;
    }
    return e.prototype.mounted = function() {
      this.setItemWidth();
    }, e.prototype.updated = function(r) {
      r.item.name !== this.props.item.name && this.setItemWidth();
    }, e.prototype.setItemWidth = function() {
      var r = this.props, n = r.setItemWidth, a = r.item;
      n && n(a.name, Oc(this.refs.el) + (a.hidden ? K2e : 0));
    }, e.prototype.render = function() {
      var r = this, n = this.props, a = n.hideTooltip, i = n.disabled, o = n.item, u = n.active, m = ge({ display: o.hidden ? "none" : null }, o.style), y = "" + (o.className || "") + (u ? " active" : "");
      return xt(Op || (Op = Et([`
      <button
        ref=`, `
        type="button"
        style=`, `
        class=`, `
        onClick=`, `
        onMouseover=`, `
        onMouseout=`, `
        disabled=`, `
        aria-label=`, `
      >
        `, `
      </button>
    `], [`
      <button
        ref=`, `
        type="button"
        style=`, `
        class=`, `
        onClick=`, `
        onMouseover=`, `
        onMouseout=`, `
        disabled=`, `
        aria-label=`, `
      >
        `, `
      </button>
    `])), function(C) {
        return r.refs.el = C;
      }, m, y, this.execCommand, this.showTooltip, a, !!i, o.text || o.tooltip || "", o.text || "");
    }, e;
  }(Nr)
), Y2e = Jc(J2e), Op, Z2e = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.showTooltip = function() {
        r.props.showTooltip(r.refs.el);
      }, r.showPopup = function() {
        var n = Kc("customPopupBody", {
          el: r.refs.el,
          pos: r.props.getBound(r.refs.el),
          popup: r.props.item.popup
        });
        n && r.props.setPopupInfo(n);
      }, r;
    }
    return e.prototype.mounted = function() {
      var r = this.props, n = r.setItemWidth, a = r.item;
      this.refs.el.appendChild(a.el), n && n(a.name, Oc(this.refs.el)), a.onMounted && a.onMounted(this.props.execCommand);
    }, e.prototype.updated = function(r) {
      var n, a = this.props, i = a.item, o = a.active, u = a.disabled;
      (r.active !== o || r.disabled !== u) && ((n = i.onUpdated) === null || n === void 0 || n.call(i, { active: o, disabled: u }));
    }, e.prototype.render = function() {
      var r = this, n = this.props, a = n.disabled, i = n.item, o = { display: i.hidden ? "none" : "inline-block" }, u = function(m) {
        return a ? null : m;
      };
      return xt(Dp || (Dp = Et([`
      <div
        ref=`, `
        style=`, `
        class=`, `
        onClick=`, `
        onMouseover=`, `
        onMouseout=`, `
      ></div>
    `], [`
      <div
        ref=`, `
        style=`, `
        class=`, `
        onClick=`, `
        onMouseover=`, `
        onMouseout=`, `
      ></div>
    `])), function(m) {
        return r.refs.el = m;
      }, o, Ke("toolbar-item-wrapper"), u(this.showPopup), u(this.showTooltip), u(this.props.hideTooltip));
    }, e;
  }(Nr)
), Q2e = Jc(Z2e), Dp, ag = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.render = function() {
      var r = this, n = this.props, a = n.group, i = n.hiddenDivider, o = a.hidden ? { display: "none" } : null, u = i ? { display: "none" } : null;
      return xt(Rp || (Rp = Et([`
      <div class="`, '" style=', `>
        `, `
        <div class="`, '" style=', `></div>
      </div>
    `], [
        `
      <div class="`,
        '" style=',
        `>
        `,
        `
        <div class="`,
        '" style=',
        `></div>
      </div>
    `
      ])), Ke("toolbar-group"), o, a.map(function(m) {
        var y = m.el ? Q2e : Y2e;
        return xt(Np || (Np = Et(["<", " key=", " ...", " item=", " />"], ["<", " key=", " ...", " item=", " />"])), y, m.name, r.props, m);
      }), Ke("toolbar-divider"), u);
    }, e;
  }(Nr)
), Np, Rp, X2e = 4, eVe = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e(r) {
      var n = t.call(this, r) || this;
      return n.handleClickDocument = function(a) {
        var i = a.target;
        !On(i, "." + Ke("dropdown-toolbar")) && !On(i, ".more") && n.setState({ showDropdown: !1, dropdownPos: null });
      }, n.showTooltip = function() {
        n.props.showTooltip(n.refs.el);
      }, n.state = { showDropdown: !1, dropdownPos: null }, n;
    }
    return e.prototype.getBound = function() {
      var r = this.props.getBound(this.refs.el);
      return r.top += X2e, ge(ge({}, r), { left: null, right: 10 });
    }, e.prototype.mounted = function() {
      document.addEventListener("click", this.handleClickDocument);
    }, e.prototype.updated = function() {
      this.state.showDropdown && !this.state.dropdownPos && this.setState({ dropdownPos: this.getBound() });
    }, e.prototype.beforeDestroy = function() {
      document.removeEventListener("click", this.handleClickDocument);
    }, e.prototype.render = function() {
      var r = this, n = this.state, a = n.showDropdown, i = n.dropdownPos, o = this.props, u = o.disabled, m = o.item, y = o.items, C = o.hideTooltip, T = y.filter(function(P) {
        return !P.hidden;
      }), x = T.length ? null : { display: "none" }, M = a ? null : { display: "none" };
      return xt(Pp || (Pp = Et([`
      <div class="`, '" style=', `>
        <button
          ref=`, `
          type="button"
          class=`, `
          onClick=`, `
          onMouseover=`, `
          onMouseout=`, `
          disabled=`, `
        ></button>
        <div
          class="`, `"
          style=`, `
          ref=`, `
        >
          `, `
        </div>
      </div>
    `], [
        `
      <div class="`,
        '" style=',
        `>
        <button
          ref=`,
        `
          type="button"
          class=`,
        `
          onClick=`,
        `
          onMouseover=`,
        `
          onMouseout=`,
        `
          disabled=`,
        `
        ></button>
        <div
          class="`,
        `"
          style=`,
        `
          ref=`,
        `
        >
          `,
        `
        </div>
      </div>
    `
      ])), Ke("toolbar-group"), x, function(P) {
        return r.refs.el = P;
      }, m.className, function() {
        return r.setState({ showDropdown: !0 });
      }, this.showTooltip, C, u, Ke("dropdown-toolbar"), ge(ge({}, M), i), function(P) {
        return r.refs.dropdownEl = P;
      }, T.length ? T.map(function(P, q) {
        var _;
        return xt(Ip || (Ip = Et([`
                  <`, `
                    group=`, `
                    hiddenDivider=`, `
                    ...`, `
                  />
                `], [
          `
                  <`,
          `
                    group=`,
          `
                    hiddenDivider=`,
          `
                    ...`,
          `
                  />
                `
        ])), ag, P, q === T.length - 1 || ((_ = T[q + 1]) === null || _ === void 0 ? void 0 : _.hidden), r.props);
      }) : null);
    }, e;
  }(Nr)
), tVe = Jc(eVe), Ip, Pp, rVe = 50, nVe = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e(r) {
      var n = t.call(this, r) || this;
      return n.toggleTab = function(a, i) {
        var o = n.props.eventEmitter;
        if (n.state.activeTab !== i) {
          var u = i === "write" ? "changePreviewTabWrite" : "changePreviewTabPreview";
          o.emit(u), n.setState({ activeTab: i });
        }
      }, n.setItemWidth = function(a, i) {
        n.itemWidthMap[a] = i;
      }, n.setPopupInfo = function(a) {
        n.setState({ showPopup: !0, popupInfo: a });
      }, n.openPopup = function(a, i) {
        i === void 0 && (i = {});
        var o = n.refs.el.querySelector("." + Ke("toolbar-group") + " ." + a);
        if (o) {
          var u = Th(o, On(o, "." + Ke("toolbar"))), m = u.offsetLeft, y = u.offsetTop, C = Kc(a, {
            el: o,
            pos: { left: m, top: o.offsetHeight + y },
            initialValues: i
          });
          C && n.setPopupInfo(C);
        }
      }, n.hidePopup = function() {
        n.state.showPopup && n.setState({ showPopup: !1 });
      }, n.execCommand = function(a, i) {
        var o = n.props.eventEmitter;
        o.emit("command", a, i), n.hidePopup();
      }, n.tabs = [
        { name: "write", text: "Write" },
        { name: "preview", text: "Preview" }
      ], n.itemWidthMap = {}, n.initialItems = V2e(r.toolbarItems || [], n.hiddenScrollSync()), n.state = {
        items: n.initialItems,
        dropdownItems: [],
        showPopup: !1,
        popupInfo: {},
        activeTab: "write"
      }, n.tooltipRef = { current: null }, n.resizeObserver = new R2e(function() {
        return n.handleResize();
      }), n.addEvent(), n;
    }
    return e.prototype.insertToolbarItem = function(r, n) {
      var a = r.groupIndex, i = r.itemIndex, o = this.initialItems[a];
      n = dc(n), o ? o.splice(i, 0, n) : this.initialItems.push([n]), this.setState(this.classifyToolbarItems());
    }, e.prototype.removeToolbarItem = function(r) {
      var n = this;
      Ti(this.initialItems, function(a) {
        var i = !1;
        return Ti(a, function(o, u) {
          return o.name === r ? (i = !0, a.splice(u, 1), n.setState(n.classifyToolbarItems()), !1) : !0;
        }), !i;
      });
    }, e.prototype.addEvent = function() {
      var r = this, n = this.props.eventEmitter;
      this.handleResize = h2e(function() {
        r.setState({ items: r.initialItems, dropdownItems: [] }), r.setState(r.classifyToolbarItems());
      }, 200), n.listen("openPopup", this.openPopup);
    }, e.prototype.appendTooltipToRoot = function() {
      var r = '<div class="' + Ke("tooltip") + `" style="display:none">
        <div class="arrow"></div>
        <span class="text"></span>
      </div>`;
      this.tooltipRef.current = Ch(r, this.refs.el);
    }, e.prototype.hiddenScrollSync = function() {
      return this.props.editorType === "wysiwyg" || this.props.previewStyle === "tab";
    }, e.prototype.movePrevItemToDropdownToolbar = function(r, n, a, i) {
      var o = function(m) {
        var y = m.pop();
        y && i.push(y);
      };
      if (r > 1)
        o(a);
      else {
        var u = Dr(n);
        u && o(u);
      }
    }, e.prototype.classifyToolbarItems = function() {
      var r = this, n = 0, a = this.refs.el.clientWidth, i = this.refs.el.querySelector("." + Ke("toolbar-divider")), o = i ? Oc(i) : 0, u = [], m = [], y = !1;
      return this.initialItems.forEach(function(C, T) {
        var x = [], M = [];
        C.forEach(function(P, q) {
          P.hidden || (n += r.itemWidthMap[P.name], n > a - rVe ? (y || (r.movePrevItemToDropdownToolbar(q, u, x, M), y = !0), M.push(P)) : x.push(P));
        }), x.length && (Ns(x), u.push(x)), M.length && (Ns(M), m.push(M)), T < r.state.items.length - 1 && (n += o);
      }), { items: u, dropdownItems: m };
    }, e.prototype.mounted = function() {
      this.props.previewStyle === "tab" && this.props.eventEmitter.emit("changePreviewTabWrite", !0), this.setState(this.classifyToolbarItems()), this.appendTooltipToRoot(), this.resizeObserver.observe(this.refs.el);
    }, e.prototype.updated = function(r) {
      var n = this.props, a = n.editorType, i = n.previewStyle, o = n.eventEmitter, u = i !== r.previewStyle, m = a !== r.editorType;
      if (u || m) {
        W2e(this.initialItems, this.hiddenScrollSync());
        var y = this.classifyToolbarItems();
        (u || i === "tab" && a === "markdown") && (o.emit("changePreviewTabWrite"), y.activeTab = "write"), this.setState(y);
      }
    }, e.prototype.beforeDestroy = function() {
      window.removeEventListener("resize", this.handleResize), this.resizeObserver.disconnect(), Qa(this.tooltipRef.current);
    }, e.prototype.render = function() {
      var r = this, n = this.props, a = n.previewStyle, i = n.eventEmitter, o = n.editorType, u = this.state, m = u.popupInfo, y = u.showPopup, C = u.activeTab, T = u.items, x = u.dropdownItems, M = {
        eventEmitter: i,
        tooltipRef: this.tooltipRef,
        disabled: o === "markdown" && a === "tab" && C === "preview",
        execCommand: this.execCommand,
        setPopupInfo: this.setPopupInfo
      }, P = a === "tab" ? { borderTopLeftRadius: 0 } : null;
      return xt(qp || (qp = Et([`
      <div class="`, `">
        <div
          class="`, `"
          style="display: `, `"
        >
          <`, " tabs=", " activeTab=", " onClick=", ` />
        </div>
        <div
          class="`, `"
          ref=`, `
          style=`, `
        >
          `, `
          <`, `
            item=`, `
            items=`, `
            ...`, `
          />
        </div>
        <`, `
          info=`, `
          show=`, `
          eventEmitter=`, `
          hidePopup=`, `
          execCommand=`, `
        />
      </div>
    `], [
        `
      <div class="`,
        `">
        <div
          class="`,
        `"
          style="display: `,
        `"
        >
          <`,
        " tabs=",
        " activeTab=",
        " onClick=",
        ` />
        </div>
        <div
          class="`,
        `"
          ref=`,
        `
          style=`,
        `
        >
          `,
        `
          <`,
        `
            item=`,
        `
            items=`,
        `
            ...`,
        `
          />
        </div>
        <`,
        `
          info=`,
        `
          show=`,
        `
          eventEmitter=`,
        `
          hidePopup=`,
        `
          execCommand=`,
        `
        />
      </div>
    `
      ])), Ke("toolbar"), Ke("md-tab-container"), o === "wysiwyg" || a === "vertical" ? "none" : "block", ng, this.tabs, C, this.toggleTab, Ke("defaultUI-toolbar"), function(q) {
        return r.refs.el = q;
      }, P, T.map(function(q, _) {
        var K;
        return xt(Bp || (Bp = Et([`
              <`, `
                group=`, `
                hiddenDivider=`, `
                setItemWidth=`, `
                ...`, `
              />
            `], [`
              <`, `
                group=`, `
                hiddenDivider=`, `
                setItemWidth=`, `
                ...`, `
              />
            `])), ag, q, _ === T.length - 1 || ((K = T[_ + 1]) === null || K === void 0 ? void 0 : K.hidden), r.setItemWidth, M);
      }), tVe, dc("more"), x, M, G2e, m, y, i, this.hidePopup, this.execCommand);
    }, e;
  }(Nr)
), Bp, qp, aVe = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e(r) {
      var n = t.call(this, r) || this;
      return n.handleClickDocument = function(a) {
        On(a.target, "." + Ke("context-menu")) || n.setState({ pos: null });
      }, n.state = {
        pos: null,
        menuGroups: []
      }, n.addEvent(), n;
    }
    return e.prototype.addEvent = function() {
      var r = this;
      this.props.eventEmitter.listen("contextmenu", function(n) {
        var a = n.pos, i = n.menuGroups;
        r.setState({ pos: a, menuGroups: i });
      });
    }, e.prototype.mounted = function() {
      document.addEventListener("click", this.handleClickDocument);
    }, e.prototype.beforeDestroy = function() {
      document.removeEventListener("click", this.handleClickDocument);
    }, e.prototype.getMenuGroupElements = function() {
      var r = this, n = this.state, a = n.pos, i = n.menuGroups;
      return a ? i.reduce(function(o, u) {
        var m = [];
        return u.forEach(function(y) {
          var C = y.label, T = y.className, x = T === void 0 ? !1 : T, M = y.disabled, P = y.onClick, q = function() {
            M || (P(), r.setState({ pos: null }));
          };
          m.push(xt(Fp || (Fp = Et([`
                <li
                  onClick=`, `
                  class="menu-item`, `"
                  aria-role="menuitem"
                >
                  <span class="`, '">', `</span>
                </li>
              `], [`
                <li
                  onClick=`, `
                  class="menu-item`, `"
                  aria-role="menuitem"
                >
                  <span class="`, '">', `</span>
                </li>
              `])), q, M ? " disabled" : "", x, C));
        }), o.push(xt(_p || (_p = Et([`<ul class="menu-group">
              `, `
            </ul>`], [`<ul class="menu-group">
              `, `
            </ul>`])), m)), o;
      }, []) : [];
    }, e.prototype.render = function() {
      var r = ge({ display: this.state.pos ? "block" : "none" }, this.state.pos);
      return xt(Hp || (Hp = Et(['<div class="', '" style=', ` aria-role="menu">
      `, `
    </div>`], ['<div class="', '" style=', ` aria-role="menu">
      `, `
    </div>`])), Ke("context-menu"), r, this.getMenuGroupElements());
    }, e;
  }(Nr)
), Fp, _p, Hp, iVe = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e(r) {
      var n = t.call(this, r) || this;
      n.changeMode = function(o) {
        o !== n.state.editorType && n.setState({ editorType: o });
      }, n.changePreviewStyle = function(o) {
        o !== n.state.previewStyle && n.setState({ previewStyle: o });
      }, n.hide = function() {
        n.setState({ hide: !0 });
      }, n.show = function() {
        n.setState({ hide: !1 });
      };
      var a = r.editorType, i = r.previewStyle;
      return n.state = {
        editorType: a,
        previewStyle: i,
        hide: !1
      }, n.addEvent(), n;
    }
    return e.prototype.mounted = function() {
      var r = this.props.slots, n = r.wwEditor, a = r.mdEditor, i = r.mdPreview;
      this.refs.wwContainer.appendChild(n), this.refs.mdContainer.insertAdjacentElement("afterbegin", a), this.refs.mdContainer.appendChild(i);
    }, e.prototype.insertToolbarItem = function(r, n) {
      this.toolbar.insertToolbarItem(r, n);
    }, e.prototype.removeToolbarItem = function(r) {
      this.toolbar.removeToolbarItem(r);
    }, e.prototype.render = function() {
      var r = this, n = this.props, a = n.eventEmitter, i = n.hideModeSwitch, o = n.toolbarItems, u = n.theme, m = this.state, y = m.hide, C = m.previewStyle, T = m.editorType, x = y ? " hidden" : "", M = Ke(T === "markdown" ? "md-mode" : "ww-mode"), P = Ke("md") + "-" + C + "-style", q = Ke([u !== "light", u + " "]);
      return xt(zp || (zp = Et([`
      <div
        class="`, "", "", `"
        ref=`, `
      >
        <`, `
          ref=`, `
          eventEmitter=`, `
          previewStyle=`, `
          toolbarItems=`, `
          editorType=`, `
        />
        <div
          class="`, " ", `"
          ref=`, `
        >
          <div class="`, `">
            <div
              class="`, " ", `"
              ref=`, `
            >
              <div class="`, `"></div>
            </div>
            <div
              class="`, `"
              ref=`, `
            />
          </div>
        </div>
        `, `
        <`, " eventEmitter=", ` />
      </div>
    `], [
        `
      <div
        class="`,
        "",
        "",
        `"
        ref=`,
        `
      >
        <`,
        `
          ref=`,
        `
          eventEmitter=`,
        `
          previewStyle=`,
        `
          toolbarItems=`,
        `
          editorType=`,
        `
        />
        <div
          class="`,
        " ",
        `"
          ref=`,
        `
        >
          <div class="`,
        `">
            <div
              class="`,
        " ",
        `"
              ref=`,
        `
            >
              <div class="`,
        `"></div>
            </div>
            <div
              class="`,
        `"
              ref=`,
        `
            />
          </div>
        </div>
        `,
        `
        <`,
        " eventEmitter=",
        ` />
      </div>
    `
      ])), q, Ke("defaultUI"), x, function(_) {
        return r.refs.el = _;
      }, nVe, function(_) {
        return r.toolbar = _;
      }, a, C, o, T, Ke("main"), M, function(_) {
        return r.refs.editorSection = _;
      }, Ke("main-container"), Ke("md-container"), P, function(_) {
        return r.refs.mdContainer = _;
      }, Ke("md-splitter"), Ke("ww-container"), function(_) {
        return r.refs.wwContainer = _;
      }, !i && xt(Up || (Up = Et(["<", " eventEmitter=", " editorType=", " />"], ["<", " eventEmitter=", " editorType=", " />"])), c2e, a, T), aVe, a);
    }, e.prototype.addEvent = function() {
      var r = this.props.eventEmitter;
      r.listen("hide", this.hide), r.listen("show", this.show), r.listen("changeMode", this.changeMode), r.listen("changePreviewStyle", this.changePreviewStyle);
    }, e;
  }(Nr)
), Up, zp, sr = (
  /** @class */
  function(t) {
    Ve(e, t);
    function e(r) {
      var n, a = t.call(this, r) || this, i, o = u2e(a.options.el, xt($p || ($p = Et([`
        <`, `
          ref=`, `
          eventEmitter=`, `
          slots=`, `
          hideModeSwitch=`, `
          toolbarItems=`, `
          previewStyle=`, `
          editorType=`, `
          theme=`, `
        />
      `], [`
        <`, `
          ref=`, `
          eventEmitter=`, `
          slots=`, `
          hideModeSwitch=`, `
          toolbarItems=`, `
          previewStyle=`, `
          editorType=`, `
          theme=`, `
        />
      `])), iVe, function(u) {
        return i = u;
      }, a.eventEmitter, a.getEditorElements(), a.options.hideModeSwitch, a.options.toolbarItems, a.options.previewStyle, a.options.initialEditType, a.options.theme));
      return a.setMinHeight(a.options.minHeight), a.setHeight(a.options.height), a.defaultUI = {
        insertToolbarItem: i.insertToolbarItem.bind(i),
        removeToolbarItem: i.removeToolbarItem.bind(i),
        destroy: o
      }, (n = a.pluginInfo.toolbarItems) === null || n === void 0 || n.forEach(function(u) {
        var m = u.groupIndex, y = u.itemIndex, C = u.item;
        a.defaultUI.insertToolbarItem({ groupIndex: m, itemIndex: y }, C);
      }), a.eventEmitter.emit("loadUI", a), a;
    }
    return e.factory = function(r) {
      return r.viewer ? new jm(r) : new e(r);
    }, e.prototype.insertToolbarItem = function(r, n) {
      this.defaultUI.insertToolbarItem(r, n);
    }, e.prototype.removeToolbarItem = function(r) {
      this.defaultUI.removeToolbarItem(r);
    }, e.prototype.destroy = function() {
      t.prototype.destroy.call(this), this.defaultUI.destroy();
    }, e;
  }(Km)
), $p;
Km.setLanguage(["en", "en-US"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Write",
  Preview: "Preview",
  Headings: "Headings",
  Paragraph: "Paragraph",
  Bold: "Bold",
  Italic: "Italic",
  Strike: "Strike",
  Code: "Inline code",
  Line: "Line",
  Blockquote: "Blockquote",
  "Unordered list": "Unordered list",
  "Ordered list": "Ordered list",
  Task: "Task",
  Indent: "Indent",
  Outdent: "Outdent",
  "Insert link": "Insert link",
  "Insert CodeBlock": "Insert codeBlock",
  "Insert table": "Insert table",
  "Insert image": "Insert image",
  Heading: "Heading",
  "Image URL": "Image URL",
  "Select image file": "Select image file",
  "Choose a file": "Choose a file",
  "No file": "No file",
  Description: "Description",
  OK: "OK",
  More: "More",
  Cancel: "Cancel",
  File: "File",
  URL: "URL",
  "Link text": "Link text",
  "Add row to up": "Add row to up",
  "Add row to down": "Add row to down",
  "Add column to left": "Add column to left",
  "Add column to right": "Add column to right",
  "Remove row": "Remove row",
  "Remove column": "Remove column",
  "Align column to left": "Align column to left",
  "Align column to center": "Align column to center",
  "Align column to right": "Align column to right",
  "Remove table": "Remove table",
  "Would you like to paste as table?": "Would you like to paste as table?",
  "Text color": "Text color",
  "Auto scroll enabled": "Auto scroll enabled",
  "Auto scroll disabled": "Auto scroll disabled",
  "Choose language": "Choose language"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
sr.setLanguage("ar", {
  Markdown: "لغة ترميز",
  WYSIWYG: "ما تراه هو ما تحصل عليه",
  Write: "يكتب",
  Preview: "عرض مسبق",
  Headings: "العناوين",
  Paragraph: "فقرة",
  Bold: "خط عريض",
  Italic: "خط مائل",
  Strike: "إضراب",
  Code: "رمز",
  Line: "خط",
  Blockquote: "فقرة مقتبسة",
  "Unordered list": "قائمة غير مرتبة",
  "Ordered list": "قائمة مرتبة",
  Task: "مهمة",
  Indent: "المسافة البادئة",
  Outdent: "المسافة الخارجة",
  "Insert link": "أدخل الرابط",
  "Insert CodeBlock": "أدخل الكود",
  "Insert table": "أدخل جدول",
  "Insert image": "أدخل صورة",
  Heading: "عنوان",
  "Image URL": "رابط الصورة",
  "Select image file": "حدد ملف الصورة",
  "Choose a file": "اختيار الملف",
  "No file": "لا ملف",
  Description: "وصف",
  OK: "موافقة",
  More: "أكثر",
  Cancel: "إلغاء",
  File: "ملف",
  URL: "رابط",
  "Link text": "نص الرابط",
  "Add row to up": "أضف صفًا لأعلى",
  "Add row to down": "أضف صفًا إلى أسفل",
  "Add column to left": "أضف العمود على اليسار",
  "Add column to right": "أضف عمودًا إلى اليمين",
  "Remove row": "حذف سطر",
  "Remove column": "حذف عمود",
  "Align column to left": "محاذاة اليسار",
  "Align column to center": "محاذاة الوسط",
  "Align column to right": "محاذاة اليمين",
  "Remove table": "حذف الجدول",
  "Would you like to paste as table?": "هل تريد اللصق كجدول",
  "Text color": "لون النص",
  "Auto scroll enabled": "التحريك التلقائي ممكّن",
  "Auto scroll disabled": "التحريك التلقائي معطّل",
  "Choose language": "اختر اللغة"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
sr.setLanguage(["cs", "cs-CZ"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Napsat",
  Preview: "Náhled",
  Headings: "Nadpisy",
  Paragraph: "Odstavec",
  Bold: "Tučné",
  Italic: "Kurzíva",
  Strike: "Přeškrtnuté",
  Code: "Kód",
  Line: "Vodorovná čára",
  Blockquote: "Citace",
  "Unordered list": "Seznam s odrážkami",
  "Ordered list": "Číslovaný seznam",
  Task: "Úkol",
  Indent: "Zvětšit odsazení",
  Outdent: "Zmenšit odsazení",
  "Insert link": "Vložit odkaz",
  "Insert CodeBlock": "Vložit blok kódu",
  "Insert table": "Vložit tabulku",
  "Insert image": "Vložit obrázek",
  Heading: "Nadpis",
  "Image URL": "URL obrázku",
  "Select image file": "Vybrat obrázek",
  "Choose a file": "Vyberte soubor",
  "No file": "Žádný soubor",
  Description: "Popis",
  OK: "OK",
  More: "Více",
  Cancel: "Zrušit",
  File: "Soubor",
  URL: "URL",
  "Link text": "Text odkazu",
  "Add row to up": "Přidejte řádek nahoru",
  "Add row to down": "Přidejte řádek dolů",
  "Add column to left": "Přidat sloupec vlevo",
  "Add column to right": "Přidat sloupec doprava",
  "Remove row": "Odebrat řádek",
  "Remove column": "Odebrat sloupec",
  "Align column to left": "Zarovnat vlevo",
  "Align column to center": "Zarovnat na střed",
  "Align column to right": "Zarovnat vpravo",
  "Remove table": "Odstranit tabulku",
  "Would you like to paste as table?": "Chcete vložit jako tabulku?",
  "Text color": "Barva textu",
  "Auto scroll enabled": "Automatické rolování zapnuto",
  "Auto scroll disabled": "Automatické rolování vypnuto",
  "Choose language": "Vybrat jazyk"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
sr.setLanguage(["de", "de-DE"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Verfassen",
  Preview: "Vorschau",
  Headings: "Überschriften",
  Paragraph: "Text",
  Bold: "Fett",
  Italic: "Kursiv",
  Strike: "Durchgestrichen",
  Code: "Code",
  Line: "Trennlinie",
  Blockquote: "Blocktext",
  "Unordered list": "Aufzählung",
  "Ordered list": "Nummerierte Aufzählung",
  Task: "Aufgabe",
  Indent: "Einrücken",
  Outdent: "Ausrücken",
  "Insert link": "Link einfügen",
  "Insert CodeBlock": "Codeblock einfügen",
  "Insert table": "Tabelle einfügen",
  "Insert image": "Grafik einfügen",
  Heading: "Titel",
  "Image URL": "Bild URL",
  "Select image file": "Grafik auswählen",
  "Choose a file": "Wähle eine Datei",
  "No file": "Keine Datei",
  Description: "Beschreibung",
  OK: "OK",
  More: "Mehr",
  Cancel: "Abbrechen",
  File: "Datei",
  URL: "URL",
  "Link text": "Anzuzeigender Text",
  "Add row to up": "Zeile nach oben hinzufügen",
  "Add row to down": "Zeile nach unten hinzufügen",
  "Add column to left": "Spalte links hinzufügen",
  "Add column to right": "Spalte rechts hinzufügen",
  "Remove row": "Zeile entfernen",
  "Remove column": "Spalte entfernen",
  "Align column to left": "Links ausrichten",
  "Align column to center": "Zentrieren",
  "Align column to right": "Rechts ausrichten",
  "Remove table": "Tabelle entfernen",
  "Would you like to paste as table?": "Möchten Sie eine Tabelle einfügen?",
  "Text color": "Textfarbe",
  "Auto scroll enabled": "Autoscrollen aktiviert",
  "Auto scroll disabled": "Autoscrollen deaktiviert",
  "Choose language": "Sprache auswählen"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
sr.setLanguage(["es", "es-ES"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Escribir",
  Preview: "Vista previa",
  Headings: "Encabezados",
  Paragraph: "Párrafo",
  Bold: "Negrita",
  Italic: "Itálica",
  Strike: "Tachado",
  Code: "Código",
  Line: "Línea",
  Blockquote: "Cita",
  "Unordered list": "Lista desordenada",
  "Ordered list": "Lista ordenada",
  Task: "Tarea",
  Indent: "Sangría",
  Outdent: "Saliendo",
  "Insert link": "Insertar enlace",
  "Insert CodeBlock": "Insertar bloque de código",
  "Insert table": "Insertar tabla",
  "Insert image": "Insertar imagen",
  Heading: "Encabezado",
  "Image URL": "URL de la imagen",
  "Select image file": "Seleccionar archivo de imagen",
  "Choose a file": "Escoge un archivo",
  "No file": "Ningún archivo",
  Description: "Descripción",
  OK: "Aceptar",
  More: "Más",
  Cancel: "Cancelar",
  File: "Archivo",
  URL: "URL",
  "Link text": "Texto del enlace",
  "Add row to up": "Agregar fila para subir",
  "Add row to down": "Agregar fila hacia abajo",
  "Add column to left": "Agregar columna a la izquierda",
  "Add column to right": "Agregar columna a la derecha",
  "Remove row": "Eliminar fila",
  "Remove column": "Eliminar columna",
  "Align column to left": "Alinear a la izquierda",
  "Align column to center": "Centrar",
  "Align column to right": "Alinear a la derecha",
  "Remove table": "Eliminar tabla",
  "Would you like to paste as table?": "¿Desea pegar como tabla?",
  "Text color": "Color del texto",
  "Auto scroll enabled": "Desplazamiento automático habilitado",
  "Auto scroll disabled": "Desplazamiento automático deshabilitado",
  "Choose language": "Elegir idioma"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
sr.setLanguage(["fi", "fi-FI"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Kirjoita",
  Preview: "Esikatselu",
  Headings: "Otsikot",
  Paragraph: "Kappale",
  Bold: "Lihavointi",
  Italic: "Kursivointi",
  Strike: "Yliviivaus",
  Code: "Koodi",
  Line: "Vaakaviiva",
  Blockquote: "Lainaus",
  "Unordered list": "Luettelo",
  "Ordered list": "Numeroitu luettelo",
  Task: "Tehtävä",
  Indent: "Suurenna sisennystä",
  Outdent: "Pienennä sisennystä",
  "Insert link": "Lisää linkki",
  "Insert CodeBlock": "Lisää koodia",
  "Insert table": "Lisää taulukko",
  "Insert image": "Lisää kuva",
  Heading: "Otsikko",
  "Image URL": "Kuvan URL",
  "Select image file": "Valitse kuvatiedosto",
  "Choose a file": "Valitse tiedosto",
  "No file": "Ei tiedosto",
  Description: "Kuvaus",
  OK: "OK",
  More: "Lisää",
  Cancel: "Peruuta",
  File: "Tiedosto",
  URL: "URL",
  "Link text": "Linkkiteksti",
  "Add row to up": "Lisää rivi ylöspäin",
  "Add row to down": "Lisää rivi alaspäin",
  "Add column to left": "Lisää sarake vasemmalla",
  "Add column to right": "Lisää sarake oikealle",
  "Remove row": "Poista rivi",
  "Remove column": "Poista sarake",
  "Align column to left": "Tasaus vasemmalle",
  "Align column to center": "Keskitä",
  "Align column to right": "Tasaus oikealle",
  "Remove table": "Poista taulukko",
  "Would you like to paste as table?": "Haluatko liittää taulukkomuodossa?",
  "Text color": "Tekstin väri",
  "Auto scroll enabled": "Automaattinen skrollaus käytössä",
  "Auto scroll disabled": "Automaattinen skrollaus pois käytöstä",
  "Choose language": "Valitse kieli"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
sr.setLanguage(["fr", "fr-FR"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Écrire",
  Preview: "Aperçu",
  Headings: "En-têtes",
  Paragraph: "Paragraphe",
  Bold: "Gras",
  Italic: "Italique",
  Strike: "Barré",
  Code: "Code en ligne",
  Line: "Ligne",
  Blockquote: "Citation",
  "Unordered list": "Liste non-ordonnée",
  "Ordered list": "Liste ordonnée",
  Task: "Tâche",
  Indent: "Retrait",
  Outdent: "Sortir",
  "Insert link": "Insérer un lien",
  "Insert CodeBlock": "Insérer un bloc de code",
  "Insert table": "Insérer un tableau",
  "Insert image": "Insérer une image",
  Heading: "En-tête",
  "Image URL": "URL de l'image",
  "Select image file": "Sélectionnez un fichier image",
  "Choose a file": "Choisissez un fichier",
  "No file": "Pas de fichier",
  Description: "Description",
  OK: "OK",
  More: "de plus",
  Cancel: "Annuler",
  File: "Fichier",
  URL: "URL",
  "Link text": "Texte du lien",
  "Add row to up": "Ajouter une ligne vers le haut",
  "Add row to down": "Ajouter une ligne vers le bas",
  "Add column to left": "Ajouter une colonne à gauche",
  "Add column to right": "Ajouter une colonne à droite",
  "Remove row": "Supprimer une ligne",
  "Remove column": "Supprimer une colonne",
  "Align column to left": "Aligner à gauche",
  "Align column to center": "Aligner au centre",
  "Align column to right": "Aligner à droite",
  "Remove table": "Supprimer le tableau",
  "Would you like to paste as table?": "Voulez-vous coller ce contenu en tant que tableau ?",
  "Text color": "Couleur du texte",
  "Auto scroll enabled": "Défilement automatique activé",
  "Auto scroll disabled": "Défilement automatique désactivé",
  "Choose language": "Choix de la langue"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
sr.setLanguage(["gl", "gl-ES"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Escribir",
  Preview: "Vista previa",
  Headings: "Encabezados",
  Paragraph: "Parágrafo",
  Bold: "Negriña",
  Italic: "Cursiva",
  Strike: "Riscado",
  Code: "Código",
  Line: "Liña",
  Blockquote: "Cita",
  "Unordered list": "Lista desordenada",
  "Ordered list": "Lista ordenada",
  Task: "Tarefa",
  Indent: "Sangría",
  Outdent: "Anular sangría",
  "Insert link": "Inserir enlace",
  "Insert CodeBlock": "Inserir bloque de código",
  "Insert table": "Inserir táboa",
  "Insert image": "Inserir imaxe",
  Heading: "Encabezado",
  "Image URL": "URL da imaxe",
  "Select image file": "Seleccionar arquivo da imaxe",
  "Choose a file": "Escoge un archivo",
  "No file": "Ningún archivo",
  Description: "Descrición",
  OK: "Aceptar",
  More: "Máis",
  Cancel: "Cancelar",
  File: "Arquivo",
  URL: "URL",
  "Link text": "Texto do enlace",
  "Add row to up": "Engade fila para arriba",
  "Add row to down": "Engade fila para abaixo",
  "Add column to left": "Engade columna á esquerda",
  "Add column to right": "Engade columna á dereita",
  "Remove row": "Eliminar fila",
  "Remove column": "Eliminar columna",
  "Align column to left": "Aliñar á esquerda",
  "Align column to center": "Centrar",
  "Align column to right": "Aliñar á dereita",
  "Remove table": "Eliminar táboa",
  "Would you like to paste as table?": "Desexa pegar como táboa?",
  "Text color": "Cor do texto",
  "Auto scroll enabled": "Desprazamento automático habilitado",
  "Auto scroll disabled": "Desprazamento automático deshabilitado",
  "Choose language": "Elixir idioma"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
sr.setLanguage(["it", "it-IT"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Scrivere",
  Preview: "Anteprima",
  Headings: "Intestazioni",
  Paragraph: "Paragrafo",
  Bold: "Grassetto",
  Italic: "Corsivo",
  Strike: "Barrato",
  Code: "Codice",
  Line: "Linea",
  Blockquote: "Blocco citazione",
  "Unordered list": "Lista puntata",
  "Ordered list": "Lista numerata",
  Task: "Attività",
  Indent: "Aggiungi indentazione",
  Outdent: "Rimuovi indentazione",
  "Insert link": "Inserisci link",
  "Insert CodeBlock": "Inserisci blocco di codice",
  "Insert table": "Inserisci tabella",
  "Insert image": "Inserisci immagine",
  Heading: "Intestazione",
  "Image URL": "URL immagine",
  "Select image file": "Seleziona file immagine",
  "Choose a file": "Scegli un file",
  "No file": "Nessun file",
  Description: "Descrizione",
  OK: "OK",
  More: "Più",
  Cancel: "Cancella",
  File: "File",
  URL: "URL",
  "Link text": "Testo del collegamento",
  "Add row to up": "Aggiungi riga in alto",
  "Add row to down": "Aggiungi riga in basso",
  "Add column to left": "Aggiungi colonna a sinistra",
  "Add column to right": "Aggiungi colonna a destra",
  "Remove row": "Rimuovi riga",
  "Remove column": "Rimuovi colonna",
  "Align column to left": "Allinea a sinistra",
  "Align column to center": "Allinea al centro",
  "Align column to right": "Allinea a destra",
  "Remove table": "Rimuovi tabella",
  "Would you like to paste as table?": "Desideri incollare sotto forma di tabella?",
  "Text color": "Colore del testo",
  "Auto scroll enabled": "Scrolling automatico abilitato",
  "Auto scroll disabled": "Scrolling automatico disabilitato",
  "Choose language": "Scegli la lingua"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
sr.setLanguage(["ja", "ja-JP"], {
  Markdown: "マークダウン",
  WYSIWYG: "WYSIWYG",
  Write: "編集する",
  Preview: "プレビュー",
  Headings: "見出し",
  Paragraph: "本文",
  Bold: "太字",
  Italic: "イタリック",
  Strike: "ストライク",
  Code: "インラインコード",
  Line: "ライン",
  Blockquote: "引用",
  "Unordered list": "番号なしリスト",
  "Ordered list": "順序付きリスト",
  Task: "タスク",
  Indent: "インデント",
  Outdent: "アウトデント",
  "Insert link": "リンク挿入",
  "Insert CodeBlock": "コードブロック挿入",
  "Insert table": "テーブル挿入",
  "Insert image": "画像挿入",
  Heading: "見出し",
  "Image URL": "イメージURL",
  "Select image file": "画像ファイル選択",
  "Choose a file": "ファイルの選択",
  "No file": "ファイルがない",
  Description: "ディスクリプション ",
  OK: "はい",
  More: "もっと",
  Cancel: "キャンセル",
  File: "ファイル",
  URL: "URL",
  "Link text": "リンクテキスト",
  "Add row to up": "行を上に追加",
  "Add row to down": "下に行を追加",
  "Add column to left": "左側に列を追加",
  "Add column to right": "右側に列を追加",
  "Remove row": "行削除",
  "Remove column": "列削除",
  "Align column to left": "左揃え",
  "Align column to center": "中央揃え",
  "Align column to right": "右揃え",
  "Remove table": "テーブル削除",
  "Would you like to paste as table?": "テーブルを貼り付けますか?",
  "Text color": "文字色相",
  "Auto scroll enabled": "自動スクロールが有効",
  "Auto scroll disabled": "自動スクロールを無効に",
  "Choose language": "言語選択"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
sr.setLanguage(["ko", "ko-KR"], {
  Markdown: "마크다운",
  WYSIWYG: "위지윅",
  Write: "편집하기",
  Preview: "미리보기",
  Headings: "제목크기",
  Paragraph: "본문",
  Bold: "굵게",
  Italic: "기울임꼴",
  Strike: "취소선",
  Code: "인라인 코드",
  Line: "문단나눔",
  Blockquote: "인용구",
  "Unordered list": "글머리 기호",
  "Ordered list": "번호 매기기",
  Task: "체크박스",
  Indent: "들여쓰기",
  Outdent: "내어쓰기",
  "Insert link": "링크 삽입",
  "Insert CodeBlock": "코드블럭 삽입",
  "Insert table": "표 삽입",
  "Insert image": "이미지 삽입",
  Heading: "제목",
  "Image URL": "이미지 주소",
  "Select image file": "이미지 파일을 선택하세요.",
  "Choose a file": "파일 선택",
  "No file": "선택된 파일 없음",
  Description: "설명",
  OK: "확인",
  More: "더 보기",
  Cancel: "취소",
  File: "파일",
  URL: "주소",
  "Link text": "링크 텍스트",
  "Add row to up": "위에 행 추가",
  "Add row to down": "아래에 행 추가",
  "Add column to left": "왼쪽에 열 추가",
  "Add column to right": "오른쪽에 열 추가",
  "Remove row": "행 삭제",
  "Remove column": "열 삭제",
  "Align column to left": "열 왼쪽 정렬",
  "Align column to center": "열 가운데 정렬",
  "Align column to right": "열 오른쪽 정렬",
  "Remove table": "표 삭제",
  "Would you like to paste as table?": "표형태로 붙여 넣겠습니까?",
  "Text color": "글자 색상",
  "Auto scroll enabled": "자동 스크롤 켜짐",
  "Auto scroll disabled": "자동 스크롤 꺼짐",
  "Choose language": "언어 선택"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
sr.setLanguage(["nb", "nb-NO"], {
  Markdown: "Funksjonaliteter",
  WYSIWYG: "WYSIWYG",
  Write: "Skriv",
  Preview: "Forhåndsvisning",
  Headings: "Overskrift",
  Paragraph: "Paragraf",
  Bold: "Fet skrift",
  Italic: "Italic",
  Strike: "Strike",
  Code: "Kode",
  Line: "Linje",
  Blockquote: "Blokksitat",
  "Unordered list": "Usortert liste",
  "Ordered list": "Sortert liste",
  Task: "Task",
  Indent: "Indent",
  Outdent: "Outdent",
  "Insert link": "Sett inn lenke",
  "Insert CodeBlock": "Sett inn CodeStreng",
  "Insert table": "Sett inn diagram",
  "Insert image": "Sett inn bilde",
  Heading: "Overskrift",
  "Image URL": "BildeURL",
  "Select image file": "Velg bildefil",
  "Choose a file": "Velg en fil",
  "No file": "Ingen fil",
  Description: "Beskrivelse",
  OK: "OK",
  More: "Mer",
  Cancel: "Angre",
  File: "Fil",
  URL: "URL",
  "Link text": "Lenketekst",
  "Add row to up": "Legg rad til opp",
  "Add row to down": "Legg rad til ned",
  "Add column to left": "Legg til kolonne til venstre",
  "Add column to right": "Legg til kolonne til høyre",
  "Remove row": "Fjern rad",
  "Remove column": "Fjern kolonne",
  "Align column to left": "Venstreorienter",
  "Align column to center": "Senterorienter",
  "Align column to right": "Høyreorienter",
  "Remove table": "Fjern diagram",
  "Would you like to paste as table?": "Ønsker du å lime inn som et diagram?",
  "Text color": "Tekstfarge",
  "Auto scroll enabled": "Auto-scroll aktivert",
  "Auto scroll disabled": "Auto-scroll deaktivert",
  "Choose language": "Velg språl"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
sr.setLanguage(["nl", "nl-NL"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Opslaan",
  Preview: "Voorbeeld",
  Headings: "Koppen",
  Paragraph: "Alinea",
  Bold: "Vet",
  Italic: "Cursief",
  Strike: "Doorhalen",
  Code: "Inline code",
  Line: "Regel",
  Blockquote: "Citaatblok",
  "Unordered list": "Opsomming",
  "Ordered list": "Genummerde opsomming",
  Task: "Taak",
  Indent: "Niveau verhogen",
  Outdent: "Niveau verlagen",
  "Insert link": "Link invoegen",
  "Insert CodeBlock": "Codeblok toevoegen",
  "Insert table": "Tabel invoegen",
  "Insert image": "Afbeelding invoegen",
  Heading: "Kop",
  "Image URL": "Afbeelding URL",
  "Select image file": "Selecteer een afbeelding",
  "Choose a file": "Kies een bestand",
  "No file": "Geen bestand",
  Description: "Omschrijving",
  OK: "OK",
  More: "Meer",
  Cancel: "Annuleren",
  File: "Bestand",
  URL: "URL",
  "Link text": "Link tekst",
  "Add row to up": "Voeg rij toe aan omhoog",
  "Add row to down": "Rij naar beneden toevoegen",
  "Add column to left": "Voeg kolom aan de linkerkant toe",
  "Add column to right": "Voeg een kolom aan de rechterkant toe",
  "Remove row": "Rij verwijderen",
  "Remove column": "Kolom verwijderen",
  "Align column to left": "Links uitlijnen",
  "Align column to center": "Centreren",
  "Align column to right": "Rechts uitlijnen",
  "Remove table": "Verwijder tabel",
  "Would you like to paste as table?": "Wil je dit als tabel plakken?",
  "Text color": "Tekstkleur",
  "Auto scroll enabled": "Autoscroll ingeschakeld",
  "Auto scroll disabled": "Autoscroll uitgeschakeld",
  "Choose language": "Kies een taal"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
sr.setLanguage(["pl", "pl-PL"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Napisz",
  Preview: "Podgląd",
  Headings: "Nagłówki",
  Paragraph: "Akapit",
  Bold: "Pogrubienie",
  Italic: "Kursywa",
  Strike: "Przekreślenie",
  Code: "Fragment kodu",
  Line: "Linia",
  Blockquote: "Cytat",
  "Unordered list": "Lista nieuporządkowana",
  "Ordered list": "Lista uporządkowana",
  Task: "Zadanie",
  Indent: "Utwórz wcięcie",
  Outdent: "Usuń wcięcie",
  "Insert link": "Umieść odnośnik",
  "Insert CodeBlock": "Umieść blok kodu",
  "Insert table": "Umieść tabelę",
  "Insert image": "Umieść obraz",
  Heading: "Nagłówek",
  "Image URL": "Adres URL obrazu",
  "Select image file": "Wybierz plik obrazu",
  "Choose a file": "Wybierz plik",
  "No file": "Brak plik",
  Description: "Opis",
  OK: "OK",
  More: "Więcej",
  Cancel: "Anuluj",
  File: "Plik",
  URL: "URL",
  "Link text": "Tekst odnośnika",
  "Add row to up": "Dodaj wiersz do góry",
  "Add row to down": "Dodaj wiersz w dół",
  "Add column to left": "Dodaj kolumnę po lewej stronie",
  "Add column to right": "Dodaj kolumnę po prawej stronie",
  "Remove row": "Usuń rząd",
  "Remove column": "Usuń kolumnę",
  "Align column to left": "Wyrównaj do lewej",
  "Align column to center": "Wyśrodkuj",
  "Align column to right": "Wyrównaj do prawej",
  "Remove table": "Usuń tabelę",
  "Would you like to paste as table?": "Czy chcesz wkleić tekst jako tabelę?",
  "Text color": "Kolor tekstu",
  "Auto scroll enabled": "Włączono automatyczne przewijanie",
  "Auto scroll disabled": "Wyłączono automatyczne przewijanie",
  "Choose language": "Wybierz język"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
sr.setLanguage(["ru", "ru-RU"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Редактор",
  Preview: "Просмотр",
  Headings: "Заголовки",
  Paragraph: "Абзац",
  Bold: "Жирный",
  Italic: "Курсив",
  Strike: "Зачеркнутый",
  Code: "Код",
  Line: "Линия",
  Blockquote: "Цитата",
  "Unordered list": "Неупорядоченный список",
  "Ordered list": "Упорядоченный список",
  Task: "Галочка",
  Indent: "Увеличить отступ",
  Outdent: "Уменьшить отступ",
  "Insert link": "Вставить ссылку",
  "Insert CodeBlock": "Вставить блок кода",
  "Insert table": "Вставить таблицу",
  "Insert image": "Вставить изображение",
  Heading: "Заголовок",
  "Image URL": "URL изображения",
  "Select image file": "Выбрать файл изображения",
  "Choose a file": "Выбрать",
  "No file": "Нет файла",
  Description: "Описание",
  OK: "Хорошо",
  More: "Еще",
  Cancel: "Отмена",
  File: "Файл",
  URL: "URL",
  "Link text": "Текст ссылки",
  "Add row to up": "Добавить строку вверх",
  "Add row to down": "Добавить строку вниз",
  "Add column to left": "Добавить столбец слева",
  "Add column to right": "Добавить столбец справа",
  "Remove row": "Удалить ряд",
  "Remove column": "Удалить столбец",
  "Align column to left": "Выровнять по левому краю",
  "Align column to center": "Выровнять по центру",
  "Align column to right": "Выровнять по правому краю",
  "Remove table": "Удалить таблицу",
  "Would you like to paste as table?": "Вы хотите вставить в виде таблицы?",
  "Text color": "Цвет текста",
  "Auto scroll enabled": "Автопрокрутка включена",
  "Auto scroll disabled": "Автопрокрутка отключена",
  "Choose language": "Выбрать язык"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
sr.setLanguage(["sv", "sv-SE"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Skriv",
  Preview: "Förhandsgranska",
  Headings: "Överskrifter",
  Paragraph: "Paragraf",
  Bold: "Fet",
  Italic: "Kursiv",
  Strike: "Genomstruken",
  Code: "Kodrad",
  Line: "Linje",
  Blockquote: "Citatblock",
  "Unordered list": "Punktlista",
  "Ordered list": "Numrerad lista",
  Task: "Att göra",
  Indent: "Öka indrag",
  Outdent: "Minska indrag",
  "Insert link": "Infoga länk",
  "Insert CodeBlock": "Infoga kodblock",
  "Insert table": "Infoga tabell",
  "Insert image": "Infoga bild",
  Heading: "Överskrift",
  "Image URL": "Bildadress",
  "Select image file": "Välj en bildfil",
  "Choose a file": "Välj en fil",
  "No file": "Ingen fil",
  Description: "Beskrivning",
  OK: "OK",
  More: "Mer",
  Cancel: "Avbryt",
  File: "Fil",
  URL: "Adress",
  "Link text": "Länktext",
  "Add row to up": "Lägg till rad till upp",
  "Add row to down": "Lägg till rad till ner",
  "Add column to left": "Lägg till kolumn till vänster",
  "Add column to right": "Lägg till kolumn till höger",
  "Remove row": "Radera rad",
  "Remove column": "Radera kolumn",
  "Align column to left": "Vänsterjustera",
  "Align column to center": "Centrera",
  "Align column to right": "Högerjustera",
  "Remove table": "Radera tabell",
  "Would you like to paste as table?": "Vill du klistra in som en tabell?",
  "Text color": "Textfärg",
  "Auto scroll enabled": "Automatisk scroll aktiverad",
  "Auto scroll disabled": "Automatisk scroll inaktiverad",
  "Choose language": "Välj språk"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
sr.setLanguage(["tr", "tr-TR"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Düzenle",
  Preview: "Ön izleme",
  Headings: "Başlıklar",
  Paragraph: "Paragraf",
  Bold: "Kalın",
  Italic: "İtalik",
  Strike: "Altı çizgili",
  Code: "Satır içi kod",
  Line: "Çizgi",
  Blockquote: "Alıntı",
  "Unordered list": "Sıralanmamış liste",
  "Ordered list": "Sıralı liste",
  Task: "Görev kutusu",
  Indent: "Girintiyi arttır",
  Outdent: "Girintiyi azalt",
  "Insert link": "Bağlantı ekle",
  "Insert CodeBlock": "Kod bloku ekle",
  "Insert table": "Tablo ekle",
  "Insert image": "İmaj ekle",
  Heading: "Başlık",
  "Image URL": "İmaj URL",
  "Select image file": "İmaj dosyası seç",
  "Choose a file": "Bir dosya seçin",
  "No file": "Dosya yok",
  Description: "Açıklama",
  OK: "Onay",
  More: "Daha Fazla",
  Cancel: "İptal",
  File: "Dosya",
  URL: "URL",
  "Link text": "Bağlantı yazısı",
  "Add row to up": "Yukarı satır ekle",
  "Add row to down": "Aşağı satır ekle",
  "Add column to left": "Sola sütun ekleyin",
  "Add column to right": "Sağa sütun ekle",
  "Remove row": "Satır sil",
  "Remove column": "Sütun sil",
  "Align column to left": "Sola hizala",
  "Align column to center": "Merkeze hizala",
  "Align column to right": "Sağa hizala",
  "Remove table": "Tabloyu kaldır",
  "Would you like to paste as table?": "Tablo olarak yapıştırmak ister misiniz?",
  "Text color": "Metin rengi",
  "Auto scroll enabled": "Otomatik kaydırma açık",
  "Auto scroll disabled": "Otomatik kaydırma kapalı",
  "Choose language": "Dil seçiniz"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
sr.setLanguage(["uk", "uk-UA"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Написати",
  Preview: "Попередній перегляд",
  Headings: "Заголовки",
  Paragraph: "Абзац",
  Bold: "Жирний",
  Italic: "Курсив",
  Strike: "Закреслений",
  Code: "Вбудований код",
  Line: "Лінія",
  Blockquote: "Блок цитування",
  "Unordered list": "Невпорядкований список",
  "Ordered list": "Упорядкований список",
  Task: "Завдання",
  Indent: "відступ",
  Outdent: "застарілий",
  "Insert link": "Вставити посилання",
  "Insert CodeBlock": "Вставити код",
  "Insert table": "Вставити таблицю",
  "Insert image": "Вставити зображення",
  Heading: "Заголовок",
  "Image URL": "URL зображення",
  "Select image file": "Вибрати файл зображення",
  "Choose a file": "Виберіть файл",
  "No file": "Немає файлу",
  Description: "Опис",
  OK: "OK",
  More: "ще",
  Cancel: "Скасувати",
  File: "Файл",
  URL: "URL",
  "Link text": "Текст посилання",
  "Add row to up": "Додати рядок вгору",
  "Add row to down": "Додати рядок вниз",
  "Add column to left": "Додайте стовпець зліва",
  "Add column to right": "Додайте стовпець праворуч",
  "Remove row": "Видалити ряд",
  "Remove column": "Видалити стовпчик",
  "Align column to left": "Вирівняти по лівому краю",
  "Align column to center": "Вирівняти по центру",
  "Align column to right": "Вирівняти по правому краю",
  "Remove table": "Видалити таблицю",
  "Would you like to paste as table?": "Ви хочете вставити у вигляді таблиці?",
  "Text color": "Колір тексту",
  "Auto scroll enabled": "Автоматична прокрутка включена",
  "Auto scroll disabled": "Автоматична прокрутка відключена",
  "Choose language": "Вибрати мову"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
sr.setLanguage("zh-CN", {
  Markdown: "Markdown",
  WYSIWYG: "所见即所得",
  Write: "编辑",
  Preview: "预览",
  Headings: "标题",
  Paragraph: "文本",
  Bold: "加粗",
  Italic: "斜体字",
  Strike: "删除线",
  Code: "内嵌代码",
  Line: "水平线",
  Blockquote: "引用块",
  "Unordered list": "无序列表",
  "Ordered list": "有序列表",
  Task: "任务",
  Indent: "缩进",
  Outdent: "减少缩进",
  "Insert link": "插入链接",
  "Insert CodeBlock": "插入代码块",
  "Insert table": "插入表格",
  "Insert image": "插入图片",
  Heading: "标题",
  "Image URL": "图片网址",
  "Select image file": "选择图片文件",
  "Choose a file": "选择一个文件",
  "No file": "没有文件",
  Description: "说明",
  OK: "确认",
  More: "更多",
  Cancel: "取消",
  File: "文件",
  URL: "URL",
  "Link text": "链接文本",
  "Add row to up": "向上添加行",
  "Add row to down": "在下方添加行",
  "Add column to left": "在左侧添加列",
  "Add column to right": "在右侧添加列",
  "Remove row": "删除行",
  "Remove column": "删除列",
  "Align column to left": "左对齐",
  "Align column to center": "居中对齐",
  "Align column to right": "右对齐",
  "Remove table": "删除表格",
  "Would you like to paste as table?": "需要粘贴为表格吗?",
  "Text color": "文字颜色",
  "Auto scroll enabled": "自动滚动已启用",
  "Auto scroll disabled": "自动滚动已禁用",
  "Choose language": "选择语言"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
sr.setLanguage("zh-TW", {
  Markdown: "Markdown",
  WYSIWYG: "所見即所得",
  Write: "編輯",
  Preview: "預覽",
  Headings: "標題",
  Paragraph: "內文",
  Bold: "粗體",
  Italic: "斜體",
  Strike: "刪除線",
  Code: "內嵌程式碼",
  Line: "分隔線",
  Blockquote: "引言",
  "Unordered list": "項目符號清單",
  "Ordered list": "編號清單",
  Task: "核取方塊清單",
  Indent: "增加縮排",
  Outdent: "減少縮排",
  "Insert link": "插入超連結",
  "Insert CodeBlock": "插入程式碼區塊",
  "Insert table": "插入表格",
  "Insert image": "插入圖片",
  Heading: "標題",
  "Image URL": "圖片網址",
  "Select image file": "選擇圖片檔案",
  "Choose a file": "選擇一個文件",
  "No file": "沒有文件",
  Description: "描述",
  OK: "確認",
  More: "更多",
  Cancel: "取消",
  File: "檔案",
  URL: "URL",
  "Link text": "超連結文字",
  "Add row to up": "向上添加行",
  "Add row to down": "在下方添加行",
  "Add column to left": "在左側添加列",
  "Add column to right": "在右側添加列",
  "Remove row": "刪除行",
  "Remove column": "刪除列",
  "Align column to left": "靠左對齊",
  "Align column to center": "置中",
  "Align column to right": "靠右對齊",
  "Remove table": "刪除表格",
  "Would you like to paste as table?": "您要以表格貼上嗎？",
  "Text color": "文字顏色",
  "Auto scroll enabled": "已啟用自動滾動",
  "Auto scroll disabled": "已停用自動滾動",
  "Choose language": "選擇語言"
});
const oVe = (t, e) => {
  if (!t.value)
    throw new Error("Reference to the element is set");
  const r = new sr({
    el: t.value,
    height: e.height,
    hideModeSwitch: e.hideModeSwitch,
    initialEditType: e.initialEditType,
    initialValue: e.initialValue,
    language: e.language,
    plugins: e.plugins,
    previewStyle: e.previewStyle,
    toolbarItems: e.toolbarItems,
    usageStatistics: e.usageStatistics,
    useCommandShortcut: e.useCommandShortcut,
    customHTMLSanitizer: (n) => n,
    events: {
      change: e.onChange ? () => e.onChange && e.onChange(r) : () => {
      }
    },
    hooks: {
      addImageBlobHook: e.addImageBlobHook
    }
  });
  return r;
}, sVe = {
  key: 0,
  class: "fullscreen-button-container"
}, lVe = /* @__PURE__ */ ds("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  fill: "none",
  viewBox: "0 0 24 24",
  stroke: "currentColor",
  "stroke-width": "2"
}, [
  /* @__PURE__ */ ds("path", {
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    d: "M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"
  })
], -1), uVe = [
  lVe
], cVe = /* @__PURE__ */ Wp({
  __name: "Editor",
  props: {
    allowFullScreen: { type: Boolean, default: !0 },
    darkMode: { type: Boolean, default: !1 },
    editorClasses: {},
    enhanced: { type: Boolean, default: !0 },
    height: { default: "500px" },
    hideModeSwitch: { type: Boolean },
    initialEditType: { default: "markdown" },
    language: {},
    modelValue: { default: "" },
    plugins: { default: () => [] },
    previewStyle: { default: "tab" },
    toolbarItems: { default: () => [
      ["heading", "bold", "italic"],
      ["quote", "ul", "ol"],
      ["table", "link"]
    ] },
    usageStatistics: { type: Boolean },
    useCommandShortcut: { type: Boolean }
  },
  emits: ["update:modelValue", "addImage", "fullScreenChange"],
  setup(t, { expose: e, emit: r }) {
    const n = t, a = ns(null), i = ns(null), o = ns(!1);
    return e({ editor: a }), Z6(o, (u) => {
      const m = document.body.classList;
      u ? m.add("overflow-hidden") : m.remove("overflow-hidden"), r("fullScreenChange", u);
    }), jp(() => Q6(() => {
      a.value = oVe(i, {
        height: "100cqh",
        hideModeSwitch: n.hideModeSwitch,
        initialEditType: n.initialEditType,
        initialValue: n.modelValue,
        language: n.language,
        plugins: n.plugins,
        previewStyle: n.previewStyle,
        toolbarItems: n.toolbarItems,
        usageStatistics: n.usageStatistics,
        useCommandShortcut: n.useCommandShortcut,
        addImageBlobHook: (u, m) => r("addImage", { blob: u, callback: m }),
        onChange: (u) => r("update:modelValue", u.getMarkdown())
      });
    })), (u, m) => (_u(), Hu("div", {
      class: Uu(["tui-editor-vue3-wrapper", {
        "tui-editor-vue3-enhanced": u.enhanced,
        "toastui-full-screen": o.value,
        "toastui-editor-dark": u.darkMode
      }]),
      style: X6({ height: o.value ? void 0 : u.height }),
      onKeydown: m[1] || (m[1] = eJ((y) => o.value = !1, ["escape"]))
    }, [
      ds("div", {
        ref_key: "editorEl",
        ref: i,
        class: Uu(u.editorClasses)
      }, null, 2),
      n.allowFullScreen ? (_u(), Hu("div", sVe, [
        ds("a", {
          href: "#",
          class: "fullscreen-button",
          onClick: m[0] || (m[0] = tJ((y) => o.value = !o.value, ["prevent"]))
        }, uVe)
      ])) : rJ("", !0)
    ], 38));
  }
});
var ig = { exports: {} };
/*!
 * @toast-ui/editor
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
(function(t, e) {
  (function(n, a) {
    t.exports = a(nh(), Kp(), io(), oo(), Gp());
  })(self, function(r, n, a, i, o) {
    return (
      /******/
      function() {
        var u = {
          /***/
          368: (
            /***/
            function(T) {
              /*! @license DOMPurify 2.3.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.3/LICENSE */
              (function(x, M) {
                T.exports = M();
              })(this, function() {
                function x(He) {
                  if (Array.isArray(He)) {
                    for (var _e = 0, Xe = Array(He.length); _e < He.length; _e++)
                      Xe[_e] = He[_e];
                    return Xe;
                  } else
                    return Array.from(He);
                }
                var M = Object.hasOwnProperty, P = Object.setPrototypeOf, q = Object.isFrozen, _ = Object.getPrototypeOf, K = Object.getOwnPropertyDescriptor, X = Object.freeze, ie = Object.seal, ee = Object.create, oe = typeof Reflect < "u" && Reflect, ue = oe.apply, pe = oe.construct;
                ue || (ue = function(_e, Xe, st) {
                  return _e.apply(Xe, st);
                }), X || (X = function(_e) {
                  return _e;
                }), ie || (ie = function(_e) {
                  return _e;
                }), pe || (pe = function(_e, Xe) {
                  return new (Function.prototype.bind.apply(_e, [null].concat(x(Xe))))();
                });
                var Se = Pt(Array.prototype.forEach), Re = Pt(Array.prototype.pop), Me = Pt(Array.prototype.push), ze = Pt(String.prototype.toLowerCase), vt = Pt(String.prototype.match), je = Pt(String.prototype.replace), rt = Pt(String.prototype.indexOf), at = Pt(String.prototype.trim), St = Pt(RegExp.prototype.test), pt = Ft(TypeError);
                function Pt(He) {
                  return function(_e) {
                    for (var Xe = arguments.length, st = Array(Xe > 1 ? Xe - 1 : 0), Ct = 1; Ct < Xe; Ct++)
                      st[Ct - 1] = arguments[Ct];
                    return ue(He, _e, st);
                  };
                }
                function Ft(He) {
                  return function() {
                    for (var _e = arguments.length, Xe = Array(_e), st = 0; st < _e; st++)
                      Xe[st] = arguments[st];
                    return pe(He, Xe);
                  };
                }
                function Je(He, _e) {
                  P && P(He, null);
                  for (var Xe = _e.length; Xe--; ) {
                    var st = _e[Xe];
                    if (typeof st == "string") {
                      var Ct = ze(st);
                      Ct !== st && (q(_e) || (_e[Xe] = Ct), st = Ct);
                    }
                    He[st] = !0;
                  }
                  return He;
                }
                function Nt(He) {
                  var _e = ee(null), Xe = void 0;
                  for (Xe in He)
                    ue(M, He, [Xe]) && (_e[Xe] = He[Xe]);
                  return _e;
                }
                function yt(He, _e) {
                  for (; He !== null; ) {
                    var Xe = K(He, _e);
                    if (Xe) {
                      if (Xe.get)
                        return Pt(Xe.get);
                      if (typeof Xe.value == "function")
                        return Pt(Xe.value);
                    }
                    He = _(He);
                  }
                  function st(Ct) {
                    return console.warn("fallback value for", Ct), null;
                  }
                  return st;
                }
                var At = X(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), lt = X(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), Rt = X(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), he = X(["animate", "color-profile", "cursor", "discard", "fedropshadow", "feimage", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), le = X(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), te = X(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), ae = X(["#text"]), Z = X(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), de = X(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), Te = X(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Pe = X(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), ft = ie(/\{\{[\s\S]*|[\s\S]*\}\}/gm), ht = ie(/<%[\s\S]*|[\s\S]*%>/gm), wt = ie(/^data-[\-\w.\u00B7-\uFFFF]/), Ot = ie(/^aria-[\-\w]+$/), Ut = ie(
                  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
                  // eslint-disable-line no-useless-escape
                ), Kt = ie(/^(?:\w+script|data):/i), qr = ie(
                  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
                  // eslint-disable-line no-control-regex
                ), Jt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(He) {
                  return typeof He;
                } : function(He) {
                  return He && typeof Symbol == "function" && He.constructor === Symbol && He !== Symbol.prototype ? "symbol" : typeof He;
                };
                function _t(He) {
                  if (Array.isArray(He)) {
                    for (var _e = 0, Xe = Array(He.length); _e < He.length; _e++)
                      Xe[_e] = He[_e];
                    return Xe;
                  } else
                    return Array.from(He);
                }
                var pr = function() {
                  return typeof window > "u" ? null : window;
                }, hr = function(_e, Xe) {
                  if ((typeof _e > "u" ? "undefined" : Jt(_e)) !== "object" || typeof _e.createPolicy != "function")
                    return null;
                  var st = null, Ct = "data-tt-policy-suffix";
                  Xe.currentScript && Xe.currentScript.hasAttribute(Ct) && (st = Xe.currentScript.getAttribute(Ct));
                  var rr = "dompurify" + (st ? "#" + st : "");
                  try {
                    return _e.createPolicy(rr, {
                      createHTML: function(Yt) {
                        return Yt;
                      }
                    });
                  } catch {
                    return console.warn("TrustedTypes policy " + rr + " could not be created."), null;
                  }
                };
                function Fr() {
                  var He = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : pr(), _e = function(se) {
                    return Fr(se);
                  };
                  if (_e.version = "2.3.3", _e.removed = [], !He || !He.document || He.document.nodeType !== 9)
                    return _e.isSupported = !1, _e;
                  var Xe = He.document, st = He.document, Ct = He.DocumentFragment, rr = He.HTMLTemplateElement, lr = He.Node, Yt = He.Element, Zt = He.NodeFilter, Rr = He.NamedNodeMap, Cr = Rr === void 0 ? He.NamedNodeMap || He.MozNamedAttrMap : Rr, Qt = He.Text, Hr = He.Comment, Tr = He.DOMParser, nn = He.trustedTypes, W = Yt.prototype, V = yt(W, "cloneNode"), R = yt(W, "nextSibling"), D = yt(W, "childNodes"), I = yt(W, "parentNode");
                  if (typeof rr == "function") {
                    var H = st.createElement("template");
                    H.content && H.content.ownerDocument && (st = H.content.ownerDocument);
                  }
                  var J = hr(nn, Xe), ve = J && In ? J.createHTML("") : "", me = st, be = me.implementation, Oe = me.createNodeIterator, Ye = me.createDocumentFragment, We = me.getElementsByTagName, ut = Xe.importNode, ct = {};
                  try {
                    ct = Nt(st).documentMode ? st.documentMode : {};
                  } catch {
                  }
                  var Ae = {};
                  _e.isSupported = typeof I == "function" && be && typeof be.createHTMLDocument < "u" && ct !== 9;
                  var ne = ft, Ee = ht, N = wt, S = Ot, v = Kt, b = qr, A = Ut, B = null, z = Je({}, [].concat(_t(At), _t(lt), _t(Rt), _t(le), _t(ae))), G = null, fe = Je({}, [].concat(_t(Z), _t(de), _t(Te), _t(Pe))), Ce = null, Ie = null, Le = !0, Fe = !0, it = !1, Ht = !1, nr = !1, Mr = !1, Ur = !1, zr = !1, Rn = !1, $r = !0, In = !1, Ea = !0, Pn = !0, Cn = !1, Tn = {}, Sn = null, xa = Je({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), Aa = null, ua = Je({}, ["audio", "video", "img", "source", "image", "track"]), ca = null, Ma = Je({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), La = "http://www.w3.org/1998/Math/MathML", Bn = "http://www.w3.org/2000/svg", mr = "http://www.w3.org/1999/xhtml", qn = mr, En = !1, Vr = void 0, Fn = ["application/xhtml+xml", "text/html"], Ri = "text/html", fn = void 0, vn = null, Ii = st.createElement("form"), Oa = function(se) {
                    vn && vn === se || ((!se || (typeof se > "u" ? "undefined" : Jt(se)) !== "object") && (se = {}), se = Nt(se), B = "ALLOWED_TAGS" in se ? Je({}, se.ALLOWED_TAGS) : z, G = "ALLOWED_ATTR" in se ? Je({}, se.ALLOWED_ATTR) : fe, ca = "ADD_URI_SAFE_ATTR" in se ? Je(Nt(Ma), se.ADD_URI_SAFE_ATTR) : Ma, Aa = "ADD_DATA_URI_TAGS" in se ? Je(Nt(ua), se.ADD_DATA_URI_TAGS) : ua, Sn = "FORBID_CONTENTS" in se ? Je({}, se.FORBID_CONTENTS) : xa, Ce = "FORBID_TAGS" in se ? Je({}, se.FORBID_TAGS) : {}, Ie = "FORBID_ATTR" in se ? Je({}, se.FORBID_ATTR) : {}, Tn = "USE_PROFILES" in se ? se.USE_PROFILES : !1, Le = se.ALLOW_ARIA_ATTR !== !1, Fe = se.ALLOW_DATA_ATTR !== !1, it = se.ALLOW_UNKNOWN_PROTOCOLS || !1, Ht = se.SAFE_FOR_TEMPLATES || !1, nr = se.WHOLE_DOCUMENT || !1, zr = se.RETURN_DOM || !1, Rn = se.RETURN_DOM_FRAGMENT || !1, $r = se.RETURN_DOM_IMPORT !== !1, In = se.RETURN_TRUSTED_TYPE || !1, Ur = se.FORCE_BODY || !1, Ea = se.SANITIZE_DOM !== !1, Pn = se.KEEP_CONTENT !== !1, Cn = se.IN_PLACE || !1, A = se.ALLOWED_URI_REGEXP || A, qn = se.NAMESPACE || mr, Vr = // eslint-disable-next-line unicorn/prefer-includes
                    Fn.indexOf(se.PARSER_MEDIA_TYPE) === -1 ? Vr = Ri : Vr = se.PARSER_MEDIA_TYPE, fn = Vr === "application/xhtml+xml" ? function(Ne) {
                      return Ne;
                    } : ze, Ht && (Fe = !1), Rn && (zr = !0), Tn && (B = Je({}, [].concat(_t(ae))), G = [], Tn.html === !0 && (Je(B, At), Je(G, Z)), Tn.svg === !0 && (Je(B, lt), Je(G, de), Je(G, Pe)), Tn.svgFilters === !0 && (Je(B, Rt), Je(G, de), Je(G, Pe)), Tn.mathMl === !0 && (Je(B, le), Je(G, Te), Je(G, Pe))), se.ADD_TAGS && (B === z && (B = Nt(B)), Je(B, se.ADD_TAGS)), se.ADD_ATTR && (G === fe && (G = Nt(G)), Je(G, se.ADD_ATTR)), se.ADD_URI_SAFE_ATTR && Je(ca, se.ADD_URI_SAFE_ATTR), se.FORBID_CONTENTS && (Sn === xa && (Sn = Nt(Sn)), Je(Sn, se.FORBID_CONTENTS)), Pn && (B["#text"] = !0), nr && Je(B, ["html", "head", "body"]), B.table && (Je(B, ["tbody"]), delete Ce.tbody), X && X(se), vn = se);
                  }, fa = Je({}, ["mi", "mo", "mn", "ms", "mtext"]), Da = Je({}, ["foreignobject", "desc", "title", "annotation-xml"]), _n = Je({}, lt);
                  Je(_n, Rt), Je(_n, he);
                  var va = Je({}, le);
                  Je(va, te);
                  var ri = function(se) {
                    var Ne = I(se);
                    (!Ne || !Ne.tagName) && (Ne = {
                      namespaceURI: mr,
                      tagName: "template"
                    });
                    var Ge = ze(se.tagName), Mt = ze(Ne.tagName);
                    if (se.namespaceURI === Bn)
                      return Ne.namespaceURI === mr ? Ge === "svg" : Ne.namespaceURI === La ? Ge === "svg" && (Mt === "annotation-xml" || fa[Mt]) : !!_n[Ge];
                    if (se.namespaceURI === La)
                      return Ne.namespaceURI === mr ? Ge === "math" : Ne.namespaceURI === Bn ? Ge === "math" && Da[Mt] : !!va[Ge];
                    if (se.namespaceURI === mr) {
                      if (Ne.namespaceURI === Bn && !Da[Mt] || Ne.namespaceURI === La && !fa[Mt])
                        return !1;
                      var ar = Je({}, ["title", "style", "font", "a", "script"]);
                      return !va[Ge] && (ar[Ge] || !_n[Ge]);
                    }
                    return !1;
                  }, jr = function(se) {
                    Me(_e.removed, { element: se });
                    try {
                      se.parentNode.removeChild(se);
                    } catch {
                      try {
                        se.outerHTML = ve;
                      } catch {
                        se.remove();
                      }
                    }
                  }, ni = function(se, Ne) {
                    try {
                      Me(_e.removed, {
                        attribute: Ne.getAttributeNode(se),
                        from: Ne
                      });
                    } catch {
                      Me(_e.removed, {
                        attribute: null,
                        from: Ne
                      });
                    }
                    if (Ne.removeAttribute(se), se === "is" && !G[se])
                      if (zr || Rn)
                        try {
                          jr(Ne);
                        } catch {
                        }
                      else
                        try {
                          Ne.setAttribute(se, "");
                        } catch {
                        }
                  }, ai = function(se) {
                    var Ne = void 0, Ge = void 0;
                    if (Ur)
                      se = "<remove></remove>" + se;
                    else {
                      var Mt = vt(se, /^[\r\n\t ]+/);
                      Ge = Mt && Mt[0];
                    }
                    Vr === "application/xhtml+xml" && (se = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + se + "</body></html>");
                    var ar = J ? J.createHTML(se) : se;
                    if (qn === mr)
                      try {
                        Ne = new Tr().parseFromString(ar, Vr);
                      } catch {
                      }
                    if (!Ne || !Ne.documentElement) {
                      Ne = be.createDocument(qn, "template", null);
                      try {
                        Ne.documentElement.innerHTML = En ? "" : ar;
                      } catch {
                      }
                    }
                    var ir = Ne.body || Ne.documentElement;
                    return se && Ge && ir.insertBefore(st.createTextNode(Ge), ir.childNodes[0] || null), qn === mr ? We.call(Ne, nr ? "html" : "body")[0] : nr ? Ne.documentElement : ir;
                  }, da = function(se) {
                    return Oe.call(se.ownerDocument || se, se, Zt.SHOW_ELEMENT | Zt.SHOW_COMMENT | Zt.SHOW_TEXT, null, !1);
                  }, Na = function(se) {
                    return se instanceof Qt || se instanceof Hr ? !1 : typeof se.nodeName != "string" || typeof se.textContent != "string" || typeof se.removeChild != "function" || !(se.attributes instanceof Cr) || typeof se.removeAttribute != "function" || typeof se.setAttribute != "function" || typeof se.namespaceURI != "string" || typeof se.insertBefore != "function";
                  }, Hn = function(se) {
                    return (typeof lr > "u" ? "undefined" : Jt(lr)) === "object" ? se instanceof lr : se && (typeof se > "u" ? "undefined" : Jt(se)) === "object" && typeof se.nodeType == "number" && typeof se.nodeName == "string";
                  }, Gr = function(se, Ne, Ge) {
                    Ae[se] && Se(Ae[se], function(Mt) {
                      Mt.call(_e, Ne, Ge, vn);
                    });
                  }, Ra = function(se) {
                    var Ne = void 0;
                    if (Gr("beforeSanitizeElements", se, null), Na(se) || vt(se.nodeName, /[\u0080-\uFFFF]/))
                      return jr(se), !0;
                    var Ge = fn(se.nodeName);
                    if (Gr("uponSanitizeElement", se, {
                      tagName: Ge,
                      allowedTags: B
                    }), !Hn(se.firstElementChild) && (!Hn(se.content) || !Hn(se.content.firstElementChild)) && St(/<[/\w]/g, se.innerHTML) && St(/<[/\w]/g, se.textContent) || Ge === "select" && St(/<template/i, se.innerHTML))
                      return jr(se), !0;
                    if (!B[Ge] || Ce[Ge]) {
                      if (Pn && !Sn[Ge]) {
                        var Mt = I(se) || se.parentNode, ar = D(se) || se.childNodes;
                        if (ar && Mt)
                          for (var ir = ar.length, Tt = ir - 1; Tt >= 0; --Tt)
                            Mt.insertBefore(V(ar[Tt], !0), R(se));
                      }
                      return jr(se), !0;
                    }
                    return se instanceof Yt && !ri(se) || (Ge === "noscript" || Ge === "noembed") && St(/<\/no(script|embed)/i, se.innerHTML) ? (jr(se), !0) : (Ht && se.nodeType === 3 && (Ne = se.textContent, Ne = je(Ne, ne, " "), Ne = je(Ne, Ee, " "), se.textContent !== Ne && (Me(_e.removed, { element: se.cloneNode() }), se.textContent = Ne)), Gr("afterSanitizeElements", se, null), !1);
                  }, Ia = function(se, Ne, Ge) {
                    if (Ea && (Ne === "id" || Ne === "name") && (Ge in st || Ge in Ii))
                      return !1;
                    if (!(Fe && !Ie[Ne] && St(N, Ne))) {
                      if (!(Le && St(S, Ne))) {
                        if (!G[Ne] || Ie[Ne])
                          return !1;
                        if (!ca[Ne]) {
                          if (!St(A, je(Ge, b, ""))) {
                            if (!((Ne === "src" || Ne === "xlink:href" || Ne === "href") && se !== "script" && rt(Ge, "data:") === 0 && Aa[se])) {
                              if (!(it && !St(v, je(Ge, b, "")))) {
                                if (Ge)
                                  return !1;
                              }
                            }
                          }
                        }
                      }
                    }
                    return !0;
                  }, Pa = function(se) {
                    var Ne = void 0, Ge = void 0, Mt = void 0, ar = void 0;
                    Gr("beforeSanitizeAttributes", se, null);
                    var ir = se.attributes;
                    if (ir) {
                      var Tt = {
                        attrName: "",
                        attrValue: "",
                        keepAttr: !0,
                        allowedAttributes: G
                      };
                      for (ar = ir.length; ar--; ) {
                        Ne = ir[ar];
                        var qt = Ne, Un = qt.name, ii = qt.namespaceURI;
                        if (Ge = at(Ne.value), Mt = fn(Un), Tt.attrName = Mt, Tt.attrValue = Ge, Tt.keepAttr = !0, Tt.forceKeepAttr = void 0, Gr("uponSanitizeAttribute", se, Tt), Ge = Tt.attrValue, !Tt.forceKeepAttr && (ni(Un, se), !!Tt.keepAttr)) {
                          if (St(/\/>/i, Ge)) {
                            ni(Un, se);
                            continue;
                          }
                          Ht && (Ge = je(Ge, ne, " "), Ge = je(Ge, Ee, " "));
                          var Pi = fn(se.nodeName);
                          if (Ia(Pi, Mt, Ge))
                            try {
                              ii ? se.setAttributeNS(ii, Un, Ge) : se.setAttribute(Un, Ge), Re(_e.removed);
                            } catch {
                            }
                        }
                      }
                      Gr("afterSanitizeAttributes", se, null);
                    }
                  }, Ba = function Ze(se) {
                    var Ne = void 0, Ge = da(se);
                    for (Gr("beforeSanitizeShadowDOM", se, null); Ne = Ge.nextNode(); )
                      Gr("uponSanitizeShadowNode", Ne, null), !Ra(Ne) && (Ne.content instanceof Ct && Ze(Ne.content), Pa(Ne));
                    Gr("afterSanitizeShadowDOM", se, null);
                  };
                  return _e.sanitize = function(Ze, se) {
                    var Ne = void 0, Ge = void 0, Mt = void 0, ar = void 0, ir = void 0;
                    if (En = !Ze, En && (Ze = "<!-->"), typeof Ze != "string" && !Hn(Ze)) {
                      if (typeof Ze.toString != "function")
                        throw pt("toString is not a function");
                      if (Ze = Ze.toString(), typeof Ze != "string")
                        throw pt("dirty is not a string, aborting");
                    }
                    if (!_e.isSupported) {
                      if (Jt(He.toStaticHTML) === "object" || typeof He.toStaticHTML == "function") {
                        if (typeof Ze == "string")
                          return He.toStaticHTML(Ze);
                        if (Hn(Ze))
                          return He.toStaticHTML(Ze.outerHTML);
                      }
                      return Ze;
                    }
                    if (Mr || Oa(se), _e.removed = [], typeof Ze == "string" && (Cn = !1), !Cn)
                      if (Ze instanceof lr)
                        Ne = ai("<!---->"), Ge = Ne.ownerDocument.importNode(Ze, !0), Ge.nodeType === 1 && Ge.nodeName === "BODY" || Ge.nodeName === "HTML" ? Ne = Ge : Ne.appendChild(Ge);
                      else {
                        if (!zr && !Ht && !nr && // eslint-disable-next-line unicorn/prefer-includes
                        Ze.indexOf("<") === -1)
                          return J && In ? J.createHTML(Ze) : Ze;
                        if (Ne = ai(Ze), !Ne)
                          return zr ? null : ve;
                      }
                    Ne && Ur && jr(Ne.firstChild);
                    for (var Tt = da(Cn ? Ze : Ne); Mt = Tt.nextNode(); )
                      Mt.nodeType === 3 && Mt === ar || Ra(Mt) || (Mt.content instanceof Ct && Ba(Mt.content), Pa(Mt), ar = Mt);
                    if (ar = null, Cn)
                      return Ze;
                    if (zr) {
                      if (Rn)
                        for (ir = Ye.call(Ne.ownerDocument); Ne.firstChild; )
                          ir.appendChild(Ne.firstChild);
                      else
                        ir = Ne;
                      return $r && (ir = ut.call(Xe, ir, !0)), ir;
                    }
                    var qt = nr ? Ne.outerHTML : Ne.innerHTML;
                    return Ht && (qt = je(qt, ne, " "), qt = je(qt, Ee, " ")), J && In ? J.createHTML(qt) : qt;
                  }, _e.setConfig = function(Ze) {
                    Oa(Ze), Mr = !0;
                  }, _e.clearConfig = function() {
                    vn = null, Mr = !1;
                  }, _e.isValidAttribute = function(Ze, se, Ne) {
                    vn || Oa({});
                    var Ge = fn(Ze), Mt = fn(se);
                    return Ia(Ge, Mt, Ne);
                  }, _e.addHook = function(Ze, se) {
                    typeof se == "function" && (Ae[Ze] = Ae[Ze] || [], Me(Ae[Ze], se));
                  }, _e.removeHook = function(Ze) {
                    Ae[Ze] && Re(Ae[Ze]);
                  }, _e.removeHooks = function(Ze) {
                    Ae[Ze] && (Ae[Ze] = []);
                  }, _e.removeAllHooks = function() {
                    Ae = {};
                  }, _e;
                }
                var _r = Fr();
                return _r;
              });
            }
          ),
          /***/
          928: (
            /***/
            function(T, x, M) {
              var P = M(322);
              function q(_, K, X) {
                var ie, ee;
                if (X = X || 0, !P(K))
                  return -1;
                if (Array.prototype.indexOf)
                  return Array.prototype.indexOf.call(K, _, X);
                for (ee = K.length, ie = X; X >= 0 && ie < ee; ie += 1)
                  if (K[ie] === _)
                    return ie;
                return -1;
              }
              T.exports = q;
            }
          ),
          /***/
          690: (
            /***/
            function(T, x, M) {
              var P = M(322), q = M(893), _ = M(956);
              function K(X, ie, ee) {
                P(X) ? q(X, ie, ee) : _(X, ie, ee);
              }
              T.exports = K;
            }
          ),
          /***/
          893: (
            /***/
            function(T) {
              function x(M, P, q) {
                var _ = 0, K = M.length;
                for (q = q || null; _ < K && P.call(q, M[_], _, M) !== !1; _ += 1)
                  ;
              }
              T.exports = x;
            }
          ),
          /***/
          956: (
            /***/
            function(T) {
              function x(M, P, q) {
                var _;
                q = q || null;
                for (_ in M)
                  if (M.hasOwnProperty(_) && P.call(q, M[_], _, M) === !1)
                    break;
              }
              T.exports = x;
            }
          ),
          /***/
          990: (
            /***/
            function(T, x, M) {
              var P = M(893);
              function q(_) {
                var K;
                try {
                  K = Array.prototype.slice.call(_);
                } catch {
                  K = [], P(_, function(ie) {
                    K.push(ie);
                  });
                }
                return K;
              }
              T.exports = q;
            }
          ),
          /***/
          755: (
            /***/
            function(T) {
              var x = "_feEventKey";
              function M(P, q) {
                var _ = P[x], K;
                return _ || (_ = P[x] = {}), K = _[q], K || (K = _[q] = []), K;
              }
              T.exports = M;
            }
          ),
          /***/
          349: (
            /***/
            function(T, x, M) {
              var P = M(758), q = M(690), _ = M(755);
              function K(ee, oe, ue) {
                if (P(oe)) {
                  q(oe.split(/\s+/g), function(pe) {
                    X(ee, pe, ue);
                  });
                  return;
                }
                q(oe, function(pe, Se) {
                  X(ee, Se, pe);
                });
              }
              function X(ee, oe, ue) {
                var pe = _(ee, oe), Se;
                ue ? (q(pe, function(Re, Me) {
                  return ue === Re.handler ? (ie(ee, oe, Re.wrappedHandler), Se = Me, !1) : !0;
                }), pe.splice(Se, 1)) : (q(pe, function(Re) {
                  ie(ee, oe, Re.wrappedHandler);
                }), pe.splice(0, pe.length));
              }
              function ie(ee, oe, ue) {
                "removeEventListener" in ee ? ee.removeEventListener(oe, ue) : "detachEvent" in ee && ee.detachEvent("on" + oe, ue);
              }
              T.exports = K;
            }
          ),
          /***/
          348: (
            /***/
            function(T, x, M) {
              var P = M(758), q = M(690), _ = M(755);
              function K(ee, oe, ue, pe) {
                if (P(oe)) {
                  q(oe.split(/\s+/g), function(Se) {
                    X(ee, Se, ue, pe);
                  });
                  return;
                }
                q(oe, function(Se, Re) {
                  X(ee, Re, Se, ue);
                });
              }
              function X(ee, oe, ue, pe) {
                function Se(Re) {
                  ue.call(pe || ee, Re || window.event);
                }
                "addEventListener" in ee ? ee.addEventListener(oe, Se) : "attachEvent" in ee && ee.attachEvent("on" + oe, Se), ie(ee, oe, ue, Se);
              }
              function ie(ee, oe, ue, pe) {
                var Se = _(ee, oe), Re = !1;
                q(Se, function(Me) {
                  return Me.handler === ue ? (Re = !0, !1) : !0;
                }), Re || Se.push({
                  handler: ue,
                  wrappedHandler: pe
                });
              }
              T.exports = K;
            }
          ),
          /***/
          24: (
            /***/
            function(T, x, M) {
              var P = M(322), q = M(929);
              function _(K, X) {
                if (X = P(X) ? X.join(" ") : X, X = X.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), q(K.className.baseVal)) {
                  K.className = X;
                  return;
                }
                K.className.baseVal = X;
              }
              T.exports = _;
            }
          ),
          /***/
          204: (
            /***/
            function(T, x, M) {
              var P = M(690), q = M(928), _ = M(902), K = M(24);
              function X(ie) {
                var ee = Array.prototype.slice.call(arguments, 1), oe = ie.classList, ue = [], pe;
                if (oe) {
                  P(ee, function(Se) {
                    ie.classList.add(Se);
                  });
                  return;
                }
                pe = _(ie), pe && (ee = [].concat(pe.split(/\s+/), ee)), P(ee, function(Se) {
                  q(Se, ue) < 0 && ue.push(Se);
                }), K(ie, ue);
              }
              T.exports = X;
            }
          ),
          /***/
          522: (
            /***/
            function(T, x, M) {
              var P = M(758), q = M(690);
              function _(K, X, ie) {
                var ee = K.style;
                if (P(X)) {
                  ee[X] = ie;
                  return;
                }
                q(X, function(oe, ue) {
                  ee[ue] = oe;
                });
              }
              T.exports = _;
            }
          ),
          /***/
          902: (
            /***/
            function(T, x, M) {
              var P = M(929);
              function q(_) {
                return !_ || !_.className ? "" : P(_.className.baseVal) ? _.className : _.className.baseVal;
              }
              T.exports = q;
            }
          ),
          /***/
          714: (
            /***/
            function(T, x, M) {
              var P = M(928), q = M(902);
              function _(K, X) {
                var ie;
                return K.classList ? K.classList.contains(X) : (ie = q(K).split(/\s+/), P(X, ie) > -1);
              }
              T.exports = _;
            }
          ),
          /***/
          471: (
            /***/
            function(T, x, M) {
              var P = M(928), q = M(990), _ = Element.prototype, K = _.matches || _.webkitMatchesSelector || _.mozMatchesSelector || _.msMatchesSelector || function(ie) {
                var ee = this.document || this.ownerDocument;
                return P(this, q(ee.querySelectorAll(ie))) > -1;
              };
              function X(ie, ee) {
                return K.call(ie, ee);
              }
              T.exports = X;
            }
          ),
          /***/
          462: (
            /***/
            function(T, x, M) {
              var P = M(893), q = M(928), _ = M(902), K = M(24);
              function X(ie) {
                var ee = Array.prototype.slice.call(arguments, 1), oe = ie.classList, ue, pe;
                if (oe) {
                  P(ee, function(Se) {
                    oe.remove(Se);
                  });
                  return;
                }
                ue = _(ie).split(/\s+/), pe = [], P(ue, function(Se) {
                  q(Se, ee) < 0 && pe.push(Se);
                }), K(ie, pe);
              }
              T.exports = X;
            }
          ),
          /***/
          969: (
            /***/
            function(T) {
              function x(M, P) {
                var q = Object.prototype.hasOwnProperty, _, K, X, ie;
                for (X = 1, ie = arguments.length; X < ie; X += 1) {
                  _ = arguments[X];
                  for (K in _)
                    q.call(_, K) && (M[K] = _[K]);
                }
                return M;
              }
              T.exports = x;
            }
          ),
          /***/
          254: (
            /***/
            function(T, x, M) {
              var P = M(956);
              function q(_, K) {
                var X = document.createElement("img"), ie = "";
                return P(K, function(ee, oe) {
                  ie += "&" + oe + "=" + ee;
                }), ie = ie.substring(1), X.src = _ + "?" + ie, X.style.display = "none", document.body.appendChild(X), document.body.removeChild(X), X;
              }
              T.exports = q;
            }
          ),
          /***/
          391: (
            /***/
            function(T, x, M) {
              var P = M(929), q = M(254), _ = 7 * 24 * 60 * 60 * 1e3;
              function K(ie) {
                var ee = (/* @__PURE__ */ new Date()).getTime();
                return ee - ie > _;
              }
              function X(ie, ee) {
                var oe = "https://www.google-analytics.com/collect", ue = location.hostname, pe = "event", Se = "use", Re = "TOAST UI " + ie + " for " + ue + ": Statistics", Me = window.localStorage.getItem(Re);
                !P(window.tui) && window.tui.usageStatistics === !1 || Me && !K(Me) || (window.localStorage.setItem(Re, (/* @__PURE__ */ new Date()).getTime()), setTimeout(function() {
                  (document.readyState === "interactive" || document.readyState === "complete") && q(oe, {
                    v: 1,
                    t: pe,
                    tid: ee,
                    cid: ue,
                    dp: ue,
                    dh: ie,
                    el: ie,
                    ec: Se
                  });
                }, 1e3));
              }
              T.exports = X;
            }
          ),
          /***/
          322: (
            /***/
            function(T) {
              function x(M) {
                return M instanceof Array;
              }
              T.exports = x;
            }
          ),
          /***/
          65: (
            /***/
            function(T, x, M) {
              var P = M(929), q = M(934);
              function _(K) {
                return !P(K) && !q(K);
              }
              T.exports = _;
            }
          ),
          /***/
          404: (
            /***/
            function(T, x, M) {
              var P = M(790);
              function q(_) {
                return !P(_);
              }
              T.exports = q;
            }
          ),
          /***/
          294: (
            /***/
            function(T) {
              function x(M) {
                return M instanceof Function;
              }
              T.exports = x;
            }
          ),
          /***/
          934: (
            /***/
            function(T) {
              function x(M) {
                return M === null;
              }
              T.exports = x;
            }
          ),
          /***/
          758: (
            /***/
            function(T) {
              function x(M) {
                return typeof M == "string" || M instanceof String;
              }
              T.exports = x;
            }
          ),
          /***/
          790: (
            /***/
            function(T, x, M) {
              var P = M(65);
              function q(_) {
                return P(_) && _ !== !1;
              }
              T.exports = q;
            }
          ),
          /***/
          929: (
            /***/
            function(T) {
              function x(M) {
                return M === void 0;
              }
              T.exports = x;
            }
          ),
          /***/
          479: (
            /***/
            function(T) {
              T.exports = r;
            }
          ),
          /***/
          481: (
            /***/
            function(T) {
              T.exports = n;
            }
          ),
          /***/
          43: (
            /***/
            function(T) {
              T.exports = a;
            }
          ),
          /***/
          814: (
            /***/
            function(T) {
              T.exports = i;
            }
          ),
          /***/
          311: (
            /***/
            function(T) {
              T.exports = o;
            }
          )
          /******/
        }, m = {};
        function y(T) {
          var x = m[T];
          if (x !== void 0)
            return x.exports;
          var M = m[T] = {
            /******/
            // no module.id needed
            /******/
            // no module.loaded needed
            /******/
            exports: {}
            /******/
          };
          return u[T].call(M.exports, M, M.exports, y), M.exports;
        }
        (function() {
          y.n = function(T) {
            var x = T && T.__esModule ? (
              /******/
              function() {
                return T.default;
              }
            ) : (
              /******/
              function() {
                return T;
              }
            );
            return y.d(x, { a: x }), x;
          };
        })(), function() {
          y.d = function(T, x) {
            for (var M in x)
              y.o(x, M) && !y.o(T, M) && Object.defineProperty(T, M, { enumerable: !0, get: x[M] });
          };
        }(), function() {
          y.g = function() {
            if (typeof globalThis == "object")
              return globalThis;
            try {
              return this || new Function("return this")();
            } catch {
              if (typeof window == "object")
                return window;
            }
          }();
        }(), function() {
          y.o = function(T, x) {
            return Object.prototype.hasOwnProperty.call(T, x);
          };
        }();
        var C = {};
        return function() {
          y.d(C, {
            default: function() {
              return (
                /* binding */
                J6
              );
            }
          });
          var T = function() {
            return T = Object.assign || function(c) {
              for (var p, k = 1, O = arguments.length; k < O; k++) {
                p = arguments[k];
                for (var U in p)
                  Object.prototype.hasOwnProperty.call(p, U) && (c[U] = p[U]);
              }
              return c;
            }, T.apply(this, arguments);
          };
          function x(f, c, p) {
            if (p || arguments.length === 2)
              for (var k = 0, O = c.length, U; k < O; k++)
                (U || !(k in c)) && (U || (U = Array.prototype.slice.call(c, 0, k)), U[k] = c[k]);
            return f.concat(U || Array.prototype.slice.call(c));
          }
          /*! *****************************************************************************
          	Copyright (c) Microsoft Corporation.
          
          	Permission to use, copy, modify, and/or distribute this software for any
          	purpose with or without fee is hereby granted.
          
          	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
          	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
          	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
          	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
          	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
          	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
          	PERFORMANCE OF THIS SOFTWARE.
          	***************************************************************************** */
          var M = function(f, c) {
            return M = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(p, k) {
              p.__proto__ = k;
            } || function(p, k) {
              for (var O in k)
                Object.prototype.hasOwnProperty.call(k, O) && (p[O] = k[O]);
            }, M(f, c);
          };
          function P(f, c) {
            if (typeof c != "function" && c !== null)
              throw new TypeError("Class extends value " + String(c) + " is not a constructor or null");
            M(f, c);
            function p() {
              this.constructor = f;
            }
            f.prototype = c === null ? Object.create(c) : (p.prototype = c.prototype, new p());
          }
          var q = function() {
            return q = Object.assign || function(c) {
              for (var p, k = 1, O = arguments.length; k < O; k++) {
                p = arguments[k];
                for (var U in p)
                  Object.prototype.hasOwnProperty.call(p, U) && (c[U] = p[U]);
              }
              return c;
            }, q.apply(this, arguments);
          };
          function _(f, c, p) {
            if (p || arguments.length === 2)
              for (var k = 0, O = c.length, U; k < O; k++)
                (U || !(k in c)) && (U || (U = Array.prototype.slice.call(c, 0, k)), U[k] = c[k]);
            return f.concat(U || Array.prototype.slice.call(c));
          }
          var K = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof y.g < "u" ? y.g : typeof self < "u" ? self : {}, X = {};
          function ie(f) {
            var c, p, k = X[f];
            if (k)
              return k;
            for (k = X[f] = [], c = 0; c < 128; c++)
              p = String.fromCharCode(c), /^[0-9a-z]$/i.test(p) ? k.push(p) : k.push("%" + ("0" + c.toString(16).toUpperCase()).slice(-2));
            for (c = 0; c < f.length; c++)
              k[f.charCodeAt(c)] = f[c];
            return k;
          }
          function ee(f, c, p) {
            var k, O, U, j, Q, ke = "";
            for (typeof c != "string" && (p = c, c = ee.defaultChars), typeof p > "u" && (p = !0), Q = ie(c), k = 0, O = f.length; k < O; k++) {
              if (U = f.charCodeAt(k), p && U === 37 && k + 2 < O && /^[0-9a-f]{2}$/i.test(f.slice(k + 1, k + 3))) {
                ke += f.slice(k, k + 3), k += 2;
                continue;
              }
              if (U < 128) {
                ke += Q[U];
                continue;
              }
              if (U >= 55296 && U <= 57343) {
                if (U >= 55296 && U <= 56319 && k + 1 < O && (j = f.charCodeAt(k + 1), j >= 56320 && j <= 57343)) {
                  ke += encodeURIComponent(f[k] + f[k + 1]), k++;
                  continue;
                }
                ke += "%EF%BF%BD";
                continue;
              }
              ke += encodeURIComponent(f[k]);
            }
            return ke;
          }
          ee.defaultChars = ";/?:@&=+$,-_.!~*'()#", ee.componentChars = "-_.!~*'()";
          var oe = ee, ue = {}, pe = {}, Se = "Á", Re = "á", Me = "Ă", ze = "ă", vt = "∾", je = "∿", rt = "∾̳", at = "Â", St = "â", pt = "´", Pt = "А", Ft = "а", Je = "Æ", Nt = "æ", yt = "⁡", At = "𝔄", lt = "𝔞", Rt = "À", he = "à", le = "ℵ", te = "ℵ", ae = "Α", Z = "α", de = "Ā", Te = "ā", Pe = "⨿", ft = "&", ht = "&", wt = "⩕", Ot = "⩓", Ut = "∧", Kt = "⩜", qr = "⩘", Jt = "⩚", _t = "∠", pr = "⦤", hr = "∠", Fr = "⦨", _r = "⦩", He = "⦪", _e = "⦫", Xe = "⦬", st = "⦭", Ct = "⦮", rr = "⦯", lr = "∡", Yt = "∟", Zt = "⊾", Rr = "⦝", Cr = "∢", Qt = "Å", Hr = "⍼", Tr = "Ą", nn = "ą", W = "𝔸", V = "𝕒", R = "⩯", D = "≈", I = "⩰", H = "≊", J = "≋", ve = "'", me = "⁡", be = "≈", Oe = "≊", Ye = "Å", We = "å", ut = "𝒜", ct = "𝒶", Ae = "≔", ne = "*", Ee = "≈", N = "≍", S = "Ã", v = "ã", b = "Ä", A = "ä", B = "∳", z = "⨑", G = "≌", fe = "϶", Ce = "‵", Ie = "∽", Le = "⋍", Fe = "∖", it = "⫧", Ht = "⊽", nr = "⌅", Mr = "⌆", Ur = "⌅", zr = "⎵", Rn = "⎶", $r = "≌", In = "Б", Ea = "б", Pn = "„", Cn = "∵", Tn = "∵", Sn = "∵", xa = "⦰", Aa = "϶", ua = "ℬ", ca = "ℬ", Ma = "Β", La = "β", Bn = "ℶ", mr = "≬", qn = "𝔅", En = "𝔟", Vr = "⋂", Fn = "◯", Ri = "⋃", fn = "⨀", vn = "⨁", Ii = "⨂", Oa = "⨆", fa = "★", Da = "▽", _n = "△", va = "⨄", ri = "⋁", jr = "⋀", ni = "⤍", ai = "⧫", da = "▪", Na = "▴", Hn = "▾", Gr = "◂", Ra = "▸", Ia = "␣", Pa = "▒", Ba = "░", Ze = "▓", se = "█", Ne = "=⃥", Ge = "≡⃥", Mt = "⫭", ar = "⌐", ir = "𝔹", Tt = "𝕓", qt = "⊥", Un = "⊥", ii = "⋈", Pi = "⧉", dn = "┐", Ks = "╕", Bi = "╖", qi = "╗", Js = "┌", Ys = "╒", oi = "╓", Zs = "╔", Fi = "─", pa = "═", Qs = "┬", Xs = "╤", el = "╥", tl = "╦", rl = "┴", nl = "╧", _i = "╨", co = "╩", al = "⊟", fo = "⊞", il = "⊠", vo = "┘", po = "╛", ol = "╜", qa = "╝", sl = "└", ha = "╘", ll = "╙", ul = "╚", Fa = "│", cl = "║", ho = "┼", mo = "╪", _a = "╫", fl = "╬", Ha = "┤", vl = "╡", zn = "╢", ma = "╣", $n = "├", Kr = "╞", gr = "╟", go = "╠", dl = "‵", yo = "˘", pl = "˘", bo = "¦", ko = "𝒷", si = "ℬ", Vn = "⁏", Hi = "∽", wo = "⋍", Ui = "⧅", hl = "\\", ml = "⟈", gl = "•", yl = "•", Co = "≎", To = "⪮", bl = "≏", kl = "≎", wl = "≏", Cl = "Ć", Tl = "ć", Sl = "⩄", So = "⩉", El = "⩋", xl = "∩", zi = "⋒", Al = "⩇", Ml = "⩀", Ll = "ⅅ", Ol = "∩︀", Dl = "⁁", Eo = "ˇ", xo = "ℭ", Ao = "⩍", Nl = "Č", Mo = "č", Rl = "Ç", Lo = "ç", s = "Ĉ", h = "ĉ", l = "∰", d = "⩌", g = "⩐", w = "Ċ", E = "ċ", L = "¸", F = "¸", $ = "⦲", Y = "¢", ce = "·", re = "·", ye = "𝔠", we = "ℭ", qe = "Ч", ot = "ч", De = "✓", Dt = "✓", mt = "Χ", Bt = "χ", bt = "ˆ", kt = "≗", Vt = "↺", Ir = "↻", Jr = "⊛", ur = "⊚", an = "⊝", Lr = "⊙", ga = "®", on = "Ⓢ", ya = "⊖", Yr = "⊕", Gt = "⊗", Oo = "○", Il = "⧃", li = "≗", Wn = "⨐", Do = "⫯", No = "⧂", og = "∲", sg = "”", lg = "’", ug = "♣", cg = "♣", fg = ":", vg = "∷", dg = "⩴", pg = "≔", hg = "≔", mg = ",", gg = "@", yg = "∁", bg = "∘", kg = "∁", wg = "ℂ", Cg = "≅", Tg = "⩭", Sg = "≡", Eg = "∮", xg = "∯", Ag = "∮", Mg = "𝕔", Lg = "ℂ", Og = "∐", Dg = "∐", Ng = "©", Rg = "©", Ig = "℗", Pg = "∳", Bg = "↵", qg = "✗", Fg = "⨯", _g = "𝒞", Hg = "𝒸", Ug = "⫏", zg = "⫑", $g = "⫐", Vg = "⫒", Wg = "⋯", jg = "⤸", Gg = "⤵", Kg = "⋞", Jg = "⋟", Yg = "↶", Zg = "⤽", Qg = "⩈", Xg = "⩆", ey = "≍", ty = "∪", ry = "⋓", ny = "⩊", ay = "⊍", iy = "⩅", oy = "∪︀", sy = "↷", ly = "⤼", uy = "⋞", cy = "⋟", fy = "⋎", vy = "⋏", dy = "¤", py = "↶", hy = "↷", my = "⋎", gy = "⋏", yy = "∲", by = "∱", ky = "⌭", wy = "†", Cy = "‡", Ty = "ℸ", Sy = "↓", Ey = "↡", xy = "⇓", Ay = "‐", My = "⫤", Ly = "⊣", Oy = "⤏", Dy = "˝", Ny = "Ď", Ry = "ď", Iy = "Д", Py = "д", By = "‡", qy = "⇊", Fy = "ⅅ", _y = "ⅆ", Hy = "⤑", Uy = "⩷", zy = "°", $y = "∇", Vy = "Δ", Wy = "δ", jy = "⦱", Gy = "⥿", Ky = "𝔇", Jy = "𝔡", Yy = "⥥", Zy = "⇃", Qy = "⇂", Xy = "´", eb = "˙", tb = "˝", rb = "`", nb = "˜", ab = "⋄", ib = "⋄", ob = "⋄", sb = "♦", lb = "♦", ub = "¨", cb = "ⅆ", fb = "ϝ", vb = "⋲", db = "÷", pb = "÷", hb = "⋇", mb = "⋇", gb = "Ђ", yb = "ђ", bb = "⌞", kb = "⌍", wb = "$", Cb = "𝔻", Tb = "𝕕", Sb = "¨", Eb = "˙", xb = "⃜", Ab = "≐", Mb = "≑", Lb = "≐", Ob = "∸", Db = "∔", Nb = "⊡", Rb = "⌆", Ib = "∯", Pb = "¨", Bb = "⇓", qb = "⇐", Fb = "⇔", _b = "⫤", Hb = "⟸", Ub = "⟺", zb = "⟹", $b = "⇒", Vb = "⊨", Wb = "⇑", jb = "⇕", Gb = "∥", Kb = "⤓", Jb = "↓", Yb = "↓", Zb = "⇓", Qb = "⇵", Xb = "̑", ek = "⇊", tk = "⇃", rk = "⇂", nk = "⥐", ak = "⥞", ik = "⥖", ok = "↽", sk = "⥟", lk = "⥗", uk = "⇁", ck = "↧", fk = "⊤", vk = "⤐", dk = "⌟", pk = "⌌", hk = "𝒟", mk = "𝒹", gk = "Ѕ", yk = "ѕ", bk = "⧶", kk = "Đ", wk = "đ", Ck = "⋱", Tk = "▿", Sk = "▾", Ek = "⇵", xk = "⥯", Ak = "⦦", Mk = "Џ", Lk = "џ", Ok = "⟿", Dk = "É", Nk = "é", Rk = "⩮", Ik = "Ě", Pk = "ě", Bk = "Ê", qk = "ê", Fk = "≖", _k = "≕", Hk = "Э", Uk = "э", zk = "⩷", $k = "Ė", Vk = "ė", Wk = "≑", jk = "ⅇ", Gk = "≒", Kk = "𝔈", Jk = "𝔢", Yk = "⪚", Zk = "È", Qk = "è", Xk = "⪖", ew = "⪘", tw = "⪙", rw = "∈", nw = "⏧", aw = "ℓ", iw = "⪕", ow = "⪗", sw = "Ē", lw = "ē", uw = "∅", cw = "∅", fw = "◻", vw = "∅", dw = "▫", pw = " ", hw = " ", mw = " ", gw = "Ŋ", yw = "ŋ", bw = " ", kw = "Ę", ww = "ę", Cw = "𝔼", Tw = "𝕖", Sw = "⋕", Ew = "⧣", xw = "⩱", Aw = "ε", Mw = "Ε", Lw = "ε", Ow = "ϵ", Dw = "≖", Nw = "≕", Rw = "≂", Iw = "⪖", Pw = "⪕", Bw = "⩵", qw = "=", Fw = "≂", _w = "≟", Hw = "⇌", Uw = "≡", zw = "⩸", $w = "⧥", Vw = "⥱", Ww = "≓", jw = "ℯ", Gw = "ℰ", Kw = "≐", Jw = "⩳", Yw = "≂", Zw = "Η", Qw = "η", Xw = "Ð", eC = "ð", tC = "Ë", rC = "ë", nC = "€", aC = "!", iC = "∃", oC = "∃", sC = "ℰ", lC = "ⅇ", uC = "ⅇ", cC = "≒", fC = "Ф", vC = "ф", dC = "♀", pC = "ﬃ", hC = "ﬀ", mC = "ﬄ", gC = "𝔉", yC = "𝔣", bC = "ﬁ", kC = "◼", wC = "▪", CC = "fj", TC = "♭", SC = "ﬂ", EC = "▱", xC = "ƒ", AC = "𝔽", MC = "𝕗", LC = "∀", OC = "∀", DC = "⋔", NC = "⫙", RC = "ℱ", IC = "⨍", PC = "½", BC = "⅓", qC = "¼", FC = "⅕", _C = "⅙", HC = "⅛", UC = "⅔", zC = "⅖", $C = "¾", VC = "⅗", WC = "⅜", jC = "⅘", GC = "⅚", KC = "⅝", JC = "⅞", YC = "⁄", ZC = "⌢", QC = "𝒻", XC = "ℱ", eT = "ǵ", tT = "Γ", rT = "γ", nT = "Ϝ", aT = "ϝ", iT = "⪆", oT = "Ğ", sT = "ğ", lT = "Ģ", uT = "Ĝ", cT = "ĝ", fT = "Г", vT = "г", dT = "Ġ", pT = "ġ", hT = "≥", mT = "≧", gT = "⪌", yT = "⋛", bT = "≥", kT = "≧", wT = "⩾", CT = "⪩", TT = "⩾", ST = "⪀", ET = "⪂", xT = "⪄", AT = "⋛︀", MT = "⪔", LT = "𝔊", OT = "𝔤", DT = "≫", NT = "⋙", RT = "⋙", IT = "ℷ", PT = "Ѓ", BT = "ѓ", qT = "⪥", FT = "≷", _T = "⪒", HT = "⪤", UT = "⪊", zT = "⪊", $T = "⪈", VT = "≩", WT = "⪈", jT = "≩", GT = "⋧", KT = "𝔾", JT = "𝕘", YT = "`", ZT = "≥", QT = "⋛", XT = "≧", e0 = "⪢", t0 = "≷", r0 = "⩾", n0 = "≳", a0 = "𝒢", i0 = "ℊ", o0 = "≳", s0 = "⪎", l0 = "⪐", u0 = "⪧", c0 = "⩺", f0 = ">", v0 = ">", d0 = "≫", p0 = "⋗", h0 = "⦕", m0 = "⩼", g0 = "⪆", y0 = "⥸", b0 = "⋗", k0 = "⋛", w0 = "⪌", C0 = "≷", T0 = "≳", S0 = "≩︀", E0 = "≩︀", x0 = "ˇ", A0 = " ", M0 = "½", L0 = "ℋ", O0 = "Ъ", D0 = "ъ", N0 = "⥈", R0 = "↔", I0 = "⇔", P0 = "↭", B0 = "^", q0 = "ℏ", F0 = "Ĥ", _0 = "ĥ", H0 = "♥", U0 = "♥", z0 = "…", $0 = "⊹", V0 = "𝔥", W0 = "ℌ", j0 = "ℋ", G0 = "⤥", K0 = "⤦", J0 = "⇿", Y0 = "∻", Z0 = "↩", Q0 = "↪", X0 = "𝕙", e1 = "ℍ", t1 = "―", r1 = "─", n1 = "𝒽", a1 = "ℋ", i1 = "ℏ", o1 = "Ħ", s1 = "ħ", l1 = "≎", u1 = "≏", c1 = "⁃", f1 = "‐", v1 = "Í", d1 = "í", p1 = "⁣", h1 = "Î", m1 = "î", g1 = "И", y1 = "и", b1 = "İ", k1 = "Е", w1 = "е", C1 = "¡", T1 = "⇔", S1 = "𝔦", E1 = "ℑ", x1 = "Ì", A1 = "ì", M1 = "ⅈ", L1 = "⨌", O1 = "∭", D1 = "⧜", N1 = "℩", R1 = "Ĳ", I1 = "ĳ", P1 = "Ī", B1 = "ī", q1 = "ℑ", F1 = "ⅈ", _1 = "ℐ", H1 = "ℑ", U1 = "ı", z1 = "ℑ", $1 = "⊷", V1 = "Ƶ", W1 = "⇒", j1 = "℅", G1 = "∞", K1 = "⧝", J1 = "ı", Y1 = "⊺", Z1 = "∫", Q1 = "∬", X1 = "ℤ", eS = "∫", tS = "⊺", rS = "⋂", nS = "⨗", aS = "⨼", iS = "⁣", oS = "⁢", sS = "Ё", lS = "ё", uS = "Į", cS = "į", fS = "𝕀", vS = "𝕚", dS = "Ι", pS = "ι", hS = "⨼", mS = "¿", gS = "𝒾", yS = "ℐ", bS = "∈", kS = "⋵", wS = "⋹", CS = "⋴", TS = "⋳", SS = "∈", ES = "⁢", xS = "Ĩ", AS = "ĩ", MS = "І", LS = "і", OS = "Ï", DS = "ï", NS = "Ĵ", RS = "ĵ", IS = "Й", PS = "й", BS = "𝔍", qS = "𝔧", FS = "ȷ", _S = "𝕁", HS = "𝕛", US = "𝒥", zS = "𝒿", $S = "Ј", VS = "ј", WS = "Є", jS = "є", GS = "Κ", KS = "κ", JS = "ϰ", YS = "Ķ", ZS = "ķ", QS = "К", XS = "к", eE = "𝔎", tE = "𝔨", rE = "ĸ", nE = "Х", aE = "х", iE = "Ќ", oE = "ќ", sE = "𝕂", lE = "𝕜", uE = "𝒦", cE = "𝓀", fE = "⇚", vE = "Ĺ", dE = "ĺ", pE = "⦴", hE = "ℒ", mE = "Λ", gE = "λ", yE = "⟨", bE = "⟪", kE = "⦑", wE = "⟨", CE = "⪅", TE = "ℒ", SE = "«", EE = "⇤", xE = "⤟", AE = "←", ME = "↞", LE = "⇐", OE = "⤝", DE = "↩", NE = "↫", RE = "⤹", IE = "⥳", PE = "↢", BE = "⤙", qE = "⤛", FE = "⪫", _E = "⪭", HE = "⪭︀", UE = "⤌", zE = "⤎", $E = "❲", VE = "{", WE = "[", jE = "⦋", GE = "⦏", KE = "⦍", JE = "Ľ", YE = "ľ", ZE = "Ļ", QE = "ļ", XE = "⌈", ex = "{", tx = "Л", rx = "л", nx = "⤶", ax = "“", ix = "„", ox = "⥧", sx = "⥋", lx = "↲", ux = "≤", cx = "≦", fx = "⟨", vx = "⇤", dx = "←", px = "←", hx = "⇐", mx = "⇆", gx = "↢", yx = "⌈", bx = "⟦", kx = "⥡", wx = "⥙", Cx = "⇃", Tx = "⌊", Sx = "↽", Ex = "↼", xx = "⇇", Ax = "↔", Mx = "↔", Lx = "⇔", Ox = "⇆", Dx = "⇋", Nx = "↭", Rx = "⥎", Ix = "↤", Px = "⊣", Bx = "⥚", qx = "⋋", Fx = "⧏", _x = "⊲", Hx = "⊴", Ux = "⥑", zx = "⥠", $x = "⥘", Vx = "↿", Wx = "⥒", jx = "↼", Gx = "⪋", Kx = "⋚", Jx = "≤", Yx = "≦", Zx = "⩽", Qx = "⪨", Xx = "⩽", eA = "⩿", tA = "⪁", rA = "⪃", nA = "⋚︀", aA = "⪓", iA = "⪅", oA = "⋖", sA = "⋚", lA = "⪋", uA = "⋚", cA = "≦", fA = "≶", vA = "≶", dA = "⪡", pA = "≲", hA = "⩽", mA = "≲", gA = "⥼", yA = "⌊", bA = "𝔏", kA = "𝔩", wA = "≶", CA = "⪑", TA = "⥢", SA = "↽", EA = "↼", xA = "⥪", AA = "▄", MA = "Љ", LA = "љ", OA = "⇇", DA = "≪", NA = "⋘", RA = "⌞", IA = "⇚", PA = "⥫", BA = "◺", qA = "Ŀ", FA = "ŀ", _A = "⎰", HA = "⎰", UA = "⪉", zA = "⪉", $A = "⪇", VA = "≨", WA = "⪇", jA = "≨", GA = "⋦", KA = "⟬", JA = "⇽", YA = "⟦", ZA = "⟵", QA = "⟵", XA = "⟸", eM = "⟷", tM = "⟷", rM = "⟺", nM = "⟼", aM = "⟶", iM = "⟶", oM = "⟹", sM = "↫", lM = "↬", uM = "⦅", cM = "𝕃", fM = "𝕝", vM = "⨭", dM = "⨴", pM = "∗", hM = "_", mM = "↙", gM = "↘", yM = "◊", bM = "◊", kM = "⧫", wM = "(", CM = "⦓", TM = "⇆", SM = "⌟", EM = "⇋", xM = "⥭", AM = "‎", MM = "⊿", LM = "‹", OM = "𝓁", DM = "ℒ", NM = "↰", RM = "↰", IM = "≲", PM = "⪍", BM = "⪏", qM = "[", FM = "‘", _M = "‚", HM = "Ł", UM = "ł", zM = "⪦", $M = "⩹", VM = "<", WM = "<", jM = "≪", GM = "⋖", KM = "⋋", JM = "⋉", YM = "⥶", ZM = "⩻", QM = "◃", XM = "⊴", eL = "◂", tL = "⦖", rL = "⥊", nL = "⥦", aL = "≨︀", iL = "≨︀", oL = "¯", sL = "♂", lL = "✠", uL = "✠", cL = "↦", fL = "↦", vL = "↧", dL = "↤", pL = "↥", hL = "▮", mL = "⨩", gL = "М", yL = "м", bL = "—", kL = "∺", wL = "∡", CL = " ", TL = "ℳ", SL = "𝔐", EL = "𝔪", xL = "℧", AL = "µ", ML = "*", LL = "⫰", OL = "∣", DL = "·", NL = "⊟", RL = "−", IL = "∸", PL = "⨪", BL = "∓", qL = "⫛", FL = "…", _L = "∓", HL = "⊧", UL = "𝕄", zL = "𝕞", $L = "∓", VL = "𝓂", WL = "ℳ", jL = "∾", GL = "Μ", KL = "μ", JL = "⊸", YL = "⊸", ZL = "∇", QL = "Ń", XL = "ń", eO = "∠⃒", tO = "≉", rO = "⩰̸", nO = "≋̸", aO = "ŉ", iO = "≉", oO = "♮", sO = "ℕ", lO = "♮", uO = " ", cO = "≎̸", fO = "≏̸", vO = "⩃", dO = "Ň", pO = "ň", hO = "Ņ", mO = "ņ", gO = "≇", yO = "⩭̸", bO = "⩂", kO = "Н", wO = "н", CO = "–", TO = "⤤", SO = "↗", EO = "⇗", xO = "↗", AO = "≠", MO = "≐̸", LO = "​", OO = "​", DO = "​", NO = "​", RO = "≢", IO = "⤨", PO = "≂̸", BO = "≫", qO = "≪", FO = `
`, _O = "∄", HO = "∄", UO = "𝔑", zO = "𝔫", $O = "≧̸", VO = "≱", WO = "≱", jO = "≧̸", GO = "⩾̸", KO = "⩾̸", JO = "⋙̸", YO = "≵", ZO = "≫⃒", QO = "≯", XO = "≯", eD = "≫̸", tD = "↮", rD = "⇎", nD = "⫲", aD = "∋", iD = "⋼", oD = "⋺", sD = "∋", lD = "Њ", uD = "њ", cD = "↚", fD = "⇍", vD = "‥", dD = "≦̸", pD = "≰", hD = "↚", mD = "⇍", gD = "↮", yD = "⇎", bD = "≰", kD = "≦̸", wD = "⩽̸", CD = "⩽̸", TD = "≮", SD = "⋘̸", ED = "≴", xD = "≪⃒", AD = "≮", MD = "⋪", LD = "⋬", OD = "≪̸", DD = "∤", ND = "⁠", RD = " ", ID = "𝕟", PD = "ℕ", BD = "⫬", qD = "¬", FD = "≢", _D = "≭", HD = "∦", UD = "∉", zD = "≠", $D = "≂̸", VD = "∄", WD = "≯", jD = "≱", GD = "≧̸", KD = "≫̸", JD = "≹", YD = "⩾̸", ZD = "≵", QD = "≎̸", XD = "≏̸", eN = "∉", tN = "⋵̸", rN = "⋹̸", nN = "∉", aN = "⋷", iN = "⋶", oN = "⧏̸", sN = "⋪", lN = "⋬", uN = "≮", cN = "≰", fN = "≸", vN = "≪̸", dN = "⩽̸", pN = "≴", hN = "⪢̸", mN = "⪡̸", gN = "∌", yN = "∌", bN = "⋾", kN = "⋽", wN = "⊀", CN = "⪯̸", TN = "⋠", SN = "∌", EN = "⧐̸", xN = "⋫", AN = "⋭", MN = "⊏̸", LN = "⋢", ON = "⊐̸", DN = "⋣", NN = "⊂⃒", RN = "⊈", IN = "⊁", PN = "⪰̸", BN = "⋡", qN = "≿̸", FN = "⊃⃒", _N = "⊉", HN = "≁", UN = "≄", zN = "≇", $N = "≉", VN = "∤", WN = "∦", jN = "∦", GN = "⫽⃥", KN = "∂̸", JN = "⨔", YN = "⊀", ZN = "⋠", QN = "⊀", XN = "⪯̸", eR = "⪯̸", tR = "⤳̸", rR = "↛", nR = "⇏", aR = "↝̸", iR = "↛", oR = "⇏", sR = "⋫", lR = "⋭", uR = "⊁", cR = "⋡", fR = "⪰̸", vR = "𝒩", dR = "𝓃", pR = "∤", hR = "∦", mR = "≁", gR = "≄", yR = "≄", bR = "∤", kR = "∦", wR = "⋢", CR = "⋣", TR = "⊄", SR = "⫅̸", ER = "⊈", xR = "⊂⃒", AR = "⊈", MR = "⫅̸", LR = "⊁", OR = "⪰̸", DR = "⊅", NR = "⫆̸", RR = "⊉", IR = "⊃⃒", PR = "⊉", BR = "⫆̸", qR = "≹", FR = "Ñ", _R = "ñ", HR = "≸", UR = "⋪", zR = "⋬", $R = "⋫", VR = "⋭", WR = "Ν", jR = "ν", GR = "#", KR = "№", JR = " ", YR = "≍⃒", ZR = "⊬", QR = "⊭", XR = "⊮", eI = "⊯", tI = "≥⃒", rI = ">⃒", nI = "⤄", aI = "⧞", iI = "⤂", oI = "≤⃒", sI = "<⃒", lI = "⊴⃒", uI = "⤃", cI = "⊵⃒", fI = "∼⃒", vI = "⤣", dI = "↖", pI = "⇖", hI = "↖", mI = "⤧", gI = "Ó", yI = "ó", bI = "⊛", kI = "Ô", wI = "ô", CI = "⊚", TI = "О", SI = "о", EI = "⊝", xI = "Ő", AI = "ő", MI = "⨸", LI = "⊙", OI = "⦼", DI = "Œ", NI = "œ", RI = "⦿", II = "𝔒", PI = "𝔬", BI = "˛", qI = "Ò", FI = "ò", _I = "⧁", HI = "⦵", UI = "Ω", zI = "∮", $I = "↺", VI = "⦾", WI = "⦻", jI = "‾", GI = "⧀", KI = "Ō", JI = "ō", YI = "Ω", ZI = "ω", QI = "Ο", XI = "ο", eP = "⦶", tP = "⊖", rP = "𝕆", nP = "𝕠", aP = "⦷", iP = "“", oP = "‘", sP = "⦹", lP = "⊕", uP = "↻", cP = "⩔", fP = "∨", vP = "⩝", dP = "ℴ", pP = "ℴ", hP = "ª", mP = "º", gP = "⊶", yP = "⩖", bP = "⩗", kP = "⩛", wP = "Ⓢ", CP = "𝒪", TP = "ℴ", SP = "Ø", EP = "ø", xP = "⊘", AP = "Õ", MP = "õ", LP = "⨶", OP = "⨷", DP = "⊗", NP = "Ö", RP = "ö", IP = "⌽", PP = "‾", BP = "⏞", qP = "⎴", FP = "⏜", _P = "¶", HP = "∥", UP = "∥", zP = "⫳", $P = "⫽", VP = "∂", WP = "∂", jP = "П", GP = "п", KP = "%", JP = ".", YP = "‰", ZP = "⊥", QP = "‱", XP = "𝔓", eB = "𝔭", tB = "Φ", rB = "φ", nB = "ϕ", aB = "ℳ", iB = "☎", oB = "Π", sB = "π", lB = "⋔", uB = "ϖ", cB = "ℏ", fB = "ℎ", vB = "ℏ", dB = "⨣", pB = "⊞", hB = "⨢", mB = "+", gB = "∔", yB = "⨥", bB = "⩲", kB = "±", wB = "±", CB = "⨦", TB = "⨧", SB = "±", EB = "ℌ", xB = "⨕", AB = "𝕡", MB = "ℙ", LB = "£", OB = "⪷", DB = "⪻", NB = "≺", RB = "≼", IB = "⪷", PB = "≺", BB = "≼", qB = "≺", FB = "⪯", _B = "≼", HB = "≾", UB = "⪯", zB = "⪹", $B = "⪵", VB = "⋨", WB = "⪯", jB = "⪳", GB = "≾", KB = "′", JB = "″", YB = "ℙ", ZB = "⪹", QB = "⪵", XB = "⋨", eq = "∏", tq = "∏", rq = "⌮", nq = "⌒", aq = "⌓", iq = "∝", oq = "∝", sq = "∷", lq = "∝", uq = "≾", cq = "⊰", fq = "𝒫", vq = "𝓅", dq = "Ψ", pq = "ψ", hq = " ", mq = "𝔔", gq = "𝔮", yq = "⨌", bq = "𝕢", kq = "ℚ", wq = "⁗", Cq = "𝒬", Tq = "𝓆", Sq = "ℍ", Eq = "⨖", xq = "?", Aq = "≟", Mq = '"', Lq = '"', Oq = "⇛", Dq = "∽̱", Nq = "Ŕ", Rq = "ŕ", Iq = "√", Pq = "⦳", Bq = "⟩", qq = "⟫", Fq = "⦒", _q = "⦥", Hq = "⟩", Uq = "»", zq = "⥵", $q = "⇥", Vq = "⤠", Wq = "⤳", jq = "→", Gq = "↠", Kq = "⇒", Jq = "⤞", Yq = "↪", Zq = "↬", Qq = "⥅", Xq = "⥴", eF = "⤖", tF = "↣", rF = "↝", nF = "⤚", aF = "⤜", iF = "∶", oF = "ℚ", sF = "⤍", lF = "⤏", uF = "⤐", cF = "❳", fF = "}", vF = "]", dF = "⦌", pF = "⦎", hF = "⦐", mF = "Ř", gF = "ř", yF = "Ŗ", bF = "ŗ", kF = "⌉", wF = "}", CF = "Р", TF = "р", SF = "⤷", EF = "⥩", xF = "”", AF = "”", MF = "↳", LF = "ℜ", OF = "ℛ", DF = "ℜ", NF = "ℝ", RF = "ℜ", IF = "▭", PF = "®", BF = "®", qF = "∋", FF = "⇋", _F = "⥯", HF = "⥽", UF = "⌋", zF = "𝔯", $F = "ℜ", VF = "⥤", WF = "⇁", jF = "⇀", GF = "⥬", KF = "Ρ", JF = "ρ", YF = "ϱ", ZF = "⟩", QF = "⇥", XF = "→", e_ = "→", t_ = "⇒", r_ = "⇄", n_ = "↣", a_ = "⌉", i_ = "⟧", o_ = "⥝", s_ = "⥕", l_ = "⇂", u_ = "⌋", c_ = "⇁", f_ = "⇀", v_ = "⇄", d_ = "⇌", p_ = "⇉", h_ = "↝", m_ = "↦", g_ = "⊢", y_ = "⥛", b_ = "⋌", k_ = "⧐", w_ = "⊳", C_ = "⊵", T_ = "⥏", S_ = "⥜", E_ = "⥔", x_ = "↾", A_ = "⥓", M_ = "⇀", L_ = "˚", O_ = "≓", D_ = "⇄", N_ = "⇌", R_ = "‏", I_ = "⎱", P_ = "⎱", B_ = "⫮", q_ = "⟭", F_ = "⇾", __ = "⟧", H_ = "⦆", U_ = "𝕣", z_ = "ℝ", $_ = "⨮", V_ = "⨵", W_ = "⥰", j_ = ")", G_ = "⦔", K_ = "⨒", J_ = "⇉", Y_ = "⇛", Z_ = "›", Q_ = "𝓇", X_ = "ℛ", eH = "↱", tH = "↱", rH = "]", nH = "’", aH = "’", iH = "⋌", oH = "⋊", sH = "▹", lH = "⊵", uH = "▸", cH = "⧎", fH = "⧴", vH = "⥨", dH = "℞", pH = "Ś", hH = "ś", mH = "‚", gH = "⪸", yH = "Š", bH = "š", kH = "⪼", wH = "≻", CH = "≽", TH = "⪰", SH = "⪴", EH = "Ş", xH = "ş", AH = "Ŝ", MH = "ŝ", LH = "⪺", OH = "⪶", DH = "⋩", NH = "⨓", RH = "≿", IH = "С", PH = "с", BH = "⊡", qH = "⋅", FH = "⩦", _H = "⤥", HH = "↘", UH = "⇘", zH = "↘", $H = "§", VH = ";", WH = "⤩", jH = "∖", GH = "∖", KH = "✶", JH = "𝔖", YH = "𝔰", ZH = "⌢", QH = "♯", XH = "Щ", eU = "щ", tU = "Ш", rU = "ш", nU = "↓", aU = "←", iU = "∣", oU = "∥", sU = "→", lU = "↑", uU = "­", cU = "Σ", fU = "σ", vU = "ς", dU = "ς", pU = "∼", hU = "⩪", mU = "≃", gU = "≃", yU = "⪞", bU = "⪠", kU = "⪝", wU = "⪟", CU = "≆", TU = "⨤", SU = "⥲", EU = "←", xU = "∘", AU = "∖", MU = "⨳", LU = "⧤", OU = "∣", DU = "⌣", NU = "⪪", RU = "⪬", IU = "⪬︀", PU = "Ь", BU = "ь", qU = "⌿", FU = "⧄", _U = "/", HU = "𝕊", UU = "𝕤", zU = "♠", $U = "♠", VU = "∥", WU = "⊓", jU = "⊓︀", GU = "⊔", KU = "⊔︀", JU = "√", YU = "⊏", ZU = "⊑", QU = "⊏", XU = "⊑", ez = "⊐", tz = "⊒", rz = "⊐", nz = "⊒", az = "□", iz = "□", oz = "⊓", sz = "⊏", lz = "⊑", uz = "⊐", cz = "⊒", fz = "⊔", vz = "▪", dz = "□", pz = "▪", hz = "→", mz = "𝒮", gz = "𝓈", yz = "∖", bz = "⌣", kz = "⋆", wz = "⋆", Cz = "☆", Tz = "★", Sz = "ϵ", Ez = "ϕ", xz = "¯", Az = "⊂", Mz = "⋐", Lz = "⪽", Oz = "⫅", Dz = "⊆", Nz = "⫃", Rz = "⫁", Iz = "⫋", Pz = "⊊", Bz = "⪿", qz = "⥹", Fz = "⊂", _z = "⋐", Hz = "⊆", Uz = "⫅", zz = "⊆", $z = "⊊", Vz = "⫋", Wz = "⫇", jz = "⫕", Gz = "⫓", Kz = "⪸", Jz = "≻", Yz = "≽", Zz = "≻", Qz = "⪰", Xz = "≽", e$ = "≿", t$ = "⪰", r$ = "⪺", n$ = "⪶", a$ = "⋩", i$ = "≿", o$ = "∋", s$ = "∑", l$ = "∑", u$ = "♪", c$ = "¹", f$ = "²", v$ = "³", d$ = "⊃", p$ = "⋑", h$ = "⪾", m$ = "⫘", g$ = "⫆", y$ = "⊇", b$ = "⫄", k$ = "⊃", w$ = "⊇", C$ = "⟉", T$ = "⫗", S$ = "⥻", E$ = "⫂", x$ = "⫌", A$ = "⊋", M$ = "⫀", L$ = "⊃", O$ = "⋑", D$ = "⊇", N$ = "⫆", R$ = "⊋", I$ = "⫌", P$ = "⫈", B$ = "⫔", q$ = "⫖", F$ = "⤦", _$ = "↙", H$ = "⇙", U$ = "↙", z$ = "⤪", $$ = "ß", V$ = "	", W$ = "⌖", j$ = "Τ", G$ = "τ", K$ = "⎴", J$ = "Ť", Y$ = "ť", Z$ = "Ţ", Q$ = "ţ", X$ = "Т", e2 = "т", t2 = "⃛", r2 = "⌕", n2 = "𝔗", a2 = "𝔱", i2 = "∴", o2 = "∴", s2 = "∴", l2 = "Θ", u2 = "θ", c2 = "ϑ", f2 = "ϑ", v2 = "≈", d2 = "∼", p2 = "  ", h2 = " ", m2 = " ", g2 = "≈", y2 = "∼", b2 = "Þ", k2 = "þ", w2 = "˜", C2 = "∼", T2 = "≃", S2 = "≅", E2 = "≈", x2 = "⨱", A2 = "⊠", M2 = "×", L2 = "⨰", O2 = "∭", D2 = "⤨", N2 = "⌶", R2 = "⫱", I2 = "⊤", P2 = "𝕋", B2 = "𝕥", q2 = "⫚", F2 = "⤩", _2 = "‴", H2 = "™", U2 = "™", z2 = "▵", $2 = "▿", V2 = "◃", W2 = "⊴", j2 = "≜", G2 = "▹", K2 = "⊵", J2 = "◬", Y2 = "≜", Z2 = "⨺", Q2 = "⃛", X2 = "⨹", eV = "⧍", tV = "⨻", rV = "⏢", nV = "𝒯", aV = "𝓉", iV = "Ц", oV = "ц", sV = "Ћ", lV = "ћ", uV = "Ŧ", cV = "ŧ", fV = "≬", vV = "↞", dV = "↠", pV = "Ú", hV = "ú", mV = "↑", gV = "↟", yV = "⇑", bV = "⥉", kV = "Ў", wV = "ў", CV = "Ŭ", TV = "ŭ", SV = "Û", EV = "û", xV = "У", AV = "у", MV = "⇅", LV = "Ű", OV = "ű", DV = "⥮", NV = "⥾", RV = "𝔘", IV = "𝔲", PV = "Ù", BV = "ù", qV = "⥣", FV = "↿", _V = "↾", HV = "▀", UV = "⌜", zV = "⌜", $V = "⌏", VV = "◸", WV = "Ū", jV = "ū", GV = "¨", KV = "_", JV = "⏟", YV = "⎵", ZV = "⏝", QV = "⋃", XV = "⊎", e3 = "Ų", t3 = "ų", r3 = "𝕌", n3 = "𝕦", a3 = "⤒", i3 = "↑", o3 = "↑", s3 = "⇑", l3 = "⇅", u3 = "↕", c3 = "↕", f3 = "⇕", v3 = "⥮", d3 = "↿", p3 = "↾", h3 = "⊎", m3 = "↖", g3 = "↗", y3 = "υ", b3 = "ϒ", k3 = "ϒ", w3 = "Υ", C3 = "υ", T3 = "↥", S3 = "⊥", E3 = "⇈", x3 = "⌝", A3 = "⌝", M3 = "⌎", L3 = "Ů", O3 = "ů", D3 = "◹", N3 = "𝒰", R3 = "𝓊", I3 = "⋰", P3 = "Ũ", B3 = "ũ", q3 = "▵", F3 = "▴", _3 = "⇈", H3 = "Ü", U3 = "ü", z3 = "⦧", $3 = "⦜", V3 = "ϵ", W3 = "ϰ", j3 = "∅", G3 = "ϕ", K3 = "ϖ", J3 = "∝", Y3 = "↕", Z3 = "⇕", Q3 = "ϱ", X3 = "ς", eW = "⊊︀", tW = "⫋︀", rW = "⊋︀", nW = "⫌︀", aW = "ϑ", iW = "⊲", oW = "⊳", sW = "⫨", lW = "⫫", uW = "⫩", cW = "В", fW = "в", vW = "⊢", dW = "⊨", pW = "⊩", hW = "⊫", mW = "⫦", gW = "⊻", yW = "∨", bW = "⋁", kW = "≚", wW = "⋮", CW = "|", TW = "‖", SW = "|", EW = "‖", xW = "∣", AW = "|", MW = "❘", LW = "≀", OW = " ", DW = "𝔙", NW = "𝔳", RW = "⊲", IW = "⊂⃒", PW = "⊃⃒", BW = "𝕍", qW = "𝕧", FW = "∝", _W = "⊳", HW = "𝒱", UW = "𝓋", zW = "⫋︀", $W = "⊊︀", VW = "⫌︀", WW = "⊋︀", jW = "⊪", GW = "⦚", KW = "Ŵ", JW = "ŵ", YW = "⩟", ZW = "∧", QW = "⋀", XW = "≙", ej = "℘", tj = "𝔚", rj = "𝔴", nj = "𝕎", aj = "𝕨", ij = "℘", oj = "≀", sj = "≀", lj = "𝒲", uj = "𝓌", cj = "⋂", fj = "◯", vj = "⋃", dj = "▽", pj = "𝔛", hj = "𝔵", mj = "⟷", gj = "⟺", yj = "Ξ", bj = "ξ", kj = "⟵", wj = "⟸", Cj = "⟼", Tj = "⋻", Sj = "⨀", Ej = "𝕏", xj = "𝕩", Aj = "⨁", Mj = "⨂", Lj = "⟶", Oj = "⟹", Dj = "𝒳", Nj = "𝓍", Rj = "⨆", Ij = "⨄", Pj = "△", Bj = "⋁", qj = "⋀", Fj = "Ý", _j = "ý", Hj = "Я", Uj = "я", zj = "Ŷ", $j = "ŷ", Vj = "Ы", Wj = "ы", jj = "¥", Gj = "𝔜", Kj = "𝔶", Jj = "Ї", Yj = "ї", Zj = "𝕐", Qj = "𝕪", Xj = "𝒴", eG = "𝓎", tG = "Ю", rG = "ю", nG = "ÿ", aG = "Ÿ", iG = "Ź", oG = "ź", sG = "Ž", lG = "ž", uG = "З", cG = "з", fG = "Ż", vG = "ż", dG = "ℨ", pG = "​", hG = "Ζ", mG = "ζ", gG = "𝔷", yG = "ℨ", bG = "Ж", kG = "ж", wG = "⇝", CG = "𝕫", TG = "ℤ", SG = "𝒵", EG = "𝓏", xG = "‍", AG = "‌", Yc = {
            Aacute: Se,
            aacute: Re,
            Abreve: Me,
            abreve: ze,
            ac: vt,
            acd: je,
            acE: rt,
            Acirc: at,
            acirc: St,
            acute: pt,
            Acy: Pt,
            acy: Ft,
            AElig: Je,
            aelig: Nt,
            af: yt,
            Afr: At,
            afr: lt,
            Agrave: Rt,
            agrave: he,
            alefsym: le,
            aleph: te,
            Alpha: ae,
            alpha: Z,
            Amacr: de,
            amacr: Te,
            amalg: Pe,
            amp: ft,
            AMP: ht,
            andand: wt,
            And: Ot,
            and: Ut,
            andd: Kt,
            andslope: qr,
            andv: Jt,
            ang: _t,
            ange: pr,
            angle: hr,
            angmsdaa: Fr,
            angmsdab: _r,
            angmsdac: He,
            angmsdad: _e,
            angmsdae: Xe,
            angmsdaf: st,
            angmsdag: Ct,
            angmsdah: rr,
            angmsd: lr,
            angrt: Yt,
            angrtvb: Zt,
            angrtvbd: Rr,
            angsph: Cr,
            angst: Qt,
            angzarr: Hr,
            Aogon: Tr,
            aogon: nn,
            Aopf: W,
            aopf: V,
            apacir: R,
            ap: D,
            apE: I,
            ape: H,
            apid: J,
            apos: ve,
            ApplyFunction: me,
            approx: be,
            approxeq: Oe,
            Aring: Ye,
            aring: We,
            Ascr: ut,
            ascr: ct,
            Assign: Ae,
            ast: ne,
            asymp: Ee,
            asympeq: N,
            Atilde: S,
            atilde: v,
            Auml: b,
            auml: A,
            awconint: B,
            awint: z,
            backcong: G,
            backepsilon: fe,
            backprime: Ce,
            backsim: Ie,
            backsimeq: Le,
            Backslash: Fe,
            Barv: it,
            barvee: Ht,
            barwed: nr,
            Barwed: Mr,
            barwedge: Ur,
            bbrk: zr,
            bbrktbrk: Rn,
            bcong: $r,
            Bcy: In,
            bcy: Ea,
            bdquo: Pn,
            becaus: Cn,
            because: Tn,
            Because: Sn,
            bemptyv: xa,
            bepsi: Aa,
            bernou: ua,
            Bernoullis: ca,
            Beta: Ma,
            beta: La,
            beth: Bn,
            between: mr,
            Bfr: qn,
            bfr: En,
            bigcap: Vr,
            bigcirc: Fn,
            bigcup: Ri,
            bigodot: fn,
            bigoplus: vn,
            bigotimes: Ii,
            bigsqcup: Oa,
            bigstar: fa,
            bigtriangledown: Da,
            bigtriangleup: _n,
            biguplus: va,
            bigvee: ri,
            bigwedge: jr,
            bkarow: ni,
            blacklozenge: ai,
            blacksquare: da,
            blacktriangle: Na,
            blacktriangledown: Hn,
            blacktriangleleft: Gr,
            blacktriangleright: Ra,
            blank: Ia,
            blk12: Pa,
            blk14: Ba,
            blk34: Ze,
            block: se,
            bne: Ne,
            bnequiv: Ge,
            bNot: Mt,
            bnot: ar,
            Bopf: ir,
            bopf: Tt,
            bot: qt,
            bottom: Un,
            bowtie: ii,
            boxbox: Pi,
            boxdl: dn,
            boxdL: Ks,
            boxDl: Bi,
            boxDL: qi,
            boxdr: Js,
            boxdR: Ys,
            boxDr: oi,
            boxDR: Zs,
            boxh: Fi,
            boxH: pa,
            boxhd: Qs,
            boxHd: Xs,
            boxhD: el,
            boxHD: tl,
            boxhu: rl,
            boxHu: nl,
            boxhU: _i,
            boxHU: co,
            boxminus: al,
            boxplus: fo,
            boxtimes: il,
            boxul: vo,
            boxuL: po,
            boxUl: ol,
            boxUL: qa,
            boxur: sl,
            boxuR: ha,
            boxUr: ll,
            boxUR: ul,
            boxv: Fa,
            boxV: cl,
            boxvh: ho,
            boxvH: mo,
            boxVh: _a,
            boxVH: fl,
            boxvl: Ha,
            boxvL: vl,
            boxVl: zn,
            boxVL: ma,
            boxvr: $n,
            boxvR: Kr,
            boxVr: gr,
            boxVR: go,
            bprime: dl,
            breve: yo,
            Breve: pl,
            brvbar: bo,
            bscr: ko,
            Bscr: si,
            bsemi: Vn,
            bsim: Hi,
            bsime: wo,
            bsolb: Ui,
            bsol: hl,
            bsolhsub: ml,
            bull: gl,
            bullet: yl,
            bump: Co,
            bumpE: To,
            bumpe: bl,
            Bumpeq: kl,
            bumpeq: wl,
            Cacute: Cl,
            cacute: Tl,
            capand: Sl,
            capbrcup: So,
            capcap: El,
            cap: xl,
            Cap: zi,
            capcup: Al,
            capdot: Ml,
            CapitalDifferentialD: Ll,
            caps: Ol,
            caret: Dl,
            caron: Eo,
            Cayleys: xo,
            ccaps: Ao,
            Ccaron: Nl,
            ccaron: Mo,
            Ccedil: Rl,
            ccedil: Lo,
            Ccirc: s,
            ccirc: h,
            Cconint: l,
            ccups: d,
            ccupssm: g,
            Cdot: w,
            cdot: E,
            cedil: L,
            Cedilla: F,
            cemptyv: $,
            cent: Y,
            centerdot: ce,
            CenterDot: re,
            cfr: ye,
            Cfr: we,
            CHcy: qe,
            chcy: ot,
            check: De,
            checkmark: Dt,
            Chi: mt,
            chi: Bt,
            circ: bt,
            circeq: kt,
            circlearrowleft: Vt,
            circlearrowright: Ir,
            circledast: Jr,
            circledcirc: ur,
            circleddash: an,
            CircleDot: Lr,
            circledR: ga,
            circledS: on,
            CircleMinus: ya,
            CirclePlus: Yr,
            CircleTimes: Gt,
            cir: Oo,
            cirE: Il,
            cire: li,
            cirfnint: Wn,
            cirmid: Do,
            cirscir: No,
            ClockwiseContourIntegral: og,
            CloseCurlyDoubleQuote: sg,
            CloseCurlyQuote: lg,
            clubs: ug,
            clubsuit: cg,
            colon: fg,
            Colon: vg,
            Colone: dg,
            colone: pg,
            coloneq: hg,
            comma: mg,
            commat: gg,
            comp: yg,
            compfn: bg,
            complement: kg,
            complexes: wg,
            cong: Cg,
            congdot: Tg,
            Congruent: Sg,
            conint: Eg,
            Conint: xg,
            ContourIntegral: Ag,
            copf: Mg,
            Copf: Lg,
            coprod: Og,
            Coproduct: Dg,
            copy: Ng,
            COPY: Rg,
            copysr: Ig,
            CounterClockwiseContourIntegral: Pg,
            crarr: Bg,
            cross: qg,
            Cross: Fg,
            Cscr: _g,
            cscr: Hg,
            csub: Ug,
            csube: zg,
            csup: $g,
            csupe: Vg,
            ctdot: Wg,
            cudarrl: jg,
            cudarrr: Gg,
            cuepr: Kg,
            cuesc: Jg,
            cularr: Yg,
            cularrp: Zg,
            cupbrcap: Qg,
            cupcap: Xg,
            CupCap: ey,
            cup: ty,
            Cup: ry,
            cupcup: ny,
            cupdot: ay,
            cupor: iy,
            cups: oy,
            curarr: sy,
            curarrm: ly,
            curlyeqprec: uy,
            curlyeqsucc: cy,
            curlyvee: fy,
            curlywedge: vy,
            curren: dy,
            curvearrowleft: py,
            curvearrowright: hy,
            cuvee: my,
            cuwed: gy,
            cwconint: yy,
            cwint: by,
            cylcty: ky,
            dagger: wy,
            Dagger: Cy,
            daleth: Ty,
            darr: Sy,
            Darr: Ey,
            dArr: xy,
            dash: Ay,
            Dashv: My,
            dashv: Ly,
            dbkarow: Oy,
            dblac: Dy,
            Dcaron: Ny,
            dcaron: Ry,
            Dcy: Iy,
            dcy: Py,
            ddagger: By,
            ddarr: qy,
            DD: Fy,
            dd: _y,
            DDotrahd: Hy,
            ddotseq: Uy,
            deg: zy,
            Del: $y,
            Delta: Vy,
            delta: Wy,
            demptyv: jy,
            dfisht: Gy,
            Dfr: Ky,
            dfr: Jy,
            dHar: Yy,
            dharl: Zy,
            dharr: Qy,
            DiacriticalAcute: Xy,
            DiacriticalDot: eb,
            DiacriticalDoubleAcute: tb,
            DiacriticalGrave: rb,
            DiacriticalTilde: nb,
            diam: ab,
            diamond: ib,
            Diamond: ob,
            diamondsuit: sb,
            diams: lb,
            die: ub,
            DifferentialD: cb,
            digamma: fb,
            disin: vb,
            div: db,
            divide: pb,
            divideontimes: hb,
            divonx: mb,
            DJcy: gb,
            djcy: yb,
            dlcorn: bb,
            dlcrop: kb,
            dollar: wb,
            Dopf: Cb,
            dopf: Tb,
            Dot: Sb,
            dot: Eb,
            DotDot: xb,
            doteq: Ab,
            doteqdot: Mb,
            DotEqual: Lb,
            dotminus: Ob,
            dotplus: Db,
            dotsquare: Nb,
            doublebarwedge: Rb,
            DoubleContourIntegral: Ib,
            DoubleDot: Pb,
            DoubleDownArrow: Bb,
            DoubleLeftArrow: qb,
            DoubleLeftRightArrow: Fb,
            DoubleLeftTee: _b,
            DoubleLongLeftArrow: Hb,
            DoubleLongLeftRightArrow: Ub,
            DoubleLongRightArrow: zb,
            DoubleRightArrow: $b,
            DoubleRightTee: Vb,
            DoubleUpArrow: Wb,
            DoubleUpDownArrow: jb,
            DoubleVerticalBar: Gb,
            DownArrowBar: Kb,
            downarrow: Jb,
            DownArrow: Yb,
            Downarrow: Zb,
            DownArrowUpArrow: Qb,
            DownBreve: Xb,
            downdownarrows: ek,
            downharpoonleft: tk,
            downharpoonright: rk,
            DownLeftRightVector: nk,
            DownLeftTeeVector: ak,
            DownLeftVectorBar: ik,
            DownLeftVector: ok,
            DownRightTeeVector: sk,
            DownRightVectorBar: lk,
            DownRightVector: uk,
            DownTeeArrow: ck,
            DownTee: fk,
            drbkarow: vk,
            drcorn: dk,
            drcrop: pk,
            Dscr: hk,
            dscr: mk,
            DScy: gk,
            dscy: yk,
            dsol: bk,
            Dstrok: kk,
            dstrok: wk,
            dtdot: Ck,
            dtri: Tk,
            dtrif: Sk,
            duarr: Ek,
            duhar: xk,
            dwangle: Ak,
            DZcy: Mk,
            dzcy: Lk,
            dzigrarr: Ok,
            Eacute: Dk,
            eacute: Nk,
            easter: Rk,
            Ecaron: Ik,
            ecaron: Pk,
            Ecirc: Bk,
            ecirc: qk,
            ecir: Fk,
            ecolon: _k,
            Ecy: Hk,
            ecy: Uk,
            eDDot: zk,
            Edot: $k,
            edot: Vk,
            eDot: Wk,
            ee: jk,
            efDot: Gk,
            Efr: Kk,
            efr: Jk,
            eg: Yk,
            Egrave: Zk,
            egrave: Qk,
            egs: Xk,
            egsdot: ew,
            el: tw,
            Element: rw,
            elinters: nw,
            ell: aw,
            els: iw,
            elsdot: ow,
            Emacr: sw,
            emacr: lw,
            empty: uw,
            emptyset: cw,
            EmptySmallSquare: fw,
            emptyv: vw,
            EmptyVerySmallSquare: dw,
            emsp13: pw,
            emsp14: hw,
            emsp: mw,
            ENG: gw,
            eng: yw,
            ensp: bw,
            Eogon: kw,
            eogon: ww,
            Eopf: Cw,
            eopf: Tw,
            epar: Sw,
            eparsl: Ew,
            eplus: xw,
            epsi: Aw,
            Epsilon: Mw,
            epsilon: Lw,
            epsiv: Ow,
            eqcirc: Dw,
            eqcolon: Nw,
            eqsim: Rw,
            eqslantgtr: Iw,
            eqslantless: Pw,
            Equal: Bw,
            equals: qw,
            EqualTilde: Fw,
            equest: _w,
            Equilibrium: Hw,
            equiv: Uw,
            equivDD: zw,
            eqvparsl: $w,
            erarr: Vw,
            erDot: Ww,
            escr: jw,
            Escr: Gw,
            esdot: Kw,
            Esim: Jw,
            esim: Yw,
            Eta: Zw,
            eta: Qw,
            ETH: Xw,
            eth: eC,
            Euml: tC,
            euml: rC,
            euro: nC,
            excl: aC,
            exist: iC,
            Exists: oC,
            expectation: sC,
            exponentiale: lC,
            ExponentialE: uC,
            fallingdotseq: cC,
            Fcy: fC,
            fcy: vC,
            female: dC,
            ffilig: pC,
            fflig: hC,
            ffllig: mC,
            Ffr: gC,
            ffr: yC,
            filig: bC,
            FilledSmallSquare: kC,
            FilledVerySmallSquare: wC,
            fjlig: CC,
            flat: TC,
            fllig: SC,
            fltns: EC,
            fnof: xC,
            Fopf: AC,
            fopf: MC,
            forall: LC,
            ForAll: OC,
            fork: DC,
            forkv: NC,
            Fouriertrf: RC,
            fpartint: IC,
            frac12: PC,
            frac13: BC,
            frac14: qC,
            frac15: FC,
            frac16: _C,
            frac18: HC,
            frac23: UC,
            frac25: zC,
            frac34: $C,
            frac35: VC,
            frac38: WC,
            frac45: jC,
            frac56: GC,
            frac58: KC,
            frac78: JC,
            frasl: YC,
            frown: ZC,
            fscr: QC,
            Fscr: XC,
            gacute: eT,
            Gamma: tT,
            gamma: rT,
            Gammad: nT,
            gammad: aT,
            gap: iT,
            Gbreve: oT,
            gbreve: sT,
            Gcedil: lT,
            Gcirc: uT,
            gcirc: cT,
            Gcy: fT,
            gcy: vT,
            Gdot: dT,
            gdot: pT,
            ge: hT,
            gE: mT,
            gEl: gT,
            gel: yT,
            geq: bT,
            geqq: kT,
            geqslant: wT,
            gescc: CT,
            ges: TT,
            gesdot: ST,
            gesdoto: ET,
            gesdotol: xT,
            gesl: AT,
            gesles: MT,
            Gfr: LT,
            gfr: OT,
            gg: DT,
            Gg: NT,
            ggg: RT,
            gimel: IT,
            GJcy: PT,
            gjcy: BT,
            gla: qT,
            gl: FT,
            glE: _T,
            glj: HT,
            gnap: UT,
            gnapprox: zT,
            gne: $T,
            gnE: VT,
            gneq: WT,
            gneqq: jT,
            gnsim: GT,
            Gopf: KT,
            gopf: JT,
            grave: YT,
            GreaterEqual: ZT,
            GreaterEqualLess: QT,
            GreaterFullEqual: XT,
            GreaterGreater: e0,
            GreaterLess: t0,
            GreaterSlantEqual: r0,
            GreaterTilde: n0,
            Gscr: a0,
            gscr: i0,
            gsim: o0,
            gsime: s0,
            gsiml: l0,
            gtcc: u0,
            gtcir: c0,
            gt: f0,
            GT: v0,
            Gt: d0,
            gtdot: p0,
            gtlPar: h0,
            gtquest: m0,
            gtrapprox: g0,
            gtrarr: y0,
            gtrdot: b0,
            gtreqless: k0,
            gtreqqless: w0,
            gtrless: C0,
            gtrsim: T0,
            gvertneqq: S0,
            gvnE: E0,
            Hacek: x0,
            hairsp: A0,
            half: M0,
            hamilt: L0,
            HARDcy: O0,
            hardcy: D0,
            harrcir: N0,
            harr: R0,
            hArr: I0,
            harrw: P0,
            Hat: B0,
            hbar: q0,
            Hcirc: F0,
            hcirc: _0,
            hearts: H0,
            heartsuit: U0,
            hellip: z0,
            hercon: $0,
            hfr: V0,
            Hfr: W0,
            HilbertSpace: j0,
            hksearow: G0,
            hkswarow: K0,
            hoarr: J0,
            homtht: Y0,
            hookleftarrow: Z0,
            hookrightarrow: Q0,
            hopf: X0,
            Hopf: e1,
            horbar: t1,
            HorizontalLine: r1,
            hscr: n1,
            Hscr: a1,
            hslash: i1,
            Hstrok: o1,
            hstrok: s1,
            HumpDownHump: l1,
            HumpEqual: u1,
            hybull: c1,
            hyphen: f1,
            Iacute: v1,
            iacute: d1,
            ic: p1,
            Icirc: h1,
            icirc: m1,
            Icy: g1,
            icy: y1,
            Idot: b1,
            IEcy: k1,
            iecy: w1,
            iexcl: C1,
            iff: T1,
            ifr: S1,
            Ifr: E1,
            Igrave: x1,
            igrave: A1,
            ii: M1,
            iiiint: L1,
            iiint: O1,
            iinfin: D1,
            iiota: N1,
            IJlig: R1,
            ijlig: I1,
            Imacr: P1,
            imacr: B1,
            image: q1,
            ImaginaryI: F1,
            imagline: _1,
            imagpart: H1,
            imath: U1,
            Im: z1,
            imof: $1,
            imped: V1,
            Implies: W1,
            incare: j1,
            in: "∈",
            infin: G1,
            infintie: K1,
            inodot: J1,
            intcal: Y1,
            int: Z1,
            Int: Q1,
            integers: X1,
            Integral: eS,
            intercal: tS,
            Intersection: rS,
            intlarhk: nS,
            intprod: aS,
            InvisibleComma: iS,
            InvisibleTimes: oS,
            IOcy: sS,
            iocy: lS,
            Iogon: uS,
            iogon: cS,
            Iopf: fS,
            iopf: vS,
            Iota: dS,
            iota: pS,
            iprod: hS,
            iquest: mS,
            iscr: gS,
            Iscr: yS,
            isin: bS,
            isindot: kS,
            isinE: wS,
            isins: CS,
            isinsv: TS,
            isinv: SS,
            it: ES,
            Itilde: xS,
            itilde: AS,
            Iukcy: MS,
            iukcy: LS,
            Iuml: OS,
            iuml: DS,
            Jcirc: NS,
            jcirc: RS,
            Jcy: IS,
            jcy: PS,
            Jfr: BS,
            jfr: qS,
            jmath: FS,
            Jopf: _S,
            jopf: HS,
            Jscr: US,
            jscr: zS,
            Jsercy: $S,
            jsercy: VS,
            Jukcy: WS,
            jukcy: jS,
            Kappa: GS,
            kappa: KS,
            kappav: JS,
            Kcedil: YS,
            kcedil: ZS,
            Kcy: QS,
            kcy: XS,
            Kfr: eE,
            kfr: tE,
            kgreen: rE,
            KHcy: nE,
            khcy: aE,
            KJcy: iE,
            kjcy: oE,
            Kopf: sE,
            kopf: lE,
            Kscr: uE,
            kscr: cE,
            lAarr: fE,
            Lacute: vE,
            lacute: dE,
            laemptyv: pE,
            lagran: hE,
            Lambda: mE,
            lambda: gE,
            lang: yE,
            Lang: bE,
            langd: kE,
            langle: wE,
            lap: CE,
            Laplacetrf: TE,
            laquo: SE,
            larrb: EE,
            larrbfs: xE,
            larr: AE,
            Larr: ME,
            lArr: LE,
            larrfs: OE,
            larrhk: DE,
            larrlp: NE,
            larrpl: RE,
            larrsim: IE,
            larrtl: PE,
            latail: BE,
            lAtail: qE,
            lat: FE,
            late: _E,
            lates: HE,
            lbarr: UE,
            lBarr: zE,
            lbbrk: $E,
            lbrace: VE,
            lbrack: WE,
            lbrke: jE,
            lbrksld: GE,
            lbrkslu: KE,
            Lcaron: JE,
            lcaron: YE,
            Lcedil: ZE,
            lcedil: QE,
            lceil: XE,
            lcub: ex,
            Lcy: tx,
            lcy: rx,
            ldca: nx,
            ldquo: ax,
            ldquor: ix,
            ldrdhar: ox,
            ldrushar: sx,
            ldsh: lx,
            le: ux,
            lE: cx,
            LeftAngleBracket: fx,
            LeftArrowBar: vx,
            leftarrow: dx,
            LeftArrow: px,
            Leftarrow: hx,
            LeftArrowRightArrow: mx,
            leftarrowtail: gx,
            LeftCeiling: yx,
            LeftDoubleBracket: bx,
            LeftDownTeeVector: kx,
            LeftDownVectorBar: wx,
            LeftDownVector: Cx,
            LeftFloor: Tx,
            leftharpoondown: Sx,
            leftharpoonup: Ex,
            leftleftarrows: xx,
            leftrightarrow: Ax,
            LeftRightArrow: Mx,
            Leftrightarrow: Lx,
            leftrightarrows: Ox,
            leftrightharpoons: Dx,
            leftrightsquigarrow: Nx,
            LeftRightVector: Rx,
            LeftTeeArrow: Ix,
            LeftTee: Px,
            LeftTeeVector: Bx,
            leftthreetimes: qx,
            LeftTriangleBar: Fx,
            LeftTriangle: _x,
            LeftTriangleEqual: Hx,
            LeftUpDownVector: Ux,
            LeftUpTeeVector: zx,
            LeftUpVectorBar: $x,
            LeftUpVector: Vx,
            LeftVectorBar: Wx,
            LeftVector: jx,
            lEg: Gx,
            leg: Kx,
            leq: Jx,
            leqq: Yx,
            leqslant: Zx,
            lescc: Qx,
            les: Xx,
            lesdot: eA,
            lesdoto: tA,
            lesdotor: rA,
            lesg: nA,
            lesges: aA,
            lessapprox: iA,
            lessdot: oA,
            lesseqgtr: sA,
            lesseqqgtr: lA,
            LessEqualGreater: uA,
            LessFullEqual: cA,
            LessGreater: fA,
            lessgtr: vA,
            LessLess: dA,
            lesssim: pA,
            LessSlantEqual: hA,
            LessTilde: mA,
            lfisht: gA,
            lfloor: yA,
            Lfr: bA,
            lfr: kA,
            lg: wA,
            lgE: CA,
            lHar: TA,
            lhard: SA,
            lharu: EA,
            lharul: xA,
            lhblk: AA,
            LJcy: MA,
            ljcy: LA,
            llarr: OA,
            ll: DA,
            Ll: NA,
            llcorner: RA,
            Lleftarrow: IA,
            llhard: PA,
            lltri: BA,
            Lmidot: qA,
            lmidot: FA,
            lmoustache: _A,
            lmoust: HA,
            lnap: UA,
            lnapprox: zA,
            lne: $A,
            lnE: VA,
            lneq: WA,
            lneqq: jA,
            lnsim: GA,
            loang: KA,
            loarr: JA,
            lobrk: YA,
            longleftarrow: ZA,
            LongLeftArrow: QA,
            Longleftarrow: XA,
            longleftrightarrow: eM,
            LongLeftRightArrow: tM,
            Longleftrightarrow: rM,
            longmapsto: nM,
            longrightarrow: aM,
            LongRightArrow: iM,
            Longrightarrow: oM,
            looparrowleft: sM,
            looparrowright: lM,
            lopar: uM,
            Lopf: cM,
            lopf: fM,
            loplus: vM,
            lotimes: dM,
            lowast: pM,
            lowbar: hM,
            LowerLeftArrow: mM,
            LowerRightArrow: gM,
            loz: yM,
            lozenge: bM,
            lozf: kM,
            lpar: wM,
            lparlt: CM,
            lrarr: TM,
            lrcorner: SM,
            lrhar: EM,
            lrhard: xM,
            lrm: AM,
            lrtri: MM,
            lsaquo: LM,
            lscr: OM,
            Lscr: DM,
            lsh: NM,
            Lsh: RM,
            lsim: IM,
            lsime: PM,
            lsimg: BM,
            lsqb: qM,
            lsquo: FM,
            lsquor: _M,
            Lstrok: HM,
            lstrok: UM,
            ltcc: zM,
            ltcir: $M,
            lt: VM,
            LT: WM,
            Lt: jM,
            ltdot: GM,
            lthree: KM,
            ltimes: JM,
            ltlarr: YM,
            ltquest: ZM,
            ltri: QM,
            ltrie: XM,
            ltrif: eL,
            ltrPar: tL,
            lurdshar: rL,
            luruhar: nL,
            lvertneqq: aL,
            lvnE: iL,
            macr: oL,
            male: sL,
            malt: lL,
            maltese: uL,
            Map: "⤅",
            map: cL,
            mapsto: fL,
            mapstodown: vL,
            mapstoleft: dL,
            mapstoup: pL,
            marker: hL,
            mcomma: mL,
            Mcy: gL,
            mcy: yL,
            mdash: bL,
            mDDot: kL,
            measuredangle: wL,
            MediumSpace: CL,
            Mellintrf: TL,
            Mfr: SL,
            mfr: EL,
            mho: xL,
            micro: AL,
            midast: ML,
            midcir: LL,
            mid: OL,
            middot: DL,
            minusb: NL,
            minus: RL,
            minusd: IL,
            minusdu: PL,
            MinusPlus: BL,
            mlcp: qL,
            mldr: FL,
            mnplus: _L,
            models: HL,
            Mopf: UL,
            mopf: zL,
            mp: $L,
            mscr: VL,
            Mscr: WL,
            mstpos: jL,
            Mu: GL,
            mu: KL,
            multimap: JL,
            mumap: YL,
            nabla: ZL,
            Nacute: QL,
            nacute: XL,
            nang: eO,
            nap: tO,
            napE: rO,
            napid: nO,
            napos: aO,
            napprox: iO,
            natural: oO,
            naturals: sO,
            natur: lO,
            nbsp: uO,
            nbump: cO,
            nbumpe: fO,
            ncap: vO,
            Ncaron: dO,
            ncaron: pO,
            Ncedil: hO,
            ncedil: mO,
            ncong: gO,
            ncongdot: yO,
            ncup: bO,
            Ncy: kO,
            ncy: wO,
            ndash: CO,
            nearhk: TO,
            nearr: SO,
            neArr: EO,
            nearrow: xO,
            ne: AO,
            nedot: MO,
            NegativeMediumSpace: LO,
            NegativeThickSpace: OO,
            NegativeThinSpace: DO,
            NegativeVeryThinSpace: NO,
            nequiv: RO,
            nesear: IO,
            nesim: PO,
            NestedGreaterGreater: BO,
            NestedLessLess: qO,
            NewLine: FO,
            nexist: _O,
            nexists: HO,
            Nfr: UO,
            nfr: zO,
            ngE: $O,
            nge: VO,
            ngeq: WO,
            ngeqq: jO,
            ngeqslant: GO,
            nges: KO,
            nGg: JO,
            ngsim: YO,
            nGt: ZO,
            ngt: QO,
            ngtr: XO,
            nGtv: eD,
            nharr: tD,
            nhArr: rD,
            nhpar: nD,
            ni: aD,
            nis: iD,
            nisd: oD,
            niv: sD,
            NJcy: lD,
            njcy: uD,
            nlarr: cD,
            nlArr: fD,
            nldr: vD,
            nlE: dD,
            nle: pD,
            nleftarrow: hD,
            nLeftarrow: mD,
            nleftrightarrow: gD,
            nLeftrightarrow: yD,
            nleq: bD,
            nleqq: kD,
            nleqslant: wD,
            nles: CD,
            nless: TD,
            nLl: SD,
            nlsim: ED,
            nLt: xD,
            nlt: AD,
            nltri: MD,
            nltrie: LD,
            nLtv: OD,
            nmid: DD,
            NoBreak: ND,
            NonBreakingSpace: RD,
            nopf: ID,
            Nopf: PD,
            Not: BD,
            not: qD,
            NotCongruent: FD,
            NotCupCap: _D,
            NotDoubleVerticalBar: HD,
            NotElement: UD,
            NotEqual: zD,
            NotEqualTilde: $D,
            NotExists: VD,
            NotGreater: WD,
            NotGreaterEqual: jD,
            NotGreaterFullEqual: GD,
            NotGreaterGreater: KD,
            NotGreaterLess: JD,
            NotGreaterSlantEqual: YD,
            NotGreaterTilde: ZD,
            NotHumpDownHump: QD,
            NotHumpEqual: XD,
            notin: eN,
            notindot: tN,
            notinE: rN,
            notinva: nN,
            notinvb: aN,
            notinvc: iN,
            NotLeftTriangleBar: oN,
            NotLeftTriangle: sN,
            NotLeftTriangleEqual: lN,
            NotLess: uN,
            NotLessEqual: cN,
            NotLessGreater: fN,
            NotLessLess: vN,
            NotLessSlantEqual: dN,
            NotLessTilde: pN,
            NotNestedGreaterGreater: hN,
            NotNestedLessLess: mN,
            notni: gN,
            notniva: yN,
            notnivb: bN,
            notnivc: kN,
            NotPrecedes: wN,
            NotPrecedesEqual: CN,
            NotPrecedesSlantEqual: TN,
            NotReverseElement: SN,
            NotRightTriangleBar: EN,
            NotRightTriangle: xN,
            NotRightTriangleEqual: AN,
            NotSquareSubset: MN,
            NotSquareSubsetEqual: LN,
            NotSquareSuperset: ON,
            NotSquareSupersetEqual: DN,
            NotSubset: NN,
            NotSubsetEqual: RN,
            NotSucceeds: IN,
            NotSucceedsEqual: PN,
            NotSucceedsSlantEqual: BN,
            NotSucceedsTilde: qN,
            NotSuperset: FN,
            NotSupersetEqual: _N,
            NotTilde: HN,
            NotTildeEqual: UN,
            NotTildeFullEqual: zN,
            NotTildeTilde: $N,
            NotVerticalBar: VN,
            nparallel: WN,
            npar: jN,
            nparsl: GN,
            npart: KN,
            npolint: JN,
            npr: YN,
            nprcue: ZN,
            nprec: QN,
            npreceq: XN,
            npre: eR,
            nrarrc: tR,
            nrarr: rR,
            nrArr: nR,
            nrarrw: aR,
            nrightarrow: iR,
            nRightarrow: oR,
            nrtri: sR,
            nrtrie: lR,
            nsc: uR,
            nsccue: cR,
            nsce: fR,
            Nscr: vR,
            nscr: dR,
            nshortmid: pR,
            nshortparallel: hR,
            nsim: mR,
            nsime: gR,
            nsimeq: yR,
            nsmid: bR,
            nspar: kR,
            nsqsube: wR,
            nsqsupe: CR,
            nsub: TR,
            nsubE: SR,
            nsube: ER,
            nsubset: xR,
            nsubseteq: AR,
            nsubseteqq: MR,
            nsucc: LR,
            nsucceq: OR,
            nsup: DR,
            nsupE: NR,
            nsupe: RR,
            nsupset: IR,
            nsupseteq: PR,
            nsupseteqq: BR,
            ntgl: qR,
            Ntilde: FR,
            ntilde: _R,
            ntlg: HR,
            ntriangleleft: UR,
            ntrianglelefteq: zR,
            ntriangleright: $R,
            ntrianglerighteq: VR,
            Nu: WR,
            nu: jR,
            num: GR,
            numero: KR,
            numsp: JR,
            nvap: YR,
            nvdash: ZR,
            nvDash: QR,
            nVdash: XR,
            nVDash: eI,
            nvge: tI,
            nvgt: rI,
            nvHarr: nI,
            nvinfin: aI,
            nvlArr: iI,
            nvle: oI,
            nvlt: sI,
            nvltrie: lI,
            nvrArr: uI,
            nvrtrie: cI,
            nvsim: fI,
            nwarhk: vI,
            nwarr: dI,
            nwArr: pI,
            nwarrow: hI,
            nwnear: mI,
            Oacute: gI,
            oacute: yI,
            oast: bI,
            Ocirc: kI,
            ocirc: wI,
            ocir: CI,
            Ocy: TI,
            ocy: SI,
            odash: EI,
            Odblac: xI,
            odblac: AI,
            odiv: MI,
            odot: LI,
            odsold: OI,
            OElig: DI,
            oelig: NI,
            ofcir: RI,
            Ofr: II,
            ofr: PI,
            ogon: BI,
            Ograve: qI,
            ograve: FI,
            ogt: _I,
            ohbar: HI,
            ohm: UI,
            oint: zI,
            olarr: $I,
            olcir: VI,
            olcross: WI,
            oline: jI,
            olt: GI,
            Omacr: KI,
            omacr: JI,
            Omega: YI,
            omega: ZI,
            Omicron: QI,
            omicron: XI,
            omid: eP,
            ominus: tP,
            Oopf: rP,
            oopf: nP,
            opar: aP,
            OpenCurlyDoubleQuote: iP,
            OpenCurlyQuote: oP,
            operp: sP,
            oplus: lP,
            orarr: uP,
            Or: cP,
            or: fP,
            ord: vP,
            order: dP,
            orderof: pP,
            ordf: hP,
            ordm: mP,
            origof: gP,
            oror: yP,
            orslope: bP,
            orv: kP,
            oS: wP,
            Oscr: CP,
            oscr: TP,
            Oslash: SP,
            oslash: EP,
            osol: xP,
            Otilde: AP,
            otilde: MP,
            otimesas: LP,
            Otimes: OP,
            otimes: DP,
            Ouml: NP,
            ouml: RP,
            ovbar: IP,
            OverBar: PP,
            OverBrace: BP,
            OverBracket: qP,
            OverParenthesis: FP,
            para: _P,
            parallel: HP,
            par: UP,
            parsim: zP,
            parsl: $P,
            part: VP,
            PartialD: WP,
            Pcy: jP,
            pcy: GP,
            percnt: KP,
            period: JP,
            permil: YP,
            perp: ZP,
            pertenk: QP,
            Pfr: XP,
            pfr: eB,
            Phi: tB,
            phi: rB,
            phiv: nB,
            phmmat: aB,
            phone: iB,
            Pi: oB,
            pi: sB,
            pitchfork: lB,
            piv: uB,
            planck: cB,
            planckh: fB,
            plankv: vB,
            plusacir: dB,
            plusb: pB,
            pluscir: hB,
            plus: mB,
            plusdo: gB,
            plusdu: yB,
            pluse: bB,
            PlusMinus: kB,
            plusmn: wB,
            plussim: CB,
            plustwo: TB,
            pm: SB,
            Poincareplane: EB,
            pointint: xB,
            popf: AB,
            Popf: MB,
            pound: LB,
            prap: OB,
            Pr: DB,
            pr: NB,
            prcue: RB,
            precapprox: IB,
            prec: PB,
            preccurlyeq: BB,
            Precedes: qB,
            PrecedesEqual: FB,
            PrecedesSlantEqual: _B,
            PrecedesTilde: HB,
            preceq: UB,
            precnapprox: zB,
            precneqq: $B,
            precnsim: VB,
            pre: WB,
            prE: jB,
            precsim: GB,
            prime: KB,
            Prime: JB,
            primes: YB,
            prnap: ZB,
            prnE: QB,
            prnsim: XB,
            prod: eq,
            Product: tq,
            profalar: rq,
            profline: nq,
            profsurf: aq,
            prop: iq,
            Proportional: oq,
            Proportion: sq,
            propto: lq,
            prsim: uq,
            prurel: cq,
            Pscr: fq,
            pscr: vq,
            Psi: dq,
            psi: pq,
            puncsp: hq,
            Qfr: mq,
            qfr: gq,
            qint: yq,
            qopf: bq,
            Qopf: kq,
            qprime: wq,
            Qscr: Cq,
            qscr: Tq,
            quaternions: Sq,
            quatint: Eq,
            quest: xq,
            questeq: Aq,
            quot: Mq,
            QUOT: Lq,
            rAarr: Oq,
            race: Dq,
            Racute: Nq,
            racute: Rq,
            radic: Iq,
            raemptyv: Pq,
            rang: Bq,
            Rang: qq,
            rangd: Fq,
            range: _q,
            rangle: Hq,
            raquo: Uq,
            rarrap: zq,
            rarrb: $q,
            rarrbfs: Vq,
            rarrc: Wq,
            rarr: jq,
            Rarr: Gq,
            rArr: Kq,
            rarrfs: Jq,
            rarrhk: Yq,
            rarrlp: Zq,
            rarrpl: Qq,
            rarrsim: Xq,
            Rarrtl: eF,
            rarrtl: tF,
            rarrw: rF,
            ratail: nF,
            rAtail: aF,
            ratio: iF,
            rationals: oF,
            rbarr: sF,
            rBarr: lF,
            RBarr: uF,
            rbbrk: cF,
            rbrace: fF,
            rbrack: vF,
            rbrke: dF,
            rbrksld: pF,
            rbrkslu: hF,
            Rcaron: mF,
            rcaron: gF,
            Rcedil: yF,
            rcedil: bF,
            rceil: kF,
            rcub: wF,
            Rcy: CF,
            rcy: TF,
            rdca: SF,
            rdldhar: EF,
            rdquo: xF,
            rdquor: AF,
            rdsh: MF,
            real: LF,
            realine: OF,
            realpart: DF,
            reals: NF,
            Re: RF,
            rect: IF,
            reg: PF,
            REG: BF,
            ReverseElement: qF,
            ReverseEquilibrium: FF,
            ReverseUpEquilibrium: _F,
            rfisht: HF,
            rfloor: UF,
            rfr: zF,
            Rfr: $F,
            rHar: VF,
            rhard: WF,
            rharu: jF,
            rharul: GF,
            Rho: KF,
            rho: JF,
            rhov: YF,
            RightAngleBracket: ZF,
            RightArrowBar: QF,
            rightarrow: XF,
            RightArrow: e_,
            Rightarrow: t_,
            RightArrowLeftArrow: r_,
            rightarrowtail: n_,
            RightCeiling: a_,
            RightDoubleBracket: i_,
            RightDownTeeVector: o_,
            RightDownVectorBar: s_,
            RightDownVector: l_,
            RightFloor: u_,
            rightharpoondown: c_,
            rightharpoonup: f_,
            rightleftarrows: v_,
            rightleftharpoons: d_,
            rightrightarrows: p_,
            rightsquigarrow: h_,
            RightTeeArrow: m_,
            RightTee: g_,
            RightTeeVector: y_,
            rightthreetimes: b_,
            RightTriangleBar: k_,
            RightTriangle: w_,
            RightTriangleEqual: C_,
            RightUpDownVector: T_,
            RightUpTeeVector: S_,
            RightUpVectorBar: E_,
            RightUpVector: x_,
            RightVectorBar: A_,
            RightVector: M_,
            ring: L_,
            risingdotseq: O_,
            rlarr: D_,
            rlhar: N_,
            rlm: R_,
            rmoustache: I_,
            rmoust: P_,
            rnmid: B_,
            roang: q_,
            roarr: F_,
            robrk: __,
            ropar: H_,
            ropf: U_,
            Ropf: z_,
            roplus: $_,
            rotimes: V_,
            RoundImplies: W_,
            rpar: j_,
            rpargt: G_,
            rppolint: K_,
            rrarr: J_,
            Rrightarrow: Y_,
            rsaquo: Z_,
            rscr: Q_,
            Rscr: X_,
            rsh: eH,
            Rsh: tH,
            rsqb: rH,
            rsquo: nH,
            rsquor: aH,
            rthree: iH,
            rtimes: oH,
            rtri: sH,
            rtrie: lH,
            rtrif: uH,
            rtriltri: cH,
            RuleDelayed: fH,
            ruluhar: vH,
            rx: dH,
            Sacute: pH,
            sacute: hH,
            sbquo: mH,
            scap: gH,
            Scaron: yH,
            scaron: bH,
            Sc: kH,
            sc: wH,
            sccue: CH,
            sce: TH,
            scE: SH,
            Scedil: EH,
            scedil: xH,
            Scirc: AH,
            scirc: MH,
            scnap: LH,
            scnE: OH,
            scnsim: DH,
            scpolint: NH,
            scsim: RH,
            Scy: IH,
            scy: PH,
            sdotb: BH,
            sdot: qH,
            sdote: FH,
            searhk: _H,
            searr: HH,
            seArr: UH,
            searrow: zH,
            sect: $H,
            semi: VH,
            seswar: WH,
            setminus: jH,
            setmn: GH,
            sext: KH,
            Sfr: JH,
            sfr: YH,
            sfrown: ZH,
            sharp: QH,
            SHCHcy: XH,
            shchcy: eU,
            SHcy: tU,
            shcy: rU,
            ShortDownArrow: nU,
            ShortLeftArrow: aU,
            shortmid: iU,
            shortparallel: oU,
            ShortRightArrow: sU,
            ShortUpArrow: lU,
            shy: uU,
            Sigma: cU,
            sigma: fU,
            sigmaf: vU,
            sigmav: dU,
            sim: pU,
            simdot: hU,
            sime: mU,
            simeq: gU,
            simg: yU,
            simgE: bU,
            siml: kU,
            simlE: wU,
            simne: CU,
            simplus: TU,
            simrarr: SU,
            slarr: EU,
            SmallCircle: xU,
            smallsetminus: AU,
            smashp: MU,
            smeparsl: LU,
            smid: OU,
            smile: DU,
            smt: NU,
            smte: RU,
            smtes: IU,
            SOFTcy: PU,
            softcy: BU,
            solbar: qU,
            solb: FU,
            sol: _U,
            Sopf: HU,
            sopf: UU,
            spades: zU,
            spadesuit: $U,
            spar: VU,
            sqcap: WU,
            sqcaps: jU,
            sqcup: GU,
            sqcups: KU,
            Sqrt: JU,
            sqsub: YU,
            sqsube: ZU,
            sqsubset: QU,
            sqsubseteq: XU,
            sqsup: ez,
            sqsupe: tz,
            sqsupset: rz,
            sqsupseteq: nz,
            square: az,
            Square: iz,
            SquareIntersection: oz,
            SquareSubset: sz,
            SquareSubsetEqual: lz,
            SquareSuperset: uz,
            SquareSupersetEqual: cz,
            SquareUnion: fz,
            squarf: vz,
            squ: dz,
            squf: pz,
            srarr: hz,
            Sscr: mz,
            sscr: gz,
            ssetmn: yz,
            ssmile: bz,
            sstarf: kz,
            Star: wz,
            star: Cz,
            starf: Tz,
            straightepsilon: Sz,
            straightphi: Ez,
            strns: xz,
            sub: Az,
            Sub: Mz,
            subdot: Lz,
            subE: Oz,
            sube: Dz,
            subedot: Nz,
            submult: Rz,
            subnE: Iz,
            subne: Pz,
            subplus: Bz,
            subrarr: qz,
            subset: Fz,
            Subset: _z,
            subseteq: Hz,
            subseteqq: Uz,
            SubsetEqual: zz,
            subsetneq: $z,
            subsetneqq: Vz,
            subsim: Wz,
            subsub: jz,
            subsup: Gz,
            succapprox: Kz,
            succ: Jz,
            succcurlyeq: Yz,
            Succeeds: Zz,
            SucceedsEqual: Qz,
            SucceedsSlantEqual: Xz,
            SucceedsTilde: e$,
            succeq: t$,
            succnapprox: r$,
            succneqq: n$,
            succnsim: a$,
            succsim: i$,
            SuchThat: o$,
            sum: s$,
            Sum: l$,
            sung: u$,
            sup1: c$,
            sup2: f$,
            sup3: v$,
            sup: d$,
            Sup: p$,
            supdot: h$,
            supdsub: m$,
            supE: g$,
            supe: y$,
            supedot: b$,
            Superset: k$,
            SupersetEqual: w$,
            suphsol: C$,
            suphsub: T$,
            suplarr: S$,
            supmult: E$,
            supnE: x$,
            supne: A$,
            supplus: M$,
            supset: L$,
            Supset: O$,
            supseteq: D$,
            supseteqq: N$,
            supsetneq: R$,
            supsetneqq: I$,
            supsim: P$,
            supsub: B$,
            supsup: q$,
            swarhk: F$,
            swarr: _$,
            swArr: H$,
            swarrow: U$,
            swnwar: z$,
            szlig: $$,
            Tab: V$,
            target: W$,
            Tau: j$,
            tau: G$,
            tbrk: K$,
            Tcaron: J$,
            tcaron: Y$,
            Tcedil: Z$,
            tcedil: Q$,
            Tcy: X$,
            tcy: e2,
            tdot: t2,
            telrec: r2,
            Tfr: n2,
            tfr: a2,
            there4: i2,
            therefore: o2,
            Therefore: s2,
            Theta: l2,
            theta: u2,
            thetasym: c2,
            thetav: f2,
            thickapprox: v2,
            thicksim: d2,
            ThickSpace: p2,
            ThinSpace: h2,
            thinsp: m2,
            thkap: g2,
            thksim: y2,
            THORN: b2,
            thorn: k2,
            tilde: w2,
            Tilde: C2,
            TildeEqual: T2,
            TildeFullEqual: S2,
            TildeTilde: E2,
            timesbar: x2,
            timesb: A2,
            times: M2,
            timesd: L2,
            tint: O2,
            toea: D2,
            topbot: N2,
            topcir: R2,
            top: I2,
            Topf: P2,
            topf: B2,
            topfork: q2,
            tosa: F2,
            tprime: _2,
            trade: H2,
            TRADE: U2,
            triangle: z2,
            triangledown: $2,
            triangleleft: V2,
            trianglelefteq: W2,
            triangleq: j2,
            triangleright: G2,
            trianglerighteq: K2,
            tridot: J2,
            trie: Y2,
            triminus: Z2,
            TripleDot: Q2,
            triplus: X2,
            trisb: eV,
            tritime: tV,
            trpezium: rV,
            Tscr: nV,
            tscr: aV,
            TScy: iV,
            tscy: oV,
            TSHcy: sV,
            tshcy: lV,
            Tstrok: uV,
            tstrok: cV,
            twixt: fV,
            twoheadleftarrow: vV,
            twoheadrightarrow: dV,
            Uacute: pV,
            uacute: hV,
            uarr: mV,
            Uarr: gV,
            uArr: yV,
            Uarrocir: bV,
            Ubrcy: kV,
            ubrcy: wV,
            Ubreve: CV,
            ubreve: TV,
            Ucirc: SV,
            ucirc: EV,
            Ucy: xV,
            ucy: AV,
            udarr: MV,
            Udblac: LV,
            udblac: OV,
            udhar: DV,
            ufisht: NV,
            Ufr: RV,
            ufr: IV,
            Ugrave: PV,
            ugrave: BV,
            uHar: qV,
            uharl: FV,
            uharr: _V,
            uhblk: HV,
            ulcorn: UV,
            ulcorner: zV,
            ulcrop: $V,
            ultri: VV,
            Umacr: WV,
            umacr: jV,
            uml: GV,
            UnderBar: KV,
            UnderBrace: JV,
            UnderBracket: YV,
            UnderParenthesis: ZV,
            Union: QV,
            UnionPlus: XV,
            Uogon: e3,
            uogon: t3,
            Uopf: r3,
            uopf: n3,
            UpArrowBar: a3,
            uparrow: i3,
            UpArrow: o3,
            Uparrow: s3,
            UpArrowDownArrow: l3,
            updownarrow: u3,
            UpDownArrow: c3,
            Updownarrow: f3,
            UpEquilibrium: v3,
            upharpoonleft: d3,
            upharpoonright: p3,
            uplus: h3,
            UpperLeftArrow: m3,
            UpperRightArrow: g3,
            upsi: y3,
            Upsi: b3,
            upsih: k3,
            Upsilon: w3,
            upsilon: C3,
            UpTeeArrow: T3,
            UpTee: S3,
            upuparrows: E3,
            urcorn: x3,
            urcorner: A3,
            urcrop: M3,
            Uring: L3,
            uring: O3,
            urtri: D3,
            Uscr: N3,
            uscr: R3,
            utdot: I3,
            Utilde: P3,
            utilde: B3,
            utri: q3,
            utrif: F3,
            uuarr: _3,
            Uuml: H3,
            uuml: U3,
            uwangle: z3,
            vangrt: $3,
            varepsilon: V3,
            varkappa: W3,
            varnothing: j3,
            varphi: G3,
            varpi: K3,
            varpropto: J3,
            varr: Y3,
            vArr: Z3,
            varrho: Q3,
            varsigma: X3,
            varsubsetneq: eW,
            varsubsetneqq: tW,
            varsupsetneq: rW,
            varsupsetneqq: nW,
            vartheta: aW,
            vartriangleleft: iW,
            vartriangleright: oW,
            vBar: sW,
            Vbar: lW,
            vBarv: uW,
            Vcy: cW,
            vcy: fW,
            vdash: vW,
            vDash: dW,
            Vdash: pW,
            VDash: hW,
            Vdashl: mW,
            veebar: gW,
            vee: yW,
            Vee: bW,
            veeeq: kW,
            vellip: wW,
            verbar: CW,
            Verbar: TW,
            vert: SW,
            Vert: EW,
            VerticalBar: xW,
            VerticalLine: AW,
            VerticalSeparator: MW,
            VerticalTilde: LW,
            VeryThinSpace: OW,
            Vfr: DW,
            vfr: NW,
            vltri: RW,
            vnsub: IW,
            vnsup: PW,
            Vopf: BW,
            vopf: qW,
            vprop: FW,
            vrtri: _W,
            Vscr: HW,
            vscr: UW,
            vsubnE: zW,
            vsubne: $W,
            vsupnE: VW,
            vsupne: WW,
            Vvdash: jW,
            vzigzag: GW,
            Wcirc: KW,
            wcirc: JW,
            wedbar: YW,
            wedge: ZW,
            Wedge: QW,
            wedgeq: XW,
            weierp: ej,
            Wfr: tj,
            wfr: rj,
            Wopf: nj,
            wopf: aj,
            wp: ij,
            wr: oj,
            wreath: sj,
            Wscr: lj,
            wscr: uj,
            xcap: cj,
            xcirc: fj,
            xcup: vj,
            xdtri: dj,
            Xfr: pj,
            xfr: hj,
            xharr: mj,
            xhArr: gj,
            Xi: yj,
            xi: bj,
            xlarr: kj,
            xlArr: wj,
            xmap: Cj,
            xnis: Tj,
            xodot: Sj,
            Xopf: Ej,
            xopf: xj,
            xoplus: Aj,
            xotime: Mj,
            xrarr: Lj,
            xrArr: Oj,
            Xscr: Dj,
            xscr: Nj,
            xsqcup: Rj,
            xuplus: Ij,
            xutri: Pj,
            xvee: Bj,
            xwedge: qj,
            Yacute: Fj,
            yacute: _j,
            YAcy: Hj,
            yacy: Uj,
            Ycirc: zj,
            ycirc: $j,
            Ycy: Vj,
            ycy: Wj,
            yen: jj,
            Yfr: Gj,
            yfr: Kj,
            YIcy: Jj,
            yicy: Yj,
            Yopf: Zj,
            yopf: Qj,
            Yscr: Xj,
            yscr: eG,
            YUcy: tG,
            yucy: rG,
            yuml: nG,
            Yuml: aG,
            Zacute: iG,
            zacute: oG,
            Zcaron: sG,
            zcaron: lG,
            Zcy: uG,
            zcy: cG,
            Zdot: fG,
            zdot: vG,
            zeetrf: dG,
            ZeroWidthSpace: pG,
            Zeta: hG,
            zeta: mG,
            zfr: gG,
            Zfr: yG,
            ZHcy: bG,
            zhcy: kG,
            zigrarr: wG,
            zopf: CG,
            Zopf: TG,
            Zscr: SG,
            zscr: EG,
            zwj: xG,
            zwnj: AG
          }, MG = "Á", LG = "á", OG = "Â", DG = "â", NG = "´", RG = "Æ", IG = "æ", PG = "À", BG = "à", qG = "&", FG = "&", _G = "Å", HG = "å", UG = "Ã", zG = "ã", $G = "Ä", VG = "ä", WG = "¦", jG = "Ç", GG = "ç", KG = "¸", JG = "¢", YG = "©", ZG = "©", QG = "¤", XG = "°", e4 = "÷", t4 = "É", r4 = "é", n4 = "Ê", a4 = "ê", i4 = "È", o4 = "è", s4 = "Ð", l4 = "ð", u4 = "Ë", c4 = "ë", f4 = "½", v4 = "¼", d4 = "¾", p4 = ">", h4 = ">", m4 = "Í", g4 = "í", y4 = "Î", b4 = "î", k4 = "¡", w4 = "Ì", C4 = "ì", T4 = "¿", S4 = "Ï", E4 = "ï", x4 = "«", A4 = "<", M4 = "<", L4 = "¯", O4 = "µ", D4 = "·", N4 = " ", R4 = "¬", I4 = "Ñ", P4 = "ñ", B4 = "Ó", q4 = "ó", F4 = "Ô", _4 = "ô", H4 = "Ò", U4 = "ò", z4 = "ª", $4 = "º", V4 = "Ø", W4 = "ø", j4 = "Õ", G4 = "õ", K4 = "Ö", J4 = "ö", Y4 = "¶", Z4 = "±", Q4 = "£", X4 = '"', e5 = '"', t5 = "»", r5 = "®", n5 = "®", a5 = "§", i5 = "­", o5 = "¹", s5 = "²", l5 = "³", u5 = "ß", c5 = "Þ", f5 = "þ", v5 = "×", d5 = "Ú", p5 = "ú", h5 = "Û", m5 = "û", g5 = "Ù", y5 = "ù", b5 = "¨", k5 = "Ü", w5 = "ü", C5 = "Ý", T5 = "ý", S5 = "¥", E5 = "ÿ", x5 = {
            Aacute: MG,
            aacute: LG,
            Acirc: OG,
            acirc: DG,
            acute: NG,
            AElig: RG,
            aelig: IG,
            Agrave: PG,
            agrave: BG,
            amp: qG,
            AMP: FG,
            Aring: _G,
            aring: HG,
            Atilde: UG,
            atilde: zG,
            Auml: $G,
            auml: VG,
            brvbar: WG,
            Ccedil: jG,
            ccedil: GG,
            cedil: KG,
            cent: JG,
            copy: YG,
            COPY: ZG,
            curren: QG,
            deg: XG,
            divide: e4,
            Eacute: t4,
            eacute: r4,
            Ecirc: n4,
            ecirc: a4,
            Egrave: i4,
            egrave: o4,
            ETH: s4,
            eth: l4,
            Euml: u4,
            euml: c4,
            frac12: f4,
            frac14: v4,
            frac34: d4,
            gt: p4,
            GT: h4,
            Iacute: m4,
            iacute: g4,
            Icirc: y4,
            icirc: b4,
            iexcl: k4,
            Igrave: w4,
            igrave: C4,
            iquest: T4,
            Iuml: S4,
            iuml: E4,
            laquo: x4,
            lt: A4,
            LT: M4,
            macr: L4,
            micro: O4,
            middot: D4,
            nbsp: N4,
            not: R4,
            Ntilde: I4,
            ntilde: P4,
            Oacute: B4,
            oacute: q4,
            Ocirc: F4,
            ocirc: _4,
            Ograve: H4,
            ograve: U4,
            ordf: z4,
            ordm: $4,
            Oslash: V4,
            oslash: W4,
            Otilde: j4,
            otilde: G4,
            Ouml: K4,
            ouml: J4,
            para: Y4,
            plusmn: Z4,
            pound: Q4,
            quot: X4,
            QUOT: e5,
            raquo: t5,
            reg: r5,
            REG: n5,
            sect: a5,
            shy: i5,
            sup1: o5,
            sup2: s5,
            sup3: l5,
            szlig: u5,
            THORN: c5,
            thorn: f5,
            times: v5,
            Uacute: d5,
            uacute: p5,
            Ucirc: h5,
            ucirc: m5,
            Ugrave: g5,
            ugrave: y5,
            uml: b5,
            Uuml: k5,
            uuml: w5,
            Yacute: C5,
            yacute: T5,
            yen: S5,
            yuml: E5
          }, A5 = "&", M5 = "'", L5 = ">", O5 = "<", D5 = '"', Zc = {
            amp: A5,
            apos: M5,
            gt: L5,
            lt: O5,
            quot: D5
          }, Pl = {}, N5 = {
            0: 65533,
            128: 8364,
            130: 8218,
            131: 402,
            132: 8222,
            133: 8230,
            134: 8224,
            135: 8225,
            136: 710,
            137: 8240,
            138: 352,
            139: 8249,
            140: 338,
            142: 381,
            145: 8216,
            146: 8217,
            147: 8220,
            148: 8221,
            149: 8226,
            150: 8211,
            151: 8212,
            152: 732,
            153: 8482,
            154: 353,
            155: 8250,
            156: 339,
            158: 382,
            159: 376
          }, R5 = K && K.__importDefault || function(f) {
            return f && f.__esModule ? f : { default: f };
          };
          Object.defineProperty(Pl, "__esModule", { value: !0 });
          var Qc = R5(N5), I5 = (
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            String.fromCodePoint || function(f) {
              var c = "";
              return f > 65535 && (f -= 65536, c += String.fromCharCode(f >>> 10 & 1023 | 55296), f = 56320 | f & 1023), c += String.fromCharCode(f), c;
            }
          );
          function P5(f) {
            return f >= 55296 && f <= 57343 || f > 1114111 ? "�" : (f in Qc.default && (f = Qc.default[f]), I5(f));
          }
          Pl.default = P5;
          var Ro = K && K.__importDefault || function(f) {
            return f && f.__esModule ? f : { default: f };
          };
          Object.defineProperty(pe, "__esModule", { value: !0 }), pe.decodeHTML = pe.decodeHTMLStrict = pe.decodeXML = void 0;
          var Bl = Ro(Yc), B5 = Ro(x5), q5 = Ro(Zc), Xc = Ro(Pl), F5 = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
          pe.decodeXML = ef(q5.default), pe.decodeHTMLStrict = ef(Bl.default);
          function ef(f) {
            var c = rf(f);
            return function(p) {
              return String(p).replace(F5, c);
            };
          }
          var tf = function(f, c) {
            return f < c ? 1 : -1;
          };
          pe.decodeHTML = function() {
            for (var f = Object.keys(B5.default).sort(tf), c = Object.keys(Bl.default).sort(tf), p = 0, k = 0; p < c.length; p++)
              f[k] === c[p] ? (c[p] += ";?", k++) : c[p] += ";";
            var O = new RegExp("&(?:" + c.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), U = rf(Bl.default);
            function j(Q) {
              return Q.substr(-1) !== ";" && (Q += ";"), U(Q);
            }
            return function(Q) {
              return String(Q).replace(O, j);
            };
          }();
          function rf(f) {
            return function(p) {
              if (p.charAt(1) === "#") {
                var k = p.charAt(2);
                return k === "X" || k === "x" ? Xc.default(parseInt(p.substr(3), 16)) : Xc.default(parseInt(p.substr(2), 10));
              }
              return f[p.slice(1, -1)] || p;
            };
          }
          var Zr = {}, nf = K && K.__importDefault || function(f) {
            return f && f.__esModule ? f : { default: f };
          };
          Object.defineProperty(Zr, "__esModule", { value: !0 }), Zr.escapeUTF8 = Zr.escape = Zr.encodeNonAsciiHTML = Zr.encodeHTML = Zr.encodeXML = void 0;
          var _5 = nf(Zc), af = sf(_5.default), of = lf(af);
          Zr.encodeXML = ff(af);
          var H5 = nf(Yc), ql = sf(H5.default), U5 = lf(ql);
          Zr.encodeHTML = $5(ql, U5), Zr.encodeNonAsciiHTML = ff(ql);
          function sf(f) {
            return Object.keys(f).sort().reduce(function(c, p) {
              return c[f[p]] = "&" + p + ";", c;
            }, {});
          }
          function lf(f) {
            for (var c = [], p = [], k = 0, O = Object.keys(f); k < O.length; k++) {
              var U = O[k];
              U.length === 1 ? c.push("\\" + U) : p.push(U);
            }
            c.sort();
            for (var j = 0; j < c.length - 1; j++) {
              for (var Q = j; Q < c.length - 1 && c[Q].charCodeAt(1) + 1 === c[Q + 1].charCodeAt(1); )
                Q += 1;
              var ke = 1 + Q - j;
              ke < 3 || c.splice(j, ke, c[j] + "-" + c[Q]);
            }
            return p.unshift("[" + c.join("") + "]"), new RegExp(p.join("|"), "g");
          }
          var uf = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, z5 = (
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            String.prototype.codePointAt != null ? (
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              function(f) {
                return f.codePointAt(0);
              }
            ) : (
              // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
              function(f) {
                return (f.charCodeAt(0) - 55296) * 1024 + f.charCodeAt(1) - 56320 + 65536;
              }
            )
          );
          function Io(f) {
            return "&#x" + (f.length > 1 ? z5(f) : f.charCodeAt(0)).toString(16).toUpperCase() + ";";
          }
          function $5(f, c) {
            return function(p) {
              return p.replace(c, function(k) {
                return f[k];
              }).replace(uf, Io);
            };
          }
          var cf = new RegExp(of.source + "|" + uf.source, "g");
          function V5(f) {
            return f.replace(cf, Io);
          }
          Zr.escape = V5;
          function W5(f) {
            return f.replace(of, Io);
          }
          Zr.escapeUTF8 = W5;
          function ff(f) {
            return function(c) {
              return c.replace(cf, function(p) {
                return f[p] || Io(p);
              });
            };
          }
          (function(f) {
            Object.defineProperty(f, "__esModule", { value: !0 }), f.decodeXMLStrict = f.decodeHTML5Strict = f.decodeHTML4Strict = f.decodeHTML5 = f.decodeHTML4 = f.decodeHTMLStrict = f.decodeHTML = f.decodeXML = f.encodeHTML5 = f.encodeHTML4 = f.escapeUTF8 = f.escape = f.encodeNonAsciiHTML = f.encodeHTML = f.encodeXML = f.encode = f.decodeStrict = f.decode = void 0;
            var c = pe, p = Zr;
            function k(ke, xe) {
              return (!xe || xe <= 0 ? c.decodeXML : c.decodeHTML)(ke);
            }
            f.decode = k;
            function O(ke, xe) {
              return (!xe || xe <= 0 ? c.decodeXML : c.decodeHTMLStrict)(ke);
            }
            f.decodeStrict = O;
            function U(ke, xe) {
              return (!xe || xe <= 0 ? p.encodeXML : p.encodeHTML)(ke);
            }
            f.encode = U;
            var j = Zr;
            Object.defineProperty(f, "encodeXML", { enumerable: !0, get: function() {
              return j.encodeXML;
            } }), Object.defineProperty(f, "encodeHTML", { enumerable: !0, get: function() {
              return j.encodeHTML;
            } }), Object.defineProperty(f, "encodeNonAsciiHTML", { enumerable: !0, get: function() {
              return j.encodeNonAsciiHTML;
            } }), Object.defineProperty(f, "escape", { enumerable: !0, get: function() {
              return j.escape;
            } }), Object.defineProperty(f, "escapeUTF8", { enumerable: !0, get: function() {
              return j.escapeUTF8;
            } }), Object.defineProperty(f, "encodeHTML4", { enumerable: !0, get: function() {
              return j.encodeHTML;
            } }), Object.defineProperty(f, "encodeHTML5", { enumerable: !0, get: function() {
              return j.encodeHTML;
            } });
            var Q = pe;
            Object.defineProperty(f, "decodeXML", { enumerable: !0, get: function() {
              return Q.decodeXML;
            } }), Object.defineProperty(f, "decodeHTML", { enumerable: !0, get: function() {
              return Q.decodeHTML;
            } }), Object.defineProperty(f, "decodeHTMLStrict", { enumerable: !0, get: function() {
              return Q.decodeHTMLStrict;
            } }), Object.defineProperty(f, "decodeHTML4", { enumerable: !0, get: function() {
              return Q.decodeHTML;
            } }), Object.defineProperty(f, "decodeHTML5", { enumerable: !0, get: function() {
              return Q.decodeHTML;
            } }), Object.defineProperty(f, "decodeHTML4Strict", { enumerable: !0, get: function() {
              return Q.decodeHTMLStrict;
            } }), Object.defineProperty(f, "decodeHTML5Strict", { enumerable: !0, get: function() {
              return Q.decodeHTMLStrict;
            } }), Object.defineProperty(f, "decodeXMLStrict", { enumerable: !0, get: function() {
              return Q.decodeXML;
            } });
          })(ue);
          var vf = "&(?:#x[a-f0-9]{1,6}|#[0-9]{1,7}|[a-z][a-z0-9]{1,31});", j5 = 92, G5 = /[\\&]/, Fl = "[!\"#$%&'()*+,./:;<=>?@[\\\\\\]^_`{|}~-]", K5 = new RegExp("\\\\" + Fl + "|" + vf, "gi"), J5 = '[&<>"]', df = new RegExp(J5, "g"), Y5 = function(f) {
            return f.charCodeAt(0) === j5 ? f.charAt(1) : ue.decodeHTML(f);
          };
          function $i(f) {
            return G5.test(f) ? f.replace(K5, Y5) : f;
          }
          function Po(f) {
            try {
              return oe(f);
            } catch {
              return f;
            }
          }
          function Z5(f) {
            switch (f) {
              case "&":
                return "&amp;";
              case "<":
                return "&lt;";
              case ">":
                return "&gt;";
              case '"':
                return "&quot;";
              default:
                return f;
            }
          }
          function ui(f) {
            return df.test(f) ? f.replace(df, Z5) : f;
          }
          function _l(f, c) {
            for (var p = [], k = 0; k < c; k++)
              p.push(f);
            return p.join("");
          }
          function pf(f) {
            return f ? !/[^ \t]+/.test(f) : !0;
          }
          var Q5 = (
            /** @class */
            function() {
              function f(c) {
                this.current = c, this.root = c, this.entering = !0;
              }
              return f.prototype.next = function() {
                var c = this.current, p = this.entering;
                if (c === null)
                  return null;
                var k = Hl(c);
                return p && k ? c.firstChild ? (this.current = c.firstChild, this.entering = !0) : this.entering = !1 : c === this.root ? this.current = null : c.next === null ? (this.current = c.parent, this.entering = !1) : (this.current = c.next, this.entering = !0), { entering: p, node: c };
              }, f.prototype.resumeAt = function(c, p) {
                this.current = c, this.entering = p === !0;
              }, f;
            }()
          );
          function Hl(f) {
            switch (f.type) {
              case "document":
              case "blockQuote":
              case "list":
              case "item":
              case "paragraph":
              case "heading":
              case "emph":
              case "strong":
              case "strike":
              case "link":
              case "image":
              case "table":
              case "tableHead":
              case "tableBody":
              case "tableRow":
              case "tableCell":
              case "tableDelimRow":
              case "customInline":
                return !0;
              default:
                return !1;
            }
          }
          var X5 = 1, Bo = {};
          function e8(f) {
            return Bo[f];
          }
          function Ul(f) {
            delete Bo[f];
          }
          function t8() {
            Bo = {};
          }
          var Vi = (
            /** @class */
            function() {
              function f(c, p) {
                this.parent = null, this.prev = null, this.next = null, this.firstChild = null, this.lastChild = null, this.literal = null, c === "document" ? this.id = -1 : this.id = X5++, this.type = c, this.sourcepos = p, Bo[this.id] = this;
              }
              return f.prototype.isContainer = function() {
                return Hl(this);
              }, f.prototype.unlink = function() {
                this.prev ? this.prev.next = this.next : this.parent && (this.parent.firstChild = this.next), this.next ? this.next.prev = this.prev : this.parent && (this.parent.lastChild = this.prev), this.parent = null, this.next = null, this.prev = null;
              }, f.prototype.replaceWith = function(c) {
                this.insertBefore(c), this.unlink();
              }, f.prototype.insertAfter = function(c) {
                c.unlink(), c.next = this.next, c.next && (c.next.prev = c), c.prev = this, this.next = c, this.parent && (c.parent = this.parent, c.next || (c.parent.lastChild = c));
              }, f.prototype.insertBefore = function(c) {
                c.unlink(), c.prev = this.prev, c.prev && (c.prev.next = c), c.next = this, this.prev = c, c.parent = this.parent, c.prev || (c.parent.firstChild = c);
              }, f.prototype.appendChild = function(c) {
                c.unlink(), c.parent = this, this.lastChild ? (this.lastChild.next = c, c.prev = this.lastChild, this.lastChild = c) : (this.firstChild = c, this.lastChild = c);
              }, f.prototype.prependChild = function(c) {
                c.unlink(), c.parent = this, this.firstChild ? (this.firstChild.prev = c, c.next = this.firstChild, this.firstChild = c) : (this.firstChild = c, this.lastChild = c);
              }, f.prototype.walker = function() {
                return new Q5(this);
              }, f;
            }()
          ), jn = (
            /** @class */
            function(f) {
              P(c, f);
              function c(p, k) {
                var O = f.call(this, p, k) || this;
                return O.open = !0, O.lineOffsets = null, O.stringContent = null, O.lastLineBlank = !1, O.lastLineChecked = !1, O.type = p, O;
              }
              return c;
            }(Vi)
          ), r8 = (
            /** @class */
            function(f) {
              P(c, f);
              function c() {
                var p = f !== null && f.apply(this, arguments) || this;
                return p.listData = null, p;
              }
              return c;
            }(jn)
          ), n8 = (
            /** @class */
            function(f) {
              P(c, f);
              function c() {
                var p = f !== null && f.apply(this, arguments) || this;
                return p.level = 0, p.headingType = "atx", p;
              }
              return c;
            }(jn)
          ), a8 = (
            /** @class */
            function(f) {
              P(c, f);
              function c() {
                var p = f !== null && f.apply(this, arguments) || this;
                return p.isFenced = !1, p.fenceChar = null, p.fenceLength = 0, p.fenceOffset = -1, p.info = null, p.infoPadding = 0, p;
              }
              return c;
            }(jn)
          ), i8 = (
            /** @class */
            function(f) {
              P(c, f);
              function c() {
                var p = f !== null && f.apply(this, arguments) || this;
                return p.columns = [], p;
              }
              return c;
            }(jn)
          ), o8 = (
            /** @class */
            function(f) {
              P(c, f);
              function c() {
                var p = f !== null && f.apply(this, arguments) || this;
                return p.startIdx = 0, p.endIdx = 0, p.paddingLeft = 0, p.paddingRight = 0, p.ignored = !1, p;
              }
              return c;
            }(jn)
          ), s8 = (
            /** @class */
            function(f) {
              P(c, f);
              function c() {
                var p = f !== null && f.apply(this, arguments) || this;
                return p.title = "", p.dest = "", p.label = "", p;
              }
              return c;
            }(jn)
          ), l8 = (
            /** @class */
            function(f) {
              P(c, f);
              function c() {
                var p = f !== null && f.apply(this, arguments) || this;
                return p.syntaxLength = 0, p.offset = -1, p.info = "", p;
              }
              return c;
            }(jn)
          ), u8 = (
            /** @class */
            function(f) {
              P(c, f);
              function c() {
                var p = f !== null && f.apply(this, arguments) || this;
                return p.htmlBlockType = -1, p;
              }
              return c;
            }(jn)
          ), c8 = (
            /** @class */
            function(f) {
              P(c, f);
              function c() {
                var p = f !== null && f.apply(this, arguments) || this;
                return p.destination = null, p.title = null, p.extendedAutolink = !1, p;
              }
              return c;
            }(Vi)
          ), f8 = (
            /** @class */
            function(f) {
              P(c, f);
              function c() {
                var p = f !== null && f.apply(this, arguments) || this;
                return p.tickCount = 0, p;
              }
              return c;
            }(Vi)
          ), v8 = (
            /** @class */
            function(f) {
              P(c, f);
              function c() {
                var p = f !== null && f.apply(this, arguments) || this;
                return p.info = "", p;
              }
              return c;
            }(Vi)
          );
          function Xt(f, c) {
            switch (f) {
              case "heading":
                return new n8(f, c);
              case "list":
              case "item":
                return new r8(f, c);
              case "link":
              case "image":
                return new c8(f, c);
              case "codeBlock":
                return new a8(f, c);
              case "htmlBlock":
                return new u8(f, c);
              case "table":
                return new i8(f, c);
              case "tableCell":
                return new o8(f, c);
              case "document":
              case "paragraph":
              case "blockQuote":
              case "thematicBreak":
              case "tableRow":
              case "tableBody":
              case "tableHead":
              case "frontMatter":
                return new jn(f, c);
              case "code":
                return new f8(f, c);
              case "refDef":
                return new s8(f, c);
              case "customBlock":
                return new l8(f, c);
              case "customInline":
                return new v8(f, c);
              default:
                return new Vi(f, c);
            }
          }
          function hf(f) {
            return f.type === "codeBlock";
          }
          function d8(f) {
            return f.type === "htmlBlock";
          }
          function p8(f) {
            return f.type === "heading";
          }
          function mf(f) {
            return f.type === "list";
          }
          function h8(f) {
            return f.type === "table";
          }
          function ci(f) {
            return f.type === "refDef";
          }
          function gf(f) {
            return f.type === "customBlock";
          }
          function m8(f) {
            return f.type === "customInline";
          }
          function cr(f, c) {
            var p = Xt("text", c);
            return p.literal = f, p;
          }
          var yf = "[A-Za-z][A-Za-z0-9-]*", g8 = "[a-zA-Z_:][a-zA-Z0-9:._-]*", y8 = "[^\"'=<>`\\x00-\\x20]+", b8 = "'[^']*'", k8 = '"[^"]*"', w8 = "(?:" + y8 + "|" + b8 + "|" + k8 + ")", C8 = "(?:\\s*=\\s*" + w8 + ")", T8 = "(?:\\s+" + g8 + C8 + "?)", bf = "<" + yf + T8 + "*\\s*/?>", kf = "</" + yf + "\\s*[>]", S8 = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->", E8 = "[<][?].*?[?][>]", x8 = "<![A-Z]+\\s+[^>]*>", A8 = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", M8 = "(?:" + bf + "|" + kf + "|" + S8 + "|" + E8 + "|" + x8 + "|" + A8 + ")", L8 = new RegExp("^" + M8, "i");
          /*! http://mths.be/fromcodepoint v0.2.1 by @mathias */
          var zl;
          if (String.fromCodePoint)
            zl = function(f) {
              try {
                return String.fromCodePoint(f);
              } catch (c) {
                if (c instanceof RangeError)
                  return String.fromCharCode(65533);
                throw c;
              }
            };
          else {
            var O8 = String.fromCharCode, D8 = Math.floor;
            zl = function() {
              for (var f = [], c = 0; c < arguments.length; c++)
                f[c] = arguments[c];
              var p = 16384, k = [], O, U, j = -1, Q = f.length;
              if (!Q)
                return "";
              for (var ke = ""; ++j < Q; ) {
                var xe = Number(f[j]);
                if (!isFinite(xe) || // `NaN`, `+Infinity`, or `-Infinity`
                xe < 0 || // not a valid Unicode code point
                xe > 1114111 || // not a valid Unicode code point
                D8(xe) !== xe)
                  return String.fromCharCode(65533);
                xe <= 65535 ? k.push(xe) : (xe -= 65536, O = (xe >> 10) + 55296, U = xe % 1024 + 56320, k.push(O, U)), (j + 1 === Q || k.length > p) && (ke += O8.apply(void 0, k), k.length = 0);
              }
              return ke;
            };
          }
          var $l = zl, N8 = "(?:[w-]+.)*[A-Za-z0-9-]+.[A-Za-z0-9-]+", R8 = "[^<\\s]*[^<?!.,:*_?~\\s]", I8 = "[\\w.+-]+@(?:[\\w-]+\\.)+[\\w-]+";
          function P8(f) {
            var c = /\)+$/.exec(f);
            if (c) {
              for (var p = 0, k = 0, O = f; k < O.length; k++) {
                var U = O[k];
                U === "(" ? p < 0 ? p = 1 : p += 1 : U === ")" && (p -= 1);
              }
              if (p < 0) {
                var j = Math.min(-p, c[0].length);
                return f.substring(0, f.length - j);
              }
            }
            return f;
          }
          function B8(f) {
            return f.replace(/&[A-Za-z0-9]+;$/, "");
          }
          function q8(f) {
            for (var c = new RegExp(I8, "g"), p = [], k; k = c.exec(f); ) {
              var O = k[0];
              /[_-]+$/.test(O) || p.push({
                text: O,
                range: [k.index, k.index + O.length - 1],
                url: "mailto:" + O
              });
            }
            return p;
          }
          function F8(f) {
            for (var c = new RegExp("(www|https?://)." + N8 + R8, "g"), p = [], k; k = c.exec(f); ) {
              var O = B8(P8(k[0])), U = k[1] === "www" ? "http://" : "";
              p.push({
                text: O,
                range: [k.index, k.index + O.length - 1],
                url: "" + U + O
              });
            }
            return p;
          }
          function _8(f) {
            return _(_([], F8(f)), q8(f)).sort(function(c, p) {
              return c.range[0] - p.range[0];
            });
          }
          function H8(f, c) {
            typeof c == "boolean" && (c = _8);
            for (var p, k = function() {
              var O = p.entering, U = p.node;
              if (O && U.type === "text" && U.parent.type !== "link") {
                var j = U.literal, Q = c(j);
                if (!Q || !Q.length)
                  return "continue";
                for (var ke = 0, xe = U.sourcepos[0], Ue = xe[0], $e = xe[1], Be = function(Yn, Y6) {
                  return [
                    [Ue, $e + Yn],
                    [Ue, $e + Y6]
                  ];
                }, tt = [], et = 0, Lt = Q; et < Lt.length; et++) {
                  var er = Lt[et], yr = er.range, Gn = er.url, sn = er.text;
                  yr[0] > ke && tt.push(cr(j.substring(ke, yr[0]), Be(ke, yr[0] - 1)));
                  var Xr = Xt("link", Be.apply(void 0, yr));
                  Xr.appendChild(cr(sn, Be.apply(void 0, yr))), Xr.destination = Gn, Xr.extendedAutolink = !0, tt.push(Xr), ke = yr[1] + 1;
                }
                ke < j.length && tt.push(cr(j.substring(ke), Be(ke, j.length - 1)));
                for (var pn = 0, Kn = tt; pn < Kn.length; pn++) {
                  var Jn = Kn[pn];
                  U.insertBefore(Jn);
                }
                U.unlink();
              }
            }; p = f.next(); )
              k();
          }
          function qo(f) {
            return f[f.length - 1];
          }
          function wf(f) {
            return f.slice(1, f.length - 1).trim().replace(/[ \t\r\n]+/, " ").toLowerCase().toUpperCase();
          }
          function Fo(f, c) {
            Object.keys(f).forEach(function(p) {
              c(p, f[p]);
            });
          }
          function U8(f) {
            for (var c = [], p = 1; p < arguments.length; p++)
              c[p - 1] = arguments[p];
            var k = q({}, f);
            return c.forEach(function(O) {
              delete k[O];
            }), k;
          }
          function fi(f) {
            return !Object.keys(f).length;
          }
          function z8(f) {
            Object.keys(f).forEach(function(c) {
              delete f[c];
            });
          }
          var Vl = 10, Wl = 42, _o = 95, $8 = 96, Cf = 91, V8 = 93, Ho = 126, Tf = 60, W8 = 33, Sf = 92, j8 = 38, Ef = 40, jl = 41, G8 = 58, Ua = 39, za = 34, $a = 36, Gl = "\\\\" + Fl, xf = new RegExp(/[!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/), K8 = new RegExp('^(?:"(' + Gl + '|[^"\\x00])*"|' + ("'(" + Gl + "|[^'\\x00])*'") + "|" + ("\\((" + Gl + "|[^()\\x00])*\\))")), J8 = /^(?:<(?:[^<>\n\\\x00]|\\.)*>)/, Af = new RegExp("^" + Fl), Y8 = new RegExp("^" + vf, "i"), Z8 = /`+/, Q8 = /^`+/, X8 = /\.\.\./g, e9 = /--+/g, t9 = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/, r9 = /^<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\x00-\x20]*>/i, n9 = /^ *(?:\n *)?/, Kl = /^[ \t\n\x0b\x0c\x0d]/, Mf = /^\s/, a9 = / *$/, i9 = /^ */, Lf = /^ *(?:\n|$)/, o9 = /^\[(?:[^\\\[\]]|\\.){0,1000}\]/, s9 = /^[^\n`\[\]\\!<&*_'"~$]+/m, l9 = (
            /** @class */
            function() {
              function f(c) {
                this.subject = "", this.delimiters = null, this.brackets = null, this.pos = 0, this.lineStartNum = 0, this.lineIdx = 0, this.lineOffsets = [0], this.linePosOffset = 0, this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.options = c;
              }
              return f.prototype.sourcepos = function(c, p) {
                var k = this.linePosOffset + this.lineOffsets[this.lineIdx], O = this.lineStartNum + this.lineIdx, U = [O, c + k];
                return typeof p == "number" ? [U, [O, p + k]] : U;
              }, f.prototype.nextLine = function() {
                this.lineIdx += 1, this.linePosOffset = -this.pos;
              }, f.prototype.match = function(c) {
                var p = c.exec(this.subject.slice(this.pos));
                return p === null ? null : (this.pos += p.index + p[0].length, p[0]);
              }, f.prototype.peek = function() {
                return this.pos < this.subject.length ? this.subject.charCodeAt(this.pos) : -1;
              }, f.prototype.spnl = function() {
                return this.match(n9), !0;
              }, f.prototype.parseBackticks = function(c) {
                var p = this.pos + 1, k = this.match(Q8);
                if (k === null)
                  return !1;
                for (var O = this.pos, U; (U = this.match(Z8)) !== null; )
                  if (U === k) {
                    var j = this.subject.slice(O, this.pos - k.length), Q = this.sourcepos(p, this.pos), ke = j.split(`
`);
                    if (ke.length > 1) {
                      var xe = qo(ke);
                      this.lineIdx += ke.length - 1, this.linePosOffset = -(this.pos - xe.length - k.length), Q[1] = this.sourcepos(this.pos), j = ke.join(" ");
                    }
                    var Ue = Xt("code", Q);
                    return j.length > 0 && j.match(/[^ ]/) !== null && j[0] == " " && j[j.length - 1] == " " ? Ue.literal = j.slice(1, j.length - 1) : Ue.literal = j, Ue.tickCount = k.length, c.appendChild(Ue), !0;
                  }
                return this.pos = O, c.appendChild(cr(k, this.sourcepos(p, this.pos - 1))), !0;
              }, f.prototype.parseBackslash = function(c) {
                var p = this.subject, k;
                this.pos += 1;
                var O = this.pos;
                return this.peek() === Vl ? (this.pos += 1, k = Xt("linebreak", this.sourcepos(this.pos - 1, this.pos)), c.appendChild(k), this.nextLine()) : Af.test(p.charAt(this.pos)) ? (c.appendChild(cr(p.charAt(this.pos), this.sourcepos(O, this.pos))), this.pos += 1) : c.appendChild(cr("\\", this.sourcepos(O, O))), !0;
              }, f.prototype.parseAutolink = function(c) {
                var p, k, O, U = this.pos + 1;
                return (p = this.match(t9)) ? (k = p.slice(1, p.length - 1), O = Xt("link", this.sourcepos(U, this.pos)), O.destination = Po("mailto:" + k), O.title = "", O.appendChild(cr(k, this.sourcepos(U + 1, this.pos - 1))), c.appendChild(O), !0) : (p = this.match(r9)) ? (k = p.slice(1, p.length - 1), O = Xt("link", this.sourcepos(U, this.pos)), O.destination = Po(k), O.title = "", O.appendChild(cr(k, this.sourcepos(U + 1, this.pos - 1))), c.appendChild(O), !0) : !1;
              }, f.prototype.parseHtmlTag = function(c) {
                var p = this.pos + 1, k = this.match(L8);
                if (k === null)
                  return !1;
                var O = Xt("htmlInline", this.sourcepos(p, this.pos));
                return O.literal = k, c.appendChild(O), !0;
              }, f.prototype.scanDelims = function(c) {
                var p = 0, k = this.pos;
                if (c === Ua || c === za)
                  p++, this.pos++;
                else
                  for (; this.peek() === c; )
                    p++, this.pos++;
                if (p === 0 || p < 2 && (c === Ho || c === $a))
                  return this.pos = k, null;
                var O = k === 0 ? `
` : this.subject.charAt(k - 1), U = this.peek(), j;
                U === -1 ? j = `
` : j = $l(U);
                var Q = Mf.test(j), ke = xf.test(j), xe = Mf.test(O), Ue = xf.test(O), $e = !Q && (!ke || xe || Ue), Be = !xe && (!Ue || Q || ke), tt, et;
                return c === _o ? (tt = $e && (!Be || Ue), et = Be && (!$e || ke)) : c === Ua || c === za ? (tt = $e && !Be, et = Be) : c === $a ? (tt = !Q, et = !xe) : (tt = $e, et = Be), this.pos = k, { numdelims: p, canOpen: tt, canClose: et };
              }, f.prototype.handleDelim = function(c, p) {
                var k = this.scanDelims(c);
                if (!k)
                  return !1;
                var O = k.numdelims, U = this.pos + 1, j;
                this.pos += O, c === Ua ? j = "’" : c === za ? j = "“" : j = this.subject.slice(U - 1, this.pos);
                var Q = cr(j, this.sourcepos(U, this.pos));
                return p.appendChild(Q), (k.canOpen || k.canClose) && (this.options.smart || c !== Ua && c !== za) && (this.delimiters = {
                  cc: c,
                  numdelims: O,
                  origdelims: O,
                  node: Q,
                  previous: this.delimiters,
                  next: null,
                  canOpen: k.canOpen,
                  canClose: k.canClose
                }, this.delimiters.previous && (this.delimiters.previous.next = this.delimiters)), !0;
              }, f.prototype.removeDelimiter = function(c) {
                c.previous !== null && (c.previous.next = c.next), c.next === null ? this.delimiters = c.previous : c.next.previous = c.previous;
              }, f.prototype.removeDelimitersBetween = function(c, p) {
                c.next !== p && (c.next = p, p.previous = c);
              }, f.prototype.processEmphasis = function(c) {
                var p, k, O, U, j, Q, ke, xe = !1, Ue = (p = {}, p[_o] = [c, c, c], p[Wl] = [c, c, c], p[Ua] = [c], p[za] = [c], p[Ho] = [c], p[$a] = [c], p);
                for (O = this.delimiters; O !== null && O.previous !== c; )
                  O = O.previous;
                for (; O !== null; ) {
                  var $e = O.cc, Be = $e === _o || $e === Wl;
                  if (!O.canClose)
                    O = O.next;
                  else {
                    for (k = O.previous, ke = !1; k !== null && k !== c && k !== Ue[$e][Be ? O.origdelims % 3 : 0]; ) {
                      if (xe = Be && (O.canOpen || k.canClose) && O.origdelims % 3 !== 0 && (k.origdelims + O.origdelims) % 3 === 0, k.cc === O.cc && k.canOpen && !xe) {
                        ke = !0;
                        break;
                      }
                      k = k.previous;
                    }
                    if (U = O, Be || $e === Ho || $e === $a) {
                      if (!ke)
                        O = O.next;
                      else if (k) {
                        var tt = O.numdelims >= 2 && k.numdelims >= 2 ? 2 : 1, et = Be ? 0 : 1;
                        j = k.node, Q = O.node;
                        var Lt = Be ? tt === 1 ? "emph" : "strong" : "strike";
                        $e === $a && (Lt = "customInline");
                        var er = Xt(Lt), yr = j.sourcepos[1], Gn = Q.sourcepos[0];
                        er.sourcepos = [
                          [yr[0], yr[1] - tt + 1],
                          [Gn[0], Gn[1] + tt - 1]
                        ], j.sourcepos[1][1] -= tt, Q.sourcepos[0][1] += tt, j.literal = j.literal.slice(tt), Q.literal = Q.literal.slice(tt), k.numdelims -= tt, O.numdelims -= tt;
                        for (var sn = j.next, Xr = void 0; sn && sn !== Q; )
                          Xr = sn.next, sn.unlink(), er.appendChild(sn), sn = Xr;
                        if ($e === $a) {
                          var pn = er.firstChild, Kn = pn.literal || "", Jn = Kn.split(/\s/)[0];
                          er.info = Jn, Kn.length <= Jn.length ? pn.unlink() : (pn.sourcepos[0][1] += Jn.length, pn.literal = Kn.replace(Jn + " ", ""));
                        }
                        if (j.insertAfter(er), this.removeDelimitersBetween(k, O), k.numdelims <= et && (k.numdelims === 0 && j.unlink(), this.removeDelimiter(k)), O.numdelims <= et) {
                          O.numdelims === 0 && Q.unlink();
                          var Yn = O.next;
                          this.removeDelimiter(O), O = Yn;
                        }
                      }
                    } else
                      $e === Ua ? (O.node.literal = "’", ke && (k.node.literal = "‘"), O = O.next) : $e === za && (O.node.literal = "”", ke && (k.node.literal = "“"), O = O.next);
                    ke || (Ue[$e][Be ? U.origdelims % 3 : 0] = U.previous, U.canOpen || this.removeDelimiter(U));
                  }
                }
                for (; this.delimiters !== null && this.delimiters !== c; )
                  this.removeDelimiter(this.delimiters);
              }, f.prototype.parseLinkTitle = function() {
                var c = this.match(K8);
                return c === null ? null : $i(c.substr(1, c.length - 2));
              }, f.prototype.parseLinkDestination = function() {
                var c = this.match(J8);
                if (c === null) {
                  if (this.peek() === Tf)
                    return null;
                  for (var p = this.pos, k = 0, O = void 0; (O = this.peek()) !== -1; )
                    if (O === Sf && Af.test(this.subject.charAt(this.pos + 1)))
                      this.pos += 1, this.peek() !== -1 && (this.pos += 1);
                    else if (O === Ef)
                      this.pos += 1, k += 1;
                    else if (O === jl) {
                      if (k < 1)
                        break;
                      this.pos += 1, k -= 1;
                    } else {
                      if (Kl.exec($l(O)) !== null)
                        break;
                      this.pos += 1;
                    }
                  return this.pos === p && O !== jl || k !== 0 ? null : (c = this.subject.substr(p, this.pos - p), Po($i(c)));
                }
                return Po($i(c.substr(1, c.length - 2)));
              }, f.prototype.parseLinkLabel = function() {
                var c = this.match(o9);
                return c === null || c.length > 1001 ? 0 : c.length;
              }, f.prototype.parseOpenBracket = function(c) {
                var p = this.pos;
                this.pos += 1;
                var k = cr("[", this.sourcepos(this.pos, this.pos));
                return c.appendChild(k), this.addBracket(k, p, !1), !0;
              }, f.prototype.parseBang = function(c) {
                var p = this.pos;
                if (this.pos += 1, this.peek() === Cf) {
                  this.pos += 1;
                  var k = cr("![", this.sourcepos(this.pos - 1, this.pos));
                  c.appendChild(k), this.addBracket(k, p + 1, !0);
                } else {
                  var k = cr("!", this.sourcepos(this.pos, this.pos));
                  c.appendChild(k);
                }
                return !0;
              }, f.prototype.parseCloseBracket = function(c) {
                var p = null, k = null, O = !1;
                this.pos += 1;
                var U = this.pos, j = this.brackets;
                if (j === null)
                  return c.appendChild(cr("]", this.sourcepos(U, U))), !0;
                if (!j.active)
                  return c.appendChild(cr("]", this.sourcepos(U, U))), this.removeBracket(), !0;
                var Q = j.image, ke = this.pos;
                this.peek() === Ef && (this.pos++, this.spnl() && (p = this.parseLinkDestination()) !== null && this.spnl() && // make sure there's a space before the title:
                (Kl.test(this.subject.charAt(this.pos - 1)) && (k = this.parseLinkTitle()) || !0) && this.spnl() && this.peek() === jl ? (this.pos += 1, O = !0) : this.pos = ke);
                var xe = "";
                if (!O) {
                  var Ue = this.pos, $e = this.parseLinkLabel();
                  if ($e > 2 ? xe = this.subject.slice(Ue, Ue + $e) : j.bracketAfter || (xe = this.subject.slice(j.index, U)), $e === 0 && (this.pos = ke), xe) {
                    xe = wf(xe);
                    var Be = this.refMap[xe];
                    Be && (p = Be.destination, k = Be.title, O = !0);
                  }
                }
                if (O) {
                  var tt = Xt(Q ? "image" : "link");
                  tt.destination = p, tt.title = k || "", tt.sourcepos = [j.startpos, this.sourcepos(this.pos)];
                  for (var et = j.node.next, Lt = void 0; et; )
                    Lt = et.next, et.unlink(), tt.appendChild(et), et = Lt;
                  if (c.appendChild(tt), this.processEmphasis(j.previousDelimiter), this.removeBracket(), j.node.unlink(), !Q)
                    for (j = this.brackets; j !== null; )
                      j.image || (j.active = !1), j = j.previous;
                  return this.options.referenceDefinition && (this.refLinkCandidateMap[c.id] = { node: c, refLabel: xe }), !0;
                }
                return this.removeBracket(), this.pos = U, c.appendChild(cr("]", this.sourcepos(U, U))), this.options.referenceDefinition && (this.refLinkCandidateMap[c.id] = { node: c, refLabel: xe }), !0;
              }, f.prototype.addBracket = function(c, p, k) {
                this.brackets !== null && (this.brackets.bracketAfter = !0), this.brackets = {
                  node: c,
                  startpos: this.sourcepos(p + (k ? 0 : 1)),
                  previous: this.brackets,
                  previousDelimiter: this.delimiters,
                  index: p,
                  image: k,
                  active: !0
                };
              }, f.prototype.removeBracket = function() {
                this.brackets && (this.brackets = this.brackets.previous);
              }, f.prototype.parseEntity = function(c) {
                var p, k = this.pos + 1;
                return (p = this.match(Y8)) ? (c.appendChild(cr(ue.decodeHTML(p), this.sourcepos(k, this.pos))), !0) : !1;
              }, f.prototype.parseString = function(c) {
                var p, k = this.pos + 1;
                if (p = this.match(s9)) {
                  if (this.options.smart) {
                    var O = p.replace(X8, "…").replace(e9, function(j) {
                      var Q = 0, ke = 0;
                      return j.length % 3 === 0 ? ke = j.length / 3 : j.length % 2 === 0 ? Q = j.length / 2 : j.length % 3 === 2 ? (Q = 1, ke = (j.length - 2) / 3) : (Q = 2, ke = (j.length - 4) / 3), _l("—", ke) + _l("–", Q);
                    });
                    c.appendChild(cr(O, this.sourcepos(k, this.pos)));
                  } else {
                    var U = cr(p, this.sourcepos(k, this.pos));
                    c.appendChild(U);
                  }
                  return !0;
                }
                return !1;
              }, f.prototype.parseNewline = function(c) {
                this.pos += 1;
                var p = c.lastChild;
                if (p && p.type === "text" && p.literal[p.literal.length - 1] === " ") {
                  var k = p.literal[p.literal.length - 2] === " ", O = p.literal.length;
                  p.literal = p.literal.replace(a9, "");
                  var U = O - p.literal.length;
                  p.sourcepos[1][1] -= U, c.appendChild(Xt(k ? "linebreak" : "softbreak", this.sourcepos(this.pos - U, this.pos)));
                } else
                  c.appendChild(Xt("softbreak", this.sourcepos(this.pos, this.pos)));
                return this.nextLine(), this.match(i9), !0;
              }, f.prototype.parseReference = function(c, p) {
                if (!this.options.referenceDefinition)
                  return 0;
                this.subject = c.stringContent, this.pos = 0;
                var k = null, O = this.pos, U = this.parseLinkLabel();
                if (U === 0)
                  return 0;
                var j = this.subject.substr(0, U);
                if (this.peek() === G8)
                  this.pos++;
                else
                  return this.pos = O, 0;
                this.spnl();
                var Q = this.parseLinkDestination();
                if (Q === null)
                  return this.pos = O, 0;
                var ke = this.pos;
                this.spnl(), this.pos !== ke && (k = this.parseLinkTitle()), k === null && (k = "", this.pos = ke);
                var xe = !0;
                if (this.match(Lf) === null && (k === "" ? xe = !1 : (k = "", this.pos = ke, xe = this.match(Lf) !== null)), !xe)
                  return this.pos = O, 0;
                var Ue = wf(j);
                if (Ue === "")
                  return this.pos = O, 0;
                var $e = this.getReferenceDefSourcepos(c);
                c.sourcepos[0][0] = $e[1][0] + 1;
                var Be = Xt("refDef", $e);
                return Be.title = k, Be.dest = Q, Be.label = Ue, c.insertBefore(Be), p[Ue] ? this.refDefCandidateMap[Be.id] = Be : p[Ue] = eu(Be), this.pos - O;
              }, f.prototype.mergeTextNodes = function(c) {
                for (var p, k = []; p = c.next(); ) {
                  var O = p.entering, U = p.node;
                  if (O && U.type === "text")
                    k.push(U);
                  else if (k.length === 1)
                    k = [];
                  else if (k.length > 1) {
                    var j = k[0], Q = k[k.length - 1];
                    j.sourcepos && Q.sourcepos && (j.sourcepos[1] = Q.sourcepos[1]), j.next = Q.next, j.next && (j.next.prev = j);
                    for (var ke = 1; ke < k.length; ke += 1)
                      j.literal += k[ke].literal, k[ke].unlink();
                    k = [];
                  }
                }
              }, f.prototype.getReferenceDefSourcepos = function(c) {
                for (var p = c.stringContent.split(/\n|\r\n/), k = !1, O = 0, U = { line: 0, ch: 0 }, j = 0; j < p.length; j += 1) {
                  var Q = p[j];
                  if (Kl.test(Q))
                    break;
                  if (/\:/.test(Q) && O === 0) {
                    if (k)
                      break;
                    var ke = Q.indexOf(":") === Q.length - 1 ? j + 1 : j;
                    U = { line: ke, ch: p[ke].length }, k = !0;
                  }
                  var xe = Q.match(/'|"/g);
                  if (xe && (O += xe.length), O === 2) {
                    U = { line: j, ch: Q.length };
                    break;
                  }
                }
                return [
                  [c.sourcepos[0][0], c.sourcepos[0][1]],
                  [c.sourcepos[0][0] + U.line, U.ch]
                ];
              }, f.prototype.parseInline = function(c) {
                var p, k = !1, O = this.peek();
                if (O === -1)
                  return !1;
                switch (O) {
                  case Vl:
                    k = this.parseNewline(c);
                    break;
                  case Sf:
                    k = this.parseBackslash(c);
                    break;
                  case $8:
                    k = this.parseBackticks(c);
                    break;
                  case Wl:
                  case _o:
                  case Ho:
                  case $a:
                    k = this.handleDelim(O, c);
                    break;
                  case Ua:
                  case za:
                    k = !!(!((p = this.options) === null || p === void 0) && p.smart) && this.handleDelim(O, c);
                    break;
                  case Cf:
                    k = this.parseOpenBracket(c);
                    break;
                  case W8:
                    k = this.parseBang(c);
                    break;
                  case V8:
                    k = this.parseCloseBracket(c);
                    break;
                  case Tf:
                    k = this.parseAutolink(c) || this.parseHtmlTag(c);
                    break;
                  case j8:
                    c.disabledEntityParse || (k = this.parseEntity(c));
                    break;
                  default:
                    k = this.parseString(c);
                    break;
                }
                return k || (this.pos += 1, c.appendChild(cr($l(O), this.sourcepos(this.pos, this.pos + 1)))), !0;
              }, f.prototype.parse = function(c) {
                for (this.subject = c.stringContent.trim(), this.pos = 0, this.delimiters = null, this.brackets = null, this.lineOffsets = c.lineOffsets || [0], this.lineIdx = 0, this.linePosOffset = 0, this.lineStartNum = c.sourcepos[0][0], p8(c) && (this.lineOffsets[0] += c.level + 1); this.parseInline(c); )
                  ;
                c.stringContent = null, this.processEmphasis(null), this.mergeTextNodes(c.walker());
                var p = this.options, k = p.extendedAutolinks, O = p.customParser;
                if (k && H8(c.walker(), k), O && c.firstChild)
                  for (var U, j = c.firstChild.walker(); U = j.next(); ) {
                    var Q = U.node, ke = U.entering;
                    O[Q.type] && O[Q.type](Q, { entering: ke, options: this.options });
                  }
              }, f;
            }()
          ), u9 = /^\[([ \txX])\][ \t]+/;
          function c9(f, c) {
            if (c.firstChild && c.firstChild.type === "paragraph") {
              var p = c.firstChild, k = p.stringContent.match(u9);
              if (k) {
                var O = k[0].length;
                p.stringContent = p.stringContent.substring(O - 1), p.sourcepos[0][1] += O, p.lineOffsets[0] += O, c.listData.task = !0, c.listData.checked = /[xX]/.test(k[1]);
              }
            }
          }
          var f9 = {
            continue: function() {
              return 0;
            },
            finalize: function() {
            },
            canContain: function(f) {
              return f === "tableHead" || f === "tableBody";
            },
            acceptsLines: !1
          }, v9 = {
            continue: function() {
              return 0;
            },
            finalize: function() {
            },
            canContain: function(f) {
              return f === "tableRow";
            },
            acceptsLines: !1
          }, d9 = {
            continue: function() {
              return 1;
            },
            finalize: function() {
            },
            canContain: function(f) {
              return f === "tableRow" || f === "tableDelimRow";
            },
            acceptsLines: !1
          }, p9 = {
            continue: function() {
              return 1;
            },
            finalize: function() {
            },
            canContain: function(f) {
              return f === "tableDelimCell";
            },
            acceptsLines: !1
          }, h9 = {
            continue: function() {
              return 1;
            },
            finalize: function() {
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !1
          }, m9 = {
            continue: function() {
              return 1;
            },
            finalize: function() {
            },
            canContain: function(f) {
              return f === "tableCell";
            },
            acceptsLines: !1
          }, g9 = {
            continue: function() {
              return 1;
            },
            finalize: function() {
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !1
          }, Uo = 4, Of = 9, Df = 62, y9 = 60, Nf = 32, Rf = 91, If = /[^ \t\f\v\r\n]/, b9 = /^(?:`{3,}|~{3,})(?= *$)/;
          function Pf(f) {
            for (var c = f; c; ) {
              if (c.lastLineBlank)
                return !0;
              var p = c.type;
              if (!c.lastLineChecked && (p === "list" || p === "item"))
                c.lastLineChecked = !0, c = c.lastChild;
              else {
                c.lastLineChecked = !0;
                break;
              }
            }
            return !1;
          }
          function Qr(f, c) {
            return c < f.length ? f.charCodeAt(c) : -1;
          }
          function Bf(f) {
            return !If.test(f);
          }
          function vi(f) {
            return f === Nf || f === Of;
          }
          var k9 = /^\$\$$/, w9 = {
            continue: function(f, c) {
              var p = f.currentLine, k = p.match(k9);
              if (k)
                return f.lastLineLength = k[0].length, f.finalize(c, f.lineNumber), 2;
              for (var O = c.offset; O > 0 && vi(Qr(p, f.offset)); )
                f.advanceOffset(1, !0), O--;
              return 0;
            },
            finalize: function(f, c) {
              if (c.stringContent !== null) {
                var p = c.stringContent, k = p.indexOf(`
`), O = p.slice(0, k), U = p.slice(k + 1), j = O.match(/^(\s*)(.*)/);
                c.info = $i(j[2].trim()), c.literal = U, c.stringContent = null;
              }
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !0
          }, qf = {
            continue: function() {
              return 1;
            },
            finalize: function() {
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !0
          }, C9 = {
            continue: function() {
              return 0;
            },
            finalize: function() {
            },
            canContain: function(f) {
              return f !== "item";
            },
            acceptsLines: !1
          }, T9 = {
            continue: function() {
              return 0;
            },
            finalize: function(f, c) {
              for (var p = c.firstChild; p; ) {
                if (Pf(p) && p.next) {
                  c.listData.tight = !1;
                  break;
                }
                for (var k = p.firstChild; k; ) {
                  if (Pf(k) && (p.next || k.next)) {
                    c.listData.tight = !1;
                    break;
                  }
                  k = k.next;
                }
                p = p.next;
              }
            },
            canContain: function(f) {
              return f === "item";
            },
            acceptsLines: !1
          }, S9 = {
            continue: function(f) {
              var c = f.currentLine;
              if (!f.indented && Qr(c, f.nextNonspace) === Df)
                f.advanceNextNonspace(), f.advanceOffset(1, !1), vi(Qr(c, f.offset)) && f.advanceOffset(1, !0);
              else
                return 1;
              return 0;
            },
            finalize: function() {
            },
            canContain: function(f) {
              return f !== "item";
            },
            acceptsLines: !1
          }, E9 = {
            continue: function(f, c) {
              if (f.blank) {
                if (c.firstChild === null)
                  return 1;
                f.advanceNextNonspace();
              } else if (f.indent >= c.listData.markerOffset + c.listData.padding)
                f.advanceOffset(c.listData.markerOffset + c.listData.padding, !0);
              else
                return 1;
              return 0;
            },
            finalize: c9,
            canContain: function(f) {
              return f !== "item";
            },
            acceptsLines: !1
          }, x9 = {
            continue: function() {
              return 1;
            },
            finalize: function() {
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !1
          }, A9 = {
            continue: function() {
              return 1;
            },
            finalize: function() {
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !1
          }, M9 = {
            continue: function(f, c) {
              var p = f.currentLine, k = f.indent;
              if (c.isFenced) {
                var O = k <= 3 && p.charAt(f.nextNonspace) === c.fenceChar && p.slice(f.nextNonspace).match(b9);
                if (O && O[0].length >= c.fenceLength)
                  return f.lastLineLength = f.offset + k + O[0].length, f.finalize(c, f.lineNumber), 2;
                for (var U = c.fenceOffset; U > 0 && vi(Qr(p, f.offset)); )
                  f.advanceOffset(1, !0), U--;
              } else if (k >= Uo)
                f.advanceOffset(Uo, !0);
              else if (f.blank)
                f.advanceNextNonspace();
              else
                return 1;
              return 0;
            },
            finalize: function(f, c) {
              var p;
              if (c.stringContent !== null) {
                if (c.isFenced) {
                  var k = c.stringContent, O = k.indexOf(`
`), U = k.slice(0, O), j = k.slice(O + 1), Q = U.match(/^(\s*)(.*)/);
                  c.infoPadding = Q[1].length, c.info = $i(Q[2].trim()), c.literal = j;
                } else
                  c.literal = (p = c.stringContent) === null || p === void 0 ? void 0 : p.replace(/(\n *)+$/, `
`);
                c.stringContent = null;
              }
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !0
          }, L9 = {
            continue: function(f, c) {
              return f.blank && (c.htmlBlockType === 6 || c.htmlBlockType === 7) ? 1 : 0;
            },
            finalize: function(f, c) {
              var p;
              c.literal = ((p = c.stringContent) === null || p === void 0 ? void 0 : p.replace(/(\n *)+$/, "")) || null, c.stringContent = null;
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !0
          }, O9 = {
            continue: function(f) {
              return f.blank ? 1 : 0;
            },
            finalize: function(f, c) {
              if (c.stringContent !== null) {
                for (var p, k = !1; Qr(c.stringContent, 0) === Rf && (p = f.inlineParser.parseReference(c, f.refMap)); )
                  c.stringContent = c.stringContent.slice(p), k = !0;
                k && Bf(c.stringContent) && c.unlink();
              }
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !0
          }, D9 = qf, N9 = qf, di = {
            document: C9,
            list: T9,
            blockQuote: S9,
            item: E9,
            heading: x9,
            thematicBreak: A9,
            codeBlock: M9,
            htmlBlock: L9,
            paragraph: O9,
            table: f9,
            tableBody: v9,
            tableHead: d9,
            tableRow: m9,
            tableCell: g9,
            tableDelimRow: p9,
            tableDelimCell: h9,
            refDef: D9,
            customBlock: w9,
            frontMatter: N9
          };
          function Jl(f) {
            for (var c = 0, p = 0, k = [], O = 0; O < f.length; O += 1)
              if (f[O] === "|" && f[O - 1] !== "\\") {
                var U = f.substring(c, O);
                c === 0 && pf(U) ? p = O + 1 : k.push(U), c = O + 1;
              }
            if (c < f.length) {
              var U = f.substring(c, f.length);
              pf(U) || k.push(U);
            }
            return [p, k];
          }
          function Yl(f, c, p, k) {
            for (var O = [], U = 0, j = c; U < j.length; U++) {
              var Q = j[U], ke = Q.match(/^[ \t]+/), xe = ke ? ke[0].length : 0, Ue = void 0, $e = void 0;
              if (xe === Q.length)
                xe = 0, Ue = 0, $e = "";
              else {
                var Be = Q.match(/[ \t]+$/);
                Ue = Be ? Be[0].length : 0, $e = Q.slice(xe, Q.length - Ue);
              }
              var tt = k + xe, et = Xt(f, [
                [p, k],
                [p, k + Q.length - 1]
              ]);
              et.stringContent = $e.replace(/\\\|/g, "|"), et.startIdx = O.length, et.endIdx = O.length, et.lineOffsets = [tt - 1], et.paddingLeft = xe, et.paddingRight = Ue, O.push(et), k += Q.length + 1;
            }
            return O;
          }
          function R9(f) {
            var c = null, p = f.stringContent, k = p[0], O = p[p.length - 1];
            return O === ":" ? c = k === ":" ? "center" : "right" : k === ":" && (c = "left"), { align: c };
          }
          var I9 = function(f, c) {
            var p = c.stringContent;
            if (c.type === "paragraph" && !f.indented && !f.blank) {
              var k = p.length - 1, O = p.lastIndexOf(`
`, k - 1) + 1, U = p.slice(O, k), j = f.currentLine.slice(f.nextNonspace), Q = Jl(U), ke = Q[0], xe = Q[1], Ue = Jl(j), $e = Ue[0], Be = Ue[1], tt = /^[ \t]*:?-+:?[ \t]*$/;
              if (
                // not checking if the number of header cells and delimiter cells are the same
                // to consider the case of merged-column (via plugin)
                !xe.length || !Be.length || Be.some(function(Yn) {
                  return !tt.test(Yn);
                }) || // to prevent to regard setTextHeading as tabel delim cell with 'disallowDeepHeading' option
                Be.length === 1 && j.indexOf("|") !== 0
              )
                return 0;
              var et = c.lineOffsets, Lt = f.lineNumber - 1, er = qo(et) + 1, yr = Xt("table", [
                [Lt, er],
                [f.lineNumber, f.offset]
              ]);
              if (yr.columns = Be.map(function() {
                return { align: null };
              }), c.insertAfter(yr), et.length === 1)
                c.unlink();
              else {
                c.stringContent = p.slice(0, O);
                var Gn = p.lastIndexOf(`
`, O - 2) + 1, sn = O - Gn - 1;
                f.lastLineLength = et[et.length - 2] + sn, f.finalize(c, Lt - 1);
              }
              f.advanceOffset(f.currentLine.length - f.offset, !1);
              var Xr = Xt("tableHead", [
                [Lt, er],
                [f.lineNumber, f.offset]
              ]);
              yr.appendChild(Xr);
              var pn = Xt("tableRow", [
                [Lt, er],
                [Lt, er + U.length - 1]
              ]), Kn = Xt("tableDelimRow", [
                [f.lineNumber, f.nextNonspace + 1],
                [f.lineNumber, f.offset]
              ]);
              Xr.appendChild(pn), Xr.appendChild(Kn), Yl("tableCell", xe, Lt, er + ke).forEach(function(Yn) {
                pn.appendChild(Yn);
              });
              var Jn = Yl("tableDelimCell", Be, f.lineNumber, f.nextNonspace + 1 + $e);
              return Jn.forEach(function(Yn) {
                Kn.appendChild(Yn);
              }), yr.columns = Jn.map(R9), f.tip = yr, 2;
            }
            return 0;
          }, P9 = function(f, c) {
            if (c.type !== "table" && c.type !== "tableBody" || !f.blank && f.currentLine.indexOf("|") === -1)
              return 0;
            if (f.advanceOffset(f.currentLine.length - f.offset, !1), f.blank) {
              var p = c;
              return c.type === "tableBody" && (p = c.parent, f.finalize(c, f.lineNumber - 1)), f.finalize(p, f.lineNumber - 1), 0;
            }
            var k = c;
            c.type === "table" && (k = f.addChild("tableBody", f.nextNonspace), k.stringContent = null);
            var O = Xt("tableRow", [
              [f.lineNumber, f.nextNonspace + 1],
              [f.lineNumber, f.currentLine.length]
            ]);
            k.appendChild(O);
            var U = k.parent, j = f.currentLine.slice(f.nextNonspace), Q = Jl(j), ke = Q[0], xe = Q[1];
            return Yl("tableCell", xe, f.lineNumber, f.nextNonspace + 1 + ke).forEach(function(Ue, $e) {
              $e >= U.columns.length && (Ue.ignored = !0), O.appendChild(Ue);
            }), 2;
          }, B9 = /^(\$\$)(\s*[a-zA-Z])+/, q9 = /^(\$\$)(\s*[a-zA-Z])+.*(\$\$)/, F9 = function(f) {
            var c;
            if (!f.indented && !q9.test(f.currentLine) && (c = f.currentLine.match(B9))) {
              var p = c[1].length;
              f.closeUnmatchedBlocks();
              var k = f.addChild("customBlock", f.nextNonspace);
              return k.syntaxLength = p, k.offset = f.indent, f.advanceNextNonspace(), f.advanceOffset(p, !1), 2;
            }
            return 0;
          }, _9 = /^`{3,}(?!.*`)|^~{3,}/, H9 = [
            /./,
            /^<(?:script|pre|style)(?:\s|>|$)/i,
            /^<!--/,
            /^<[?]/,
            /^<![A-Z]/,
            /^<!\[CDATA\[/,
            /^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[123456]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|[/]?[>]|$)/i,
            new RegExp("^(?:" + bf + "|" + kf + ")\\s*$", "i")
          ], U9 = /^(?:=+|-+)[ \t]*$/, z9 = /^#{1,6}(?:[ \t]+|$)/, $9 = /^(?:(?:\*[ \t]*){3,}|(?:_[ \t]*){3,}|(?:-[ \t]*){3,})[ \t]*$/, Ff = /^[*+-]/, _f = /^(\d{1,9})([.)])/;
          function V9(f, c) {
            var p = f.currentLine.slice(f.nextNonspace), k, O, U = {
              type: "bullet",
              tight: !0,
              bulletChar: "",
              start: 0,
              delimiter: "",
              padding: 0,
              markerOffset: f.indent,
              // GFM: Task List Item
              task: !1,
              checked: !1
            };
            if (f.indent >= 4)
              return null;
            if (k = p.match(Ff))
              U.type = "bullet", U.bulletChar = k[0][0];
            else if ((k = p.match(_f)) && (c.type !== "paragraph" || k[1] === "1"))
              U.type = "ordered", U.start = parseInt(k[1], 10), U.delimiter = k[2];
            else
              return null;
            if (O = Qr(f.currentLine, f.nextNonspace + k[0].length), !(O === -1 || O === Of || O === Nf) || c.type === "paragraph" && !f.currentLine.slice(f.nextNonspace + k[0].length).match(If))
              return null;
            f.advanceNextNonspace(), f.advanceOffset(k[0].length, !0);
            var j = f.column, Q = f.offset;
            do
              f.advanceOffset(1, !0), O = Qr(f.currentLine, f.offset);
            while (f.column - j < 5 && vi(O));
            var ke = Qr(f.currentLine, f.offset) === -1, xe = f.column - j;
            return xe >= 5 || xe < 1 || ke ? (U.padding = k[0].length + 1, f.column = j, f.offset = Q, vi(Qr(f.currentLine, f.offset)) && f.advanceOffset(1, !0)) : U.padding = k[0].length + xe, U;
          }
          function W9(f, c) {
            return f.type === c.type && f.delimiter === c.delimiter && f.bulletChar === c.bulletChar;
          }
          function Hf(f, c) {
            return f.options.disallowDeepHeading && (c.type === "blockQuote" || c.type === "item");
          }
          var j9 = function(f) {
            return !f.indented && Qr(f.currentLine, f.nextNonspace) === Df ? (f.advanceNextNonspace(), f.advanceOffset(1, !1), vi(Qr(f.currentLine, f.offset)) && f.advanceOffset(1, !0), f.closeUnmatchedBlocks(), f.addChild("blockQuote", f.nextNonspace), 1) : 0;
          }, G9 = function(f, c) {
            var p;
            if (!f.indented && // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option
            !Hf(f, c) && (p = f.currentLine.slice(f.nextNonspace).match(z9))) {
              f.advanceNextNonspace(), f.advanceOffset(p[0].length, !1), f.closeUnmatchedBlocks();
              var k = f.addChild("heading", f.nextNonspace);
              return k.level = p[0].trim().length, k.headingType = "atx", k.stringContent = f.currentLine.slice(f.offset).replace(/^[ \t]*#+[ \t]*$/, "").replace(/[ \t]+#+[ \t]*$/, ""), f.advanceOffset(f.currentLine.length - f.offset), 2;
            }
            return 0;
          }, K9 = function(f) {
            var c;
            if (!f.indented && (c = f.currentLine.slice(f.nextNonspace).match(_9))) {
              var p = c[0].length;
              f.closeUnmatchedBlocks();
              var k = f.addChild("codeBlock", f.nextNonspace);
              return k.isFenced = !0, k.fenceLength = p, k.fenceChar = c[0][0], k.fenceOffset = f.indent, f.advanceNextNonspace(), f.advanceOffset(p, !1), 2;
            }
            return 0;
          }, J9 = function(f, c) {
            if (!f.indented && Qr(f.currentLine, f.nextNonspace) === y9) {
              var p = f.currentLine.slice(f.nextNonspace), k = f.options.disallowedHtmlBlockTags, O = void 0;
              for (O = 1; O <= 7; O++) {
                var U = p.match(H9[O]);
                if (U) {
                  if (O === 7) {
                    if (c.type === "paragraph")
                      return 0;
                    if (k.length > 0) {
                      var j = new RegExp("</?(?:" + k.join("|") + ")", "i");
                      if (j.test(U[0]))
                        return 0;
                    }
                  }
                  f.closeUnmatchedBlocks();
                  var Q = f.addChild("htmlBlock", f.offset);
                  return Q.htmlBlockType = O, 2;
                }
              }
            }
            return 0;
          }, Y9 = function(f, c) {
            var p;
            if (c.stringContent !== null && !f.indented && c.type === "paragraph" && // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option
            !Hf(f, c.parent) && (p = f.currentLine.slice(f.nextNonspace).match(U9))) {
              f.closeUnmatchedBlocks();
              for (var k = void 0; Qr(c.stringContent, 0) === Rf && (k = f.inlineParser.parseReference(c, f.refMap)); )
                c.stringContent = c.stringContent.slice(k);
              if (c.stringContent.length > 0) {
                var O = Xt("heading", c.sourcepos);
                return O.level = p[0][0] === "=" ? 1 : 2, O.headingType = "setext", O.stringContent = c.stringContent, c.insertAfter(O), c.unlink(), f.tip = O, f.advanceOffset(f.currentLine.length - f.offset, !1), 2;
              }
              return 0;
            }
            return 0;
          }, Z9 = function(f) {
            return !f.indented && $9.test(f.currentLine.slice(f.nextNonspace)) ? (f.closeUnmatchedBlocks(), f.addChild("thematicBreak", f.nextNonspace), f.advanceOffset(f.currentLine.length - f.offset, !1), 2) : 0;
          }, Q9 = function(f, c) {
            var p, k = c;
            return (!f.indented || c.type === "list") && (p = V9(f, k)) ? (f.closeUnmatchedBlocks(), (f.tip.type !== "list" || !W9(k.listData, p)) && (k = f.addChild("list", f.nextNonspace), k.listData = p), k = f.addChild("item", f.nextNonspace), k.listData = p, 1) : 0;
          }, X9 = function(f) {
            return f.indented && f.tip.type !== "paragraph" && !f.blank ? (f.advanceOffset(Uo, !0), f.closeUnmatchedBlocks(), f.addChild("codeBlock", f.offset), 2) : 0;
          }, Zl = [
            j9,
            G9,
            K9,
            J9,
            Y9,
            Z9,
            Q9,
            X9,
            I9,
            P9,
            F9
          ], Uf = /^(-{3}|\+{3}|;{3})$/, eK = function(f, c) {
            var p = f.currentLine, k = f.lineNumber, O = f.indented;
            if (k === 1 && !O && c.type === "document" && Uf.test(p)) {
              f.closeUnmatchedBlocks();
              var U = f.addChild("frontMatter", f.nextNonspace);
              return U.stringContent = p, f.advanceNextNonspace(), f.advanceOffset(p.length, !1), 2;
            }
            return 0;
          }, tK = {
            continue: function(f, c) {
              var p = f.currentLine, k = p.match(Uf);
              return c.type === "frontMatter" && k ? (c.stringContent += p, f.lastLineLength = k[0].length, f.finalize(c, f.lineNumber), 2) : 0;
            },
            finalize: function(f, c) {
              c.stringContent !== null && (c.literal = c.stringContent, c.stringContent = null);
            },
            canContain: function() {
              return !1;
            },
            acceptsLines: !0
          }, rK = [
            /./,
            /<\/(?:script|pre|style)>/i,
            /-->/,
            /\?>/,
            />/,
            /\]\]>/
          ], nK = /^[#`~*+_=<>0-9-;$]/, aK = /\r\n|\n|\r/;
          function Ql() {
            return Xt("document", [
              [1, 1],
              [0, 0]
            ]);
          }
          var iK = {
            smart: !1,
            tagFilter: !1,
            extendedAutolinks: !1,
            disallowedHtmlBlockTags: [],
            referenceDefinition: !1,
            disallowDeepHeading: !1,
            customParser: null,
            frontMatter: !1
          }, oK = (
            /** @class */
            function() {
              function f(c) {
                this.options = q(q({}, iK), c), this.doc = Ql(), this.tip = this.doc, this.oldtip = this.doc, this.lineNumber = 0, this.offset = 0, this.column = 0, this.nextNonspace = 0, this.nextNonspaceColumn = 0, this.indent = 0, this.currentLine = "", this.indented = !1, this.blank = !1, this.partiallyConsumedTab = !1, this.allClosed = !0, this.lastMatchedContainer = this.doc, this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.lastLineLength = 0, this.lines = [], this.options.frontMatter && (di.frontMatter = tK, Zl.unshift(eK)), this.inlineParser = new l9(this.options);
              }
              return f.prototype.advanceOffset = function(c, p) {
                p === void 0 && (p = !1);
                for (var k = this.currentLine, O, U, j; c > 0 && (j = k[this.offset]); )
                  j === "	" ? (O = 4 - this.column % 4, p ? (this.partiallyConsumedTab = O > c, U = O > c ? c : O, this.column += U, this.offset += this.partiallyConsumedTab ? 0 : 1, c -= U) : (this.partiallyConsumedTab = !1, this.column += O, this.offset += 1, c -= 1)) : (this.partiallyConsumedTab = !1, this.offset += 1, this.column += 1, c -= 1);
              }, f.prototype.advanceNextNonspace = function() {
                this.offset = this.nextNonspace, this.column = this.nextNonspaceColumn, this.partiallyConsumedTab = !1;
              }, f.prototype.findNextNonspace = function() {
                for (var c = this.currentLine, p = this.offset, k = this.column, O; (O = c.charAt(p)) !== ""; )
                  if (O === " ")
                    p++, k++;
                  else if (O === "	")
                    p++, k += 4 - k % 4;
                  else
                    break;
                this.blank = O === `
` || O === "\r" || O === "", this.nextNonspace = p, this.nextNonspaceColumn = k, this.indent = this.nextNonspaceColumn - this.column, this.indented = this.indent >= Uo;
              }, f.prototype.addLine = function() {
                if (this.partiallyConsumedTab) {
                  this.offset += 1;
                  var c = 4 - this.column % 4;
                  this.tip.stringContent += _l(" ", c);
                }
                this.tip.lineOffsets ? this.tip.lineOffsets.push(this.offset) : this.tip.lineOffsets = [this.offset], this.tip.stringContent += this.currentLine.slice(this.offset) + `
`;
              }, f.prototype.addChild = function(c, p) {
                for (; !di[this.tip.type].canContain(c); )
                  this.finalize(this.tip, this.lineNumber - 1);
                var k = p + 1, O = Xt(c, [
                  [this.lineNumber, k],
                  [0, 0]
                ]);
                return O.stringContent = "", this.tip.appendChild(O), this.tip = O, O;
              }, f.prototype.closeUnmatchedBlocks = function() {
                if (!this.allClosed) {
                  for (; this.oldtip !== this.lastMatchedContainer; ) {
                    var c = this.oldtip.parent;
                    this.finalize(this.oldtip, this.lineNumber - 1), this.oldtip = c;
                  }
                  this.allClosed = !0;
                }
              }, f.prototype.finalize = function(c, p) {
                var k = c.parent;
                c.open = !1, c.sourcepos[1] = [p, this.lastLineLength], di[c.type].finalize(this, c), this.tip = k;
              }, f.prototype.processInlines = function(c) {
                var p, k = this.options.customParser, O = c.walker();
                for (this.inlineParser.refMap = this.refMap, this.inlineParser.refLinkCandidateMap = this.refLinkCandidateMap, this.inlineParser.refDefCandidateMap = this.refDefCandidateMap, this.inlineParser.options = this.options; p = O.next(); ) {
                  var U = p.node, j = p.entering, Q = U.type;
                  k && k[Q] && k[Q](U, { entering: j, options: this.options }), !j && (Q === "paragraph" || Q === "heading" || Q === "tableCell" && !U.ignored) && this.inlineParser.parse(U);
                }
              }, f.prototype.incorporateLine = function(c) {
                var p = this.doc;
                this.oldtip = this.tip, this.offset = 0, this.column = 0, this.blank = !1, this.partiallyConsumedTab = !1, this.lineNumber += 1, c.indexOf("\0") !== -1 && (c = c.replace(/\0/g, "�")), this.currentLine = c;
                for (var k = !0, O; (O = p.lastChild) && O.open; ) {
                  switch (p = O, this.findNextNonspace(), di[p.type].continue(this, p)) {
                    case 0:
                      break;
                    case 1:
                      k = !1;
                      break;
                    case 2:
                      this.lastLineLength = c.length;
                      return;
                    default:
                      throw new Error("continue returned illegal value, must be 0, 1, or 2");
                  }
                  if (!k) {
                    p = p.parent;
                    break;
                  }
                }
                this.allClosed = p === this.oldtip, this.lastMatchedContainer = p;
                for (var U = p.type !== "paragraph" && di[p.type].acceptsLines, j = Zl.length; !U; ) {
                  if (this.findNextNonspace(), p.type !== "table" && p.type !== "tableBody" && p.type !== "paragraph" && !this.indented && !nK.test(c.slice(this.nextNonspace))) {
                    this.advanceNextNonspace();
                    break;
                  }
                  for (var Q = 0; Q < j; ) {
                    var ke = Zl[Q](this, p);
                    if (ke === 1) {
                      p = this.tip;
                      break;
                    } else if (ke === 2) {
                      p = this.tip, U = !0;
                      break;
                    } else
                      Q++;
                  }
                  if (Q === j) {
                    this.advanceNextNonspace();
                    break;
                  }
                }
                if (!this.allClosed && !this.blank && this.tip.type === "paragraph")
                  this.addLine();
                else {
                  this.closeUnmatchedBlocks(), this.blank && p.lastChild && (p.lastChild.lastLineBlank = !0);
                  for (var xe = p.type, Ue = this.blank && !(xe === "blockQuote" || hf(p) && p.isFenced || xe === "item" && !p.firstChild && p.sourcepos[0][0] === this.lineNumber), $e = p; $e; )
                    $e.lastLineBlank = Ue, $e = $e.parent;
                  di[xe].acceptsLines ? (this.addLine(), d8(p) && p.htmlBlockType >= 1 && p.htmlBlockType <= 5 && rK[p.htmlBlockType].test(this.currentLine.slice(this.offset)) && (this.lastLineLength = c.length, this.finalize(p, this.lineNumber))) : this.offset < c.length && !this.blank && (p = this.addChild("paragraph", this.offset), this.advanceNextNonspace(), this.addLine());
                }
                this.lastLineLength = c.length;
              }, f.prototype.parse = function(c, p) {
                this.doc = Ql(), this.tip = this.doc, this.lineNumber = 0, this.lastLineLength = 0, this.offset = 0, this.column = 0, this.lastMatchedContainer = this.doc, this.currentLine = "";
                var k = c.split(aK), O = k.length;
                this.lines = p || k, this.options.referenceDefinition && this.clearRefMaps(), c.charCodeAt(c.length - 1) === Vl && (O -= 1);
                for (var U = 0; U < O; U++)
                  this.incorporateLine(k[U]);
                for (; this.tip; )
                  this.finalize(this.tip, O);
                return this.processInlines(this.doc), this.doc;
              }, f.prototype.partialParseStart = function(c, p) {
                this.doc = Ql(), this.tip = this.doc, this.lineNumber = c - 1, this.lastLineLength = 0, this.offset = 0, this.column = 0, this.lastMatchedContainer = this.doc, this.currentLine = "";
                for (var k = p.length, O = 0; O < k; O++)
                  this.incorporateLine(p[O]);
                return this.doc;
              }, f.prototype.partialParseExtends = function(c) {
                for (var p = 0; p < c.length; p++)
                  this.incorporateLine(c[p]);
              }, f.prototype.partialParseFinish = function() {
                for (; this.tip; )
                  this.finalize(this.tip, this.lineNumber);
                this.processInlines(this.doc);
              }, f.prototype.setRefMaps = function(c, p, k) {
                this.refMap = c, this.refLinkCandidateMap = p, this.refDefCandidateMap = k;
              }, f.prototype.clearRefMaps = function() {
                [this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function(c) {
                  z8(c);
                });
              }, f;
            }()
          );
          function zf(f, c) {
            return f[0] < c[0] ? 1 : f[0] > c[0] ? -1 : f[1] < c[1] ? 1 : f[1] > c[1] ? -1 : 0;
          }
          function sK(f, c) {
            var p = f[0], k = f[1];
            return zf(k, c) === 1 ? 1 : zf(p, c) === -1 ? -1 : 0;
          }
          function lK(f, c) {
            if (!(f.parent !== c.parent || f === c)) {
              for (var p = f.next; p && p !== c; ) {
                for (var k = p.next, O = 0, U = ["parent", "prev", "next"]; O < U.length; O++) {
                  var j = U[O];
                  p[j] && (Ul(p[j].id), p[j] = null);
                }
                p = k;
              }
              f.next = c.next, c.next ? c.next.prev = f : f.parent.lastChild = f;
            }
          }
          function uK(f) {
            for (var c = [], p = f.firstChild; p; )
              c.push(p), p = p.next;
            return c;
          }
          function $f(f, c) {
            for (var p = 0, k = c; p < k.length; p++) {
              var O = k[p];
              f.insertBefore(O);
            }
          }
          function cK(f, c) {
            for (var p = c.length - 1; p >= 0; p -= 1)
              f.prependChild(c[p]);
          }
          function fK(f, c) {
            if (!(!f || !f.parent || c === 0)) {
              var p = f.parent.walker();
              p.resumeAt(f, !0);
              for (var k; k = p.next(); ) {
                var O = k.node, U = k.entering;
                U && (O.sourcepos[0][0] += c, O.sourcepos[1][0] += c);
              }
            }
          }
          function Vf(f, c) {
            var p = f[0], k = f[1];
            return k[0] < c ? 1 : p[0] > c ? -1 : 0;
          }
          function zo(f, c) {
            for (var p = f.firstChild; p; ) {
              var k = Vf(p.sourcepos, c);
              if (k === 0)
                return p;
              if (k === -1)
                return p.prev || p;
              p = p.next;
            }
            return f.lastChild;
          }
          function vK(f) {
            for (; f.lastChild; )
              f = f.lastChild;
            return f;
          }
          function dK(f) {
            for (; f.parent && f.parent.type !== "document" && f.parent.sourcepos[0][0] === f.sourcepos[0][0]; )
              f = f.parent;
            return f;
          }
          function pK(f, c) {
            for (var p = f.firstChild, k = null; p; ) {
              var O = Vf(p.sourcepos, c);
              if (O === 0) {
                if (p.sourcepos[0][0] === c || !p.firstChild)
                  return p;
                k = p, p = p.firstChild;
              } else {
                if (O === -1)
                  break;
                k = p, p = p.next;
              }
            }
            return k ? dK(vK(k)) : null;
          }
          function hK(f, c) {
            for (var p = f, k = null; p; ) {
              var O = sK(p.sourcepos, c);
              if (O === 0)
                if (p.firstChild)
                  k = p, p = p.firstChild;
                else
                  return p;
              else {
                if (O === -1)
                  return k;
                if (p.next)
                  p = p.next;
                else
                  return k;
              }
            }
            return p;
          }
          function Wf(f) {
            return e8(f) || null;
          }
          function Xl(f, c, p) {
            if (p === void 0 && (p = null), c)
              for (var k = c.walker(); c && c !== p; ) {
                f(c);
                var O = k.next();
                if (O)
                  c = O.node;
                else
                  break;
              }
          }
          function mK(f) {
            var c = Wf(f);
            if (!c)
              return !0;
            for (; c && c.type !== "document"; ) {
              if (!c.parent && !c.prev && !c.next)
                return !0;
              c = c.parent;
            }
            return !1;
          }
          var jf = /\r\n|\n|\r/;
          function gK(f) {
            var c = f.match(/^[ \t]+/);
            if (c && (c[0].length >= 2 || /\t/.test(c[0])))
              return !0;
            var p = c ? f.slice(c.length) : f;
            return Ff.test(p) || _f.test(p);
          }
          function yK(f) {
            return !Bf(f) && f.indexOf("|") !== -1;
          }
          function eu(f) {
            var c = f.id, p = f.title, k = f.sourcepos, O = f.dest;
            return {
              id: c,
              title: p,
              sourcepos: k,
              unlinked: !1,
              destination: O
            };
          }
          var bK = (
            /** @class */
            function() {
              function f(c, p) {
                this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.referenceDefinition = !!(p != null && p.referenceDefinition), this.parser = new oK(p), this.parser.setRefMaps(this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap), this.eventHandlerMap = { change: [] }, c = c || "", this.lineTexts = c.split(jf), this.root = this.parser.parse(c, this.lineTexts);
              }
              return f.prototype.updateLineTexts = function(c, p, k) {
                var O, U = c[0], j = c[1], Q = p[0], ke = p[1], xe = k.split(jf), Ue = xe.length, $e = this.lineTexts[U - 1], Be = this.lineTexts[Q - 1];
                xe[0] = $e.slice(0, j - 1) + xe[0], xe[Ue - 1] = xe[Ue - 1] + Be.slice(ke - 1);
                var tt = Q - U + 1;
                return (O = this.lineTexts).splice.apply(O, _([U - 1, tt], xe)), Ue - tt;
              }, f.prototype.updateRootNodeState = function() {
                if (this.lineTexts.length === 1 && this.lineTexts[0] === "") {
                  this.root.lastLineBlank = !0, this.root.sourcepos = [
                    [1, 1],
                    [1, 0]
                  ];
                  return;
                }
                this.root.lastChild && (this.root.lastLineBlank = this.root.lastChild.lastLineBlank);
                for (var c = this.lineTexts, p = c.length - 1; c[p] === ""; )
                  p -= 1;
                c.length - 2 > p && (p += 1), this.root.sourcepos[1] = [p + 1, c[p].length];
              }, f.prototype.replaceRangeNodes = function(c, p, k) {
                c ? ($f(c, k), lK(c, p), [c.id, p.id].forEach(function(O) {
                  return Ul(O);
                }), c.unlink()) : p ? ($f(p, k), Ul(p.id), p.unlink()) : cK(this.root, k);
              }, f.prototype.getNodeRange = function(c, p) {
                var k = zo(this.root, c[0]), O = zo(this.root, p[0]);
                return O && O.next && p[0] + 1 === O.next.sourcepos[0][0] && (O = O.next), [k, O];
              }, f.prototype.trigger = function(c, p) {
                this.eventHandlerMap[c].forEach(function(k) {
                  k(p);
                });
              }, f.prototype.extendEndLine = function(c) {
                for (; this.lineTexts[c] === ""; )
                  c += 1;
                return c;
              }, f.prototype.parseRange = function(c, p, k, O) {
                c && c.prev && (mf(c.prev) && gK(this.lineTexts[k - 1]) || h8(c.prev) && yK(this.lineTexts[k - 1])) && (c = c.prev, k = c.sourcepos[0][0]);
                for (var U = this.lineTexts.slice(k - 1, O), j = this.parser.partialParseStart(k, U), Q = p ? p.next : this.root.firstChild, ke = j.lastChild, xe = ke && hf(ke) && ke.open, Ue = ke && gf(ke) && ke.open, $e = ke && mf(ke); (xe || Ue) && Q || $e && Q && (Q.type === "list" || Q.sourcepos[0][1] >= 2); ) {
                  var Be = this.extendEndLine(Q.sourcepos[1][0]);
                  this.parser.partialParseExtends(this.lineTexts.slice(O, Be)), c || (c = p), p = Q, O = Be, Q = Q.next;
                }
                this.parser.partialParseFinish();
                var tt = uK(j);
                return { newNodes: tt, extStartNode: c, extEndNode: p };
              }, f.prototype.getRemovedNodeRange = function(c, p) {
                return !c || c && ci(c) || p && ci(p) ? null : {
                  id: [c.id, p.id],
                  line: [c.sourcepos[0][0] - 1, p.sourcepos[1][0] - 1]
                };
              }, f.prototype.markDeletedRefMap = function(c, p) {
                var k = this;
                if (!fi(this.refMap)) {
                  var O = function(U) {
                    if (ci(U)) {
                      var j = k.refMap[U.label];
                      j && U.id === j.id && (j.unlinked = !0);
                    }
                  };
                  c && Xl(O, c.parent, p), p && Xl(O, p);
                }
              }, f.prototype.replaceWithNewRefDefState = function(c) {
                var p = this;
                if (!fi(this.refMap)) {
                  var k = function(O) {
                    if (ci(O)) {
                      var U = O.label, j = p.refMap[U];
                      (!j || j.unlinked) && (p.refMap[U] = eu(O));
                    }
                  };
                  c.forEach(function(O) {
                    Xl(k, O);
                  });
                }
              }, f.prototype.replaceWithRefDefCandidate = function() {
                var c = this;
                fi(this.refDefCandidateMap) || Fo(this.refDefCandidateMap, function(p, k) {
                  var O = k.label, U = k.sourcepos, j = c.refMap[O];
                  (!j || j.unlinked || j.sourcepos[0][0] > U[0][0]) && (c.refMap[O] = eu(k));
                });
              }, f.prototype.getRangeWithRefDef = function(c, p, k, O, U) {
                if (this.referenceDefinition && !fi(this.refMap)) {
                  var j = zo(this.root, c - 1), Q = zo(this.root, p + 1);
                  j && ci(j) && j !== k && j !== O && (k = j, c = k.sourcepos[0][0]), Q && ci(Q) && Q !== k && Q !== O && (O = Q, p = this.extendEndLine(O.sourcepos[1][0] + U));
                }
                return [k, O, c, p];
              }, f.prototype.parse = function(c, p, k) {
                k === void 0 && (k = 0);
                var O = this.getNodeRange(c, p), U = O[0], j = O[1], Q = U ? Math.min(U.sourcepos[0][0], c[0]) : c[0], ke = this.extendEndLine((j ? Math.max(j.sourcepos[1][0], p[0]) : p[0]) + k), xe = this.parseRange.apply(this, this.getRangeWithRefDef(Q, ke, U, j, k)), Ue = xe.newNodes, $e = xe.extStartNode, Be = xe.extEndNode, tt = this.getRemovedNodeRange($e, Be), et = Be ? Be.next : this.root.firstChild;
                return this.referenceDefinition ? (this.markDeletedRefMap($e, Be), this.replaceRangeNodes($e, Be, Ue), this.replaceWithNewRefDefState(Ue)) : this.replaceRangeNodes($e, Be, Ue), { nodes: Ue, removedNodeRange: tt, nextNode: et };
              }, f.prototype.parseRefLink = function() {
                var c = this, p = [];
                return fi(this.refMap) || Fo(this.refMap, function(k, O) {
                  O.unlinked && delete c.refMap[k], Fo(c.refLinkCandidateMap, function(U, j) {
                    var Q = j.node, ke = j.refLabel;
                    ke === k && p.push(c.parse(Q.sourcepos[0], Q.sourcepos[1]));
                  });
                }), p;
              }, f.prototype.removeUnlinkedCandidate = function() {
                fi(this.refDefCandidateMap) || [this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function(c) {
                  Fo(c, function(p) {
                    mK(p) && delete c[p];
                  });
                });
              }, f.prototype.editMarkdown = function(c, p, k) {
                var O = this.updateLineTexts(c, p, k), U = this.parse(c, p, O), j = U8(U, "nextNode");
                fK(U.nextNode, O), this.updateRootNodeState();
                var Q = [j];
                return this.referenceDefinition && (this.removeUnlinkedCandidate(), this.replaceWithRefDefCandidate(), Q = Q.concat(this.parseRefLink())), this.trigger("change", Q), Q;
              }, f.prototype.getLineTexts = function() {
                return this.lineTexts;
              }, f.prototype.getRootNode = function() {
                return this.root;
              }, f.prototype.findNodeAtPosition = function(c) {
                var p = hK(this.root, c);
                return !p || p === this.root ? null : p;
              }, f.prototype.findFirstNodeAtLine = function(c) {
                return pK(this.root, c);
              }, f.prototype.on = function(c, p) {
                this.eventHandlerMap[c].push(p);
              }, f.prototype.off = function(c, p) {
                var k = this.eventHandlerMap[c], O = k.indexOf(p);
                k.splice(O, 1);
              }, f.prototype.findNodeById = function(c) {
                return Wf(c);
              }, f.prototype.removeAllNode = function() {
                t8();
              }, f;
            }()
          ), kK = [
            "title",
            "textarea",
            "style",
            "xmp",
            "iframe",
            "noembed",
            "noframes",
            "script",
            "plaintext"
          ], Gf = new RegExp("<(/?(?:" + kK.join("|") + ")[^>]*>)", "ig");
          function Kf(f) {
            return Gf.test(f) ? f.replace(Gf, function(c, p) {
              return "&lt;" + p;
            }) : f;
          }
          var Jf = {
            heading: function(f, c) {
              var p = c.entering;
              return {
                type: p ? "openTag" : "closeTag",
                tagName: "h" + f.level,
                outerNewLine: !0
              };
            },
            text: function(f) {
              return {
                type: "text",
                content: f.literal
              };
            },
            softbreak: function(f, c) {
              var p = c.options;
              return {
                type: "html",
                content: p.softbreak
              };
            },
            linebreak: function() {
              return {
                type: "html",
                content: `<br />
`
              };
            },
            emph: function(f, c) {
              var p = c.entering;
              return {
                type: p ? "openTag" : "closeTag",
                tagName: "em"
              };
            },
            strong: function(f, c) {
              var p = c.entering;
              return {
                type: p ? "openTag" : "closeTag",
                tagName: "strong"
              };
            },
            paragraph: function(f, c) {
              var p, k = c.entering, O = (p = f.parent) === null || p === void 0 ? void 0 : p.parent;
              return O && O.type === "list" && O.listData.tight ? null : {
                type: k ? "openTag" : "closeTag",
                tagName: "p",
                outerNewLine: !0
              };
            },
            thematicBreak: function() {
              return {
                type: "openTag",
                tagName: "hr",
                outerNewLine: !0,
                selfClose: !0
              };
            },
            blockQuote: function(f, c) {
              var p = c.entering;
              return {
                type: p ? "openTag" : "closeTag",
                tagName: "blockquote",
                outerNewLine: !0,
                innerNewLine: !0
              };
            },
            list: function(f, c) {
              var p = c.entering, k = f.listData, O = k.type, U = k.start, j = O === "bullet" ? "ul" : "ol", Q = {};
              return j === "ol" && U !== null && U !== 1 && (Q.start = U.toString()), {
                type: p ? "openTag" : "closeTag",
                tagName: j,
                attributes: Q,
                outerNewLine: !0
              };
            },
            item: function(f, c) {
              var p = c.entering;
              return {
                type: p ? "openTag" : "closeTag",
                tagName: "li",
                outerNewLine: !0
              };
            },
            htmlInline: function(f, c) {
              var p = c.options, k = p.tagFilter ? Kf(f.literal) : f.literal;
              return { type: "html", content: k };
            },
            htmlBlock: function(f, c) {
              var p = c.options, k = p.tagFilter ? Kf(f.literal) : f.literal;
              return p.nodeId ? [
                { type: "openTag", tagName: "div", outerNewLine: !0 },
                { type: "html", content: k },
                { type: "closeTag", tagName: "div", outerNewLine: !0 }
              ] : { type: "html", content: k, outerNewLine: !0 };
            },
            code: function(f) {
              return [
                { type: "openTag", tagName: "code" },
                { type: "text", content: f.literal },
                { type: "closeTag", tagName: "code" }
              ];
            },
            codeBlock: function(f) {
              var c = f.info, p = c ? c.split(/\s+/) : [], k = [];
              return p.length > 0 && p[0].length > 0 && k.push("language-" + ui(p[0])), [
                { type: "openTag", tagName: "pre", outerNewLine: !0 },
                { type: "openTag", tagName: "code", classNames: k },
                { type: "text", content: f.literal },
                { type: "closeTag", tagName: "code" },
                { type: "closeTag", tagName: "pre", outerNewLine: !0 }
              ];
            },
            link: function(f, c) {
              var p = c.entering;
              if (p) {
                var k = f, O = k.title, U = k.destination;
                return {
                  type: "openTag",
                  tagName: "a",
                  attributes: q({ href: ui(U) }, O && { title: ui(O) })
                };
              }
              return { type: "closeTag", tagName: "a" };
            },
            image: function(f, c) {
              var p = c.getChildrenText, k = c.skipChildren, O = f, U = O.title, j = O.destination;
              return k(), {
                type: "openTag",
                tagName: "img",
                selfClose: !0,
                attributes: q({ src: ui(j), alt: p(f) }, U && { title: ui(U) })
              };
            },
            customBlock: function(f, c, p) {
              var k = f.info.trim().toLowerCase(), O = p[k];
              if (O)
                try {
                  return O(f, c);
                } catch (U) {
                  console.warn("[@toast-ui/editor] - The error occurred when " + k + " block node was parsed in markdown renderer: " + U);
                }
              return [
                { type: "openTag", tagName: "div", outerNewLine: !0 },
                { type: "text", content: f.literal },
                { type: "closeTag", tagName: "div", outerNewLine: !0 }
              ];
            },
            frontMatter: function(f) {
              return [
                {
                  type: "openTag",
                  tagName: "div",
                  outerNewLine: !0,
                  // Because front matter is metadata, it should not be render.
                  attributes: { style: "white-space: pre; display: none;" }
                },
                { type: "text", content: f.literal },
                { type: "closeTag", tagName: "div", outerNewLine: !0 }
              ];
            },
            customInline: function(f, c, p) {
              var k = f, O = k.info, U = k.firstChild, j = O.trim().toLowerCase(), Q = p[j], ke = c.entering;
              if (Q)
                try {
                  return Q(f, c);
                } catch (xe) {
                  console.warn("[@toast-ui/editor] - The error occurred when " + j + " inline node was parsed in markdown renderer: " + xe);
                }
              return ke ? [
                { type: "openTag", tagName: "span" },
                { type: "text", content: "$$" + O + (U ? " " : "") }
              ] : [
                { type: "text", content: "$$" },
                { type: "closeTag", tagName: "span" }
              ];
            }
          }, Yf = {
            strike: function(f, c) {
              var p = c.entering;
              return {
                type: p ? "openTag" : "closeTag",
                tagName: "del"
              };
            },
            item: function(f, c) {
              var p = c.entering, k = f.listData, O = k.checked, U = k.task;
              if (p) {
                var j = {
                  type: "openTag",
                  tagName: "li",
                  outerNewLine: !0
                };
                return U ? [
                  j,
                  {
                    type: "openTag",
                    tagName: "input",
                    selfClose: !0,
                    attributes: q(q({}, O && { checked: "" }), { disabled: "", type: "checkbox" })
                  },
                  {
                    type: "text",
                    content: " "
                  }
                ] : j;
              }
              return {
                type: "closeTag",
                tagName: "li",
                outerNewLine: !0
              };
            },
            table: function(f, c) {
              var p = c.entering;
              return {
                type: p ? "openTag" : "closeTag",
                tagName: "table",
                outerNewLine: !0
              };
            },
            tableHead: function(f, c) {
              var p = c.entering;
              return {
                type: p ? "openTag" : "closeTag",
                tagName: "thead",
                outerNewLine: !0
              };
            },
            tableBody: function(f, c) {
              var p = c.entering;
              return {
                type: p ? "openTag" : "closeTag",
                tagName: "tbody",
                outerNewLine: !0
              };
            },
            tableRow: function(f, c) {
              var p = c.entering;
              if (p)
                return {
                  type: "openTag",
                  tagName: "tr",
                  outerNewLine: !0
                };
              var k = [];
              if (f.lastChild)
                for (var O = f.parent.parent.columns.length, U = f.lastChild.endIdx, j = U + 1; j < O; j += 1)
                  k.push({
                    type: "openTag",
                    tagName: "td",
                    outerNewLine: !0
                  }, {
                    type: "closeTag",
                    tagName: "td",
                    outerNewLine: !0
                  });
              return k.push({
                type: "closeTag",
                tagName: "tr",
                outerNewLine: !0
              }), k;
            },
            tableCell: function(f, c) {
              var p = c.entering;
              if (f.ignored)
                return {
                  type: "text",
                  content: ""
                };
              var k = f.parent.parent, O = k.type === "tableHead" ? "th" : "td", U = k.parent, j = U.columns[f.startIdx], Q = j != null && j.align ? { align: j.align } : null;
              return p ? q({ type: "openTag", tagName: O, outerNewLine: !0 }, Q && { attributes: Q }) : {
                type: "closeTag",
                tagName: O,
                outerNewLine: !0
              };
            }
          }, wK = {
            softbreak: `
`,
            gfm: !1,
            tagFilter: !1,
            nodeId: !1
          };
          function CK(f) {
            for (var c = [], p = f.walker(), k = null; k = p.next(); ) {
              var O = k.node;
              O.type === "text" && c.push(O.literal);
            }
            return c.join("");
          }
          var TK = (
            /** @class */
            function() {
              function f(c) {
                this.buffer = [], this.options = q(q({}, wK), c), this.convertors = this.createConvertors(), delete this.options.convertors;
              }
              return f.prototype.createConvertors = function() {
                var c = q({}, Jf);
                if (this.options.gfm && (c = q(q({}, c), Yf)), this.options.convertors) {
                  var p = this.options.convertors, k = Object.keys(p), O = q(q({}, Jf), Yf);
                  k.forEach(function(U) {
                    var j = c[U], Q = p[U], ke = Object.keys(O).indexOf(U) === -1 ? U.toLowerCase() : U;
                    j ? c[ke] = function(xe, Ue, $e) {
                      return Ue.origin = function() {
                        return j(xe, Ue, $e);
                      }, Q(xe, Ue);
                    } : c[ke] = Q;
                  });
                }
                return c;
              }, f.prototype.getConvertors = function() {
                return this.convertors;
              }, f.prototype.getOptions = function() {
                return this.options;
              }, f.prototype.render = function(c) {
                var p = this;
                this.buffer = [];
                for (var k = c.walker(), O = null, U = function() {
                  var Q = O.node, ke = O.entering, xe = j.convertors[Q.type];
                  if (!xe)
                    return "continue";
                  var Ue = !1, $e = {
                    entering: ke,
                    leaf: !Hl(Q),
                    options: j.options,
                    getChildrenText: CK,
                    skipChildren: function() {
                      Ue = !0;
                    }
                  }, Be = gf(Q) || m8(Q) ? xe(Q, $e, j.convertors) : xe(Q, $e);
                  if (Be) {
                    var tt = Array.isArray(Be) ? Be : [Be];
                    tt.forEach(function(et, Lt) {
                      et.type === "openTag" && p.options.nodeId && Lt === 0 && (et.attributes || (et.attributes = {}), et.attributes["data-nodeid"] = String(Q.id)), p.renderHTMLNode(et);
                    }), Ue && (k.resumeAt(Q, !1), k.next());
                  }
                }, j = this; O = k.next(); )
                  U();
                return this.addNewLine(), this.buffer.join("");
              }, f.prototype.renderHTMLNode = function(c) {
                switch (c.type) {
                  case "openTag":
                  case "closeTag":
                    this.renderElementNode(c);
                    break;
                  case "text":
                    this.renderTextNode(c);
                    break;
                  case "html":
                    this.renderRawHtmlNode(c);
                    break;
                }
              }, f.prototype.generateOpenTagString = function(c) {
                var p = this, k = c.tagName, O = c.classNames, U = c.attributes;
                this.buffer.push("<" + k), O && O.length > 0 && this.buffer.push(' class="' + O.join(" ") + '"'), U && Object.keys(U).forEach(function(j) {
                  var Q = U[j];
                  p.buffer.push(" " + j + '="' + Q + '"');
                }), c.selfClose && this.buffer.push(" /"), this.buffer.push(">");
              }, f.prototype.generateCloseTagString = function(c) {
                var p = c.tagName;
                this.buffer.push("</" + p + ">");
              }, f.prototype.addNewLine = function() {
                this.buffer.length && qo(qo(this.buffer)) !== `
` && this.buffer.push(`
`);
              }, f.prototype.addOuterNewLine = function(c) {
                c.outerNewLine && this.addNewLine();
              }, f.prototype.addInnerNewLine = function(c) {
                c.innerNewLine && this.addNewLine();
              }, f.prototype.renderTextNode = function(c) {
                this.buffer.push(ui(c.content));
              }, f.prototype.renderRawHtmlNode = function(c) {
                this.addOuterNewLine(c), this.buffer.push(c.content), this.addOuterNewLine(c);
              }, f.prototype.renderElementNode = function(c) {
                c.type === "openTag" ? (this.addOuterNewLine(c), this.generateOpenTagString(c), c.selfClose ? this.addOuterNewLine(c) : this.addInnerNewLine(c)) : (this.addInnerNewLine(c), this.generateCloseTagString(c), this.addOuterNewLine(c));
              }, f;
            }()
          ), SK = y(956), EK = /* @__PURE__ */ y.n(SK), xK = y(969), Zf = /* @__PURE__ */ y.n(xK), AK = y(348), Qf = /* @__PURE__ */ y.n(AK), MK = y(349), Xf = /* @__PURE__ */ y.n(MK), LK = y(204), ev = /* @__PURE__ */ y.n(LK), OK = y(462), tu = /* @__PURE__ */ y.n(OK), DK = y(522), tv = /* @__PURE__ */ y.n(DK), NK = y(990), RK = /* @__PURE__ */ y.n(NK), IK = y(322), PK = /* @__PURE__ */ y.n(IK), BK = y(758), qK = /* @__PURE__ */ y.n(BK), FK = y(929), $o = /* @__PURE__ */ y.n(FK), _K = y(714), HK = /* @__PURE__ */ y.n(_K);
          y(471);
          var rv = "[A-Za-z][A-Za-z0-9-]*", UK = "[a-zA-Z_:][a-zA-Z0-9:._-]*", zK = "[^\"'=<>`\\x00-\\x20]+", $K = "'[^']*'", VK = '"[^"]*"', WK = "(?:" + zK + "|" + $K + "|" + VK + ")", jK = "(?:\\s*=\\s*" + WK + ")", nv = "(?:\\s+" + UK + jK + "?)", GK = "<(" + rv + ")(" + nv + ")*\\s*/?>", KK = "</(" + rv + ")\\s*[>]", JK = "(?:" + GK + "|" + KK + ")", av = new RegExp("^" + JK, "i");
          y(934), y(391);
          function ru(f, c) {
            return f.indexOf(c) !== -1;
          }
          var YK = ["rel", "target", "hreflang", "type"];
          function ZK(f) {
            if (!f)
              return null;
            var c = {};
            return YK.forEach(function(p) {
              $o()(f[p]) || (c[p] = f[p]);
            }), c;
          }
          function QK(f) {
            return f[f.length - 1];
          }
          function nu(f) {
            return typeof f == "object" && f !== null;
          }
          function au(f, c) {
            var p = T({}, f);
            return f && c && Object.keys(c).forEach(function(k) {
              nu(p[k]) ? Array.isArray(c[k]) ? p[k] = iu(c[k]) : p.hasOwnProperty(k) ? p[k] = au(p[k], c[k]) : p[k] = ou(c[k]) : p[k] = c[k];
            }), p;
          }
          function iu(f) {
            return f.map(function(c) {
              return nu(c) ? Array.isArray(c) ? iu(c) : ou(c) : c;
            });
          }
          function ou(f) {
            var c = Object.keys(f);
            return c.length ? c.reduce(function(p, k) {
              return nu(f[k]) ? p[k] = Array.isArray(f[k]) ? iu(f[k]) : ou(f[k]) : p[k] = f[k], p;
            }, {}) : f;
          }
          function iv(f, c) {
            return c === void 0 && (c = {}), Object.keys(c).forEach(function(p) {
              f.hasOwnProperty(p) && typeof f[p] == "object" ? Array.isArray(c[p]) ? f[p] = c[p] : iv(f[p], c[p]) : f[p] = c[p];
            }), f;
          }
          function ov(f, c) {
            return f > c ? [c, f] : [f, c];
          }
          function XK(f, c, p) {
            var k = parseInt(f.left, 10), O = parseInt(f.top, 10), U = parseInt(f.width, 10) + parseInt(f.paddingLeft, 10) + parseInt(f.paddingRight, 10), j = parseInt(f.height, 10) + parseInt(f.paddingTop, 10) + parseInt(f.paddingBottom, 10);
            return c >= k && c <= k + U && p >= O && p <= O + j;
          }
          var e6 = "toastui-editor-";
          function Vo() {
            for (var f = [], c = 0; c < arguments.length; c++)
              f[c] = arguments[c];
            for (var p = [], k = 0, O = f; k < O.length; k++) {
              var U = O[k], j = void 0;
              Array.isArray(U) ? j = U[0] ? U[1] : null : j = U, j && p.push("" + e6 + j);
            }
            return p.join(" ");
          }
          function sv(f) {
            f.parentNode && f.parentNode.removeChild(f);
          }
          function lv(f, c, p) {
            $o()(p) && (p = !HK()(f, c));
            var k = p ? ev() : tu();
            k(f, c);
          }
          function t6(f, c) {
            var p = document.createElement("div");
            qK()(f) ? p.innerHTML = f : p.appendChild(f);
            var k = p.firstChild;
            return c && c.appendChild(k), k;
          }
          function r6(f) {
            var c = /<img class="ProseMirror-separator" alt="">/g, p = / class="ProseMirror-trailingBreak"/g, k = f;
            return k = k.replace(c, ""), k = k.replace(p, ""), k;
          }
          var n6 = y(294), uv = /* @__PURE__ */ y.n(n6);
          function a6(f) {
            return f.sourcepos[0][1];
          }
          function i6(f) {
            switch (f.type) {
              case "code":
              case "text":
              case "emph":
              case "strong":
              case "strike":
              case "link":
              case "image":
              case "htmlInline":
              case "linebreak":
              case "softbreak":
              case "customInline":
                return !0;
              default:
                return !1;
            }
          }
          function o6(f, c, p) {
            for (p === void 0 && (p = !0), f = p ? f : f.parent; f && f.type !== "document"; ) {
              if (c(f))
                return f;
              f = f.parent;
            }
            return null;
          }
          function s6(f) {
            var c = f.firstChild.literal;
            switch (f.type) {
              case "emph":
                return "*" + c + "*";
              case "strong":
                return "**" + c + "**";
              case "strike":
                return "~~" + c + "~~";
              case "code":
                return "`" + c + "`";
              case "link":
              case "image":
                var p = f, k = p.destination, O = p.title, U = f.type === "link" ? "" : "!";
                return U + "[" + c + "](" + k + (O ? ' "' + O + '"' : "") + ")";
              default:
                return null;
            }
          }
          var l6 = {}, cv = /\$\$widget\d+\s/;
          function fv(f) {
            var c = f.search(cv);
            if (c !== -1) {
              var p = f.substring(c), k = p.replace(cv, "").replace("$$", "");
              f = f.substring(0, c), f += fv(k);
            }
            return f;
          }
          function u6(f, c) {
            var p = l6[f], k = p.rule, O = p.toDOM, U = fv(c).match(k);
            return U && (c = U[0]), O(c);
          }
          function c6(f) {
            for (var c, p = "", k = f.walker(); c = k.next(); ) {
              var O = c.node, U = c.entering;
              U && (O !== f && O.type !== "text" ? (p += s6(O), k.resumeAt(f, !1), k.next()) : O.type === "text" && (p += O.literal));
            }
            return p;
          }
          var f6 = y(368), v6 = /* @__PURE__ */ y.n(f6), d6 = ["iframe", "embed"], vv = [];
          function p6(f) {
            ru(d6, f) && vv.push(f.toLowerCase());
          }
          function h6(f, c) {
            return v6().sanitize(f, T({ ADD_TAGS: vv, ADD_ATTR: ["rel", "target", "hreflang", "type"], FORBID_TAGS: [
              "input",
              "script",
              "textarea",
              "form",
              "button",
              "select",
              "meta",
              "style",
              "link",
              "title",
              "object",
              "base"
            ] }, c));
          }
          function m6(f, c) {
            return f.literal.replace(new RegExp("(<\\s*" + c + "[^>]*>)|(</" + c + "\\s*[>])", "ig"), "").trim();
          }
          function g6(f) {
            f = f.match(av)[0];
            var c = f.match(new RegExp(nv, "g"));
            return c ? c.reduce(function(p, k) {
              var O = k.trim().split("="), U = O[0], j = O.slice(1);
              return j.length && (p[U] = j.join("=").replace(/'|"/g, "").trim()), p;
            }, {}) : {};
          }
          var y6 = /^\s*<\s*\//, b6 = {
            paragraph: function(f, c) {
              var p = c.entering, k = c.origin, O = c.options;
              return O.nodeId ? {
                type: p ? "openTag" : "closeTag",
                outerNewLine: !0,
                tagName: "p"
              } : k();
            },
            softbreak: function(f) {
              var c = f.prev && f.prev.type === "htmlInline", p = c && /<br ?\/?>/.test(f.prev.literal), k = p ? `
` : `<br>
`;
              return { type: "html", content: k };
            },
            item: function(f, c) {
              var p = c.entering;
              if (p) {
                var k = {}, O = [];
                return f.listData.task && (k["data-task"] = "", O.push("task-list-item"), f.listData.checked && (O.push("checked"), k["data-task-checked"] = "")), {
                  type: "openTag",
                  tagName: "li",
                  classNames: O,
                  attributes: k,
                  outerNewLine: !0
                };
              }
              return {
                type: "closeTag",
                tagName: "li",
                outerNewLine: !0
              };
            },
            code: function(f) {
              var c = { "data-backticks": String(f.tickCount) };
              return [
                { type: "openTag", tagName: "code", attributes: c },
                { type: "text", content: f.literal },
                { type: "closeTag", tagName: "code" }
              ];
            },
            codeBlock: function(f) {
              var c = f, p = c.fenceLength, k = c.info, O = k ? k.split(/\s+/) : [], U = [], j = {};
              if (p > 3 && (j["data-backticks"] = p), O.length > 0 && O[0].length > 0) {
                var Q = O[0];
                U.push("lang-" + Q), j["data-language"] = Q;
              }
              return [
                { type: "openTag", tagName: "pre", classNames: U },
                { type: "openTag", tagName: "code", attributes: j },
                { type: "text", content: f.literal },
                { type: "closeTag", tagName: "code" },
                { type: "closeTag", tagName: "pre" }
              ];
            },
            customInline: function(f, c) {
              var p = c.origin, k = c.entering, O = c.skipChildren, U = f.info;
              if (U.indexOf("widget") !== -1 && k) {
                O();
                var j = c6(f), Q = u6(U, j).outerHTML;
                return [
                  { type: "openTag", tagName: "span", classNames: ["tui-widget"] },
                  { type: "html", content: Q },
                  { type: "closeTag", tagName: "span" }
                ];
              }
              return p();
            }
          };
          function k6(f, c) {
            var p = T({}, b6);
            return f && (p.link = function(k, O) {
              var U = O.entering, j = O.origin, Q = j();
              return U && (Q.attributes = T(T({}, Q.attributes), f)), Q;
            }), c && Object.keys(c).forEach(function(k) {
              var O = p[k], U = c[k];
              O && uv()(U) ? p[k] = function(j, Q) {
                var ke = T({}, Q);
                return ke.origin = function() {
                  return O(j, Q);
                }, U(j, ke);
              } : ru(["htmlBlock", "htmlInline"], k) && !uv()(U) ? p[k] = function(j, Q) {
                var ke = j.literal.match(av);
                if (ke) {
                  var xe = ke[0], Ue = ke[1], $e = ke[3], Be = (Ue || $e).toLowerCase(), tt = U[Be], et = m6(j, Be);
                  if (tt) {
                    var Lt = T({}, j);
                    return Lt.attrs = g6(xe), Lt.childrenHTML = et, Lt.type = Be, Q.entering = !y6.test(j.literal), tt(Lt, Q);
                  }
                }
                return Q.origin();
              } : p[k] = U;
            }), p;
          }
          var w6 = ["UL", "OL", "BLOCKQUOTE"];
          function C6(f, c) {
            for (var p = 0; f && f !== c && (ru(w6, f.tagName) || (p += f.offsetTop), f.offsetParent !== c.offsetParent); )
              f = f.parentElement;
            return p;
          }
          function T6(f, c) {
            for (var p = c, k = null; p; ) {
              var O = p.firstElementChild;
              if (!O)
                break;
              var U = dv(O, f, C6(p, c));
              k = p, p = U;
            }
            var j = p || k;
            return j === c ? null : j;
          }
          function dv(f, c, p) {
            return f && c > p + f.offsetTop ? dv(f.nextElementSibling, c, p) || f : null;
          }
          var S6 = {};
          function su(f) {
            f && (delete S6[Number(f.getAttribute("data-nodeid"))], RK()(f.children).forEach(function(c) {
              su(c);
            }));
          }
          var lu = Vo("md-preview-highlight");
          function E6(f, c) {
            for (var p = f.firstChild; p && p.next && !(a6(p.next) > c + 1); )
              p = p.next;
            return p;
          }
          var x6 = (
            /** @class */
            function() {
              function f(c, p) {
                var k = document.createElement("div");
                this.el = k, this.eventEmitter = c, this.isViewer = !!p.isViewer, this.el.className = Vo("md-preview");
                var O = p.linkAttributes, U = p.customHTMLRenderer, j = p.sanitizer, Q = p.highlight, ke = Q === void 0 ? !1 : Q;
                this.renderer = new TK({
                  gfm: !0,
                  nodeId: !0,
                  convertors: k6(O, U)
                }), this.cursorNodeId = null, this.sanitizer = j, this.initEvent(ke), this.initContentSection(), this.isViewer && (this.previewContent.style.overflowWrap = "break-word");
              }
              return f.prototype.initContentSection = function() {
                this.previewContent = t6('<div class="' + Vo("contents") + '"></div>'), this.isViewer || this.el.appendChild(this.previewContent);
              }, f.prototype.toggleActive = function(c) {
                lv(this.el, "active", c);
              }, f.prototype.initEvent = function(c) {
                var p = this;
                this.eventEmitter.listen("updatePreview", this.update.bind(this)), !this.isViewer && (c && (this.eventEmitter.listen("changeToolbarState", function(k) {
                  var O = k.mdNode, U = k.cursorPos;
                  p.updateCursorNode(O, U);
                }), this.eventEmitter.listen("blur", function() {
                  p.removeHighlight();
                })), Qf()(this.el, "scroll", function(k) {
                  p.eventEmitter.emit("scroll", "preview", T6(k.target.scrollTop, p.previewContent));
                }), this.eventEmitter.listen("changePreviewTabPreview", function() {
                  return p.toggleActive(!0);
                }), this.eventEmitter.listen("changePreviewTabWrite", function() {
                  return p.toggleActive(!1);
                }));
              }, f.prototype.removeHighlight = function() {
                if (this.cursorNodeId) {
                  var c = this.getElementByNodeId(this.cursorNodeId);
                  c && tu()(c, lu);
                }
              }, f.prototype.updateCursorNode = function(c, p) {
                c && (c = o6(c, function(j) {
                  return !i6(j);
                }), c.type === "tableRow" ? c = E6(c, p[1]) : c.type === "tableBody" && (c = null));
                var k = c ? c.id : null;
                if (this.cursorNodeId !== k) {
                  var O = this.getElementByNodeId(this.cursorNodeId), U = this.getElementByNodeId(k);
                  O && tu()(O, lu), U && ev()(U, lu), this.cursorNodeId = k;
                }
              }, f.prototype.getElementByNodeId = function(c) {
                return c ? this.previewContent.querySelector('[data-nodeid="' + c + '"]') : null;
              }, f.prototype.update = function(c) {
                var p = this;
                c.forEach(function(k) {
                  return p.replaceRangeNodes(k);
                }), this.eventEmitter.emit("afterPreviewRender", this);
              }, f.prototype.replaceRangeNodes = function(c) {
                var p = this, k = c.nodes, O = c.removedNodeRange, U = this.previewContent, j = this.eventEmitter.emitReduce("beforePreviewRender", this.sanitizer(k.map(function(et) {
                  return p.renderer.render(et);
                }).join("")));
                if (!O)
                  U.insertAdjacentHTML("afterbegin", j);
                else {
                  var Q = O.id, ke = Q[0], xe = Q[1], Ue = this.getElementByNodeId(ke), $e = this.getElementByNodeId(xe);
                  if (Ue) {
                    Ue.insertAdjacentHTML("beforebegin", j);
                    for (var Be = Ue; Be && Be !== $e; ) {
                      var tt = Be.nextElementSibling;
                      sv(Be), su(Be), Be = tt;
                    }
                    Be != null && Be.parentNode && (sv(Be), su(Be));
                  }
                }
              }, f.prototype.getRenderer = function() {
                return this.renderer;
              }, f.prototype.destroy = function() {
                Xf()(this.el, "scroll"), this.el = null;
              }, f.prototype.getElement = function() {
                return this.el;
              }, f.prototype.getHTML = function() {
                return r6(this.previewContent.innerHTML);
              }, f.prototype.setHTML = function(c) {
                this.previewContent.innerHTML = c;
              }, f.prototype.setHeight = function(c) {
                tv()(this.el, { height: c + "px" });
              }, f.prototype.setMinHeight = function(c) {
                tv()(this.el, { minHeight: c + "px" });
              }, f;
            }()
          ), A6 = x6, Wo = y(814), uu = y(479), pv = y(311), M6 = y(481), L6 = y(43), O6 = y(928), D6 = /* @__PURE__ */ y.n(O6), N6 = (
            /** @class */
            function() {
              function f() {
                this.keys = [], this.values = [];
              }
              return f.prototype.getKeyIndex = function(c) {
                return D6()(c, this.keys);
              }, f.prototype.get = function(c) {
                return this.values[this.getKeyIndex(c)];
              }, f.prototype.set = function(c, p) {
                var k = this.getKeyIndex(c);
                return k > -1 ? this.values[k] = p : (this.keys.push(c), this.values.push(p)), this;
              }, f.prototype.has = function(c) {
                return this.getKeyIndex(c) > -1;
              }, f.prototype.delete = function(c) {
                var p = this.getKeyIndex(c);
                return p > -1 ? (this.keys.splice(p, 1), this.values.splice(p, 1), !0) : !1;
              }, f.prototype.forEach = function(c, p) {
                var k = this;
                p === void 0 && (p = this), this.values.forEach(function(O, U) {
                  O && k.keys[U] && c.call(p, O, k.keys[U], k);
                });
              }, f.prototype.clear = function() {
                this.keys = [], this.values = [];
              }, f;
            }()
          ), hv = N6, cu = "en-US", R6 = (
            /** @class */
            function() {
              function f() {
                this.code = cu, this.langs = new hv();
              }
              return f.prototype.setCode = function(c) {
                this.code = c || cu;
              }, f.prototype.setLanguage = function(c, p) {
                var k = this;
                c = [].concat(c), c.forEach(function(O) {
                  if (!k.langs.has(O))
                    k.langs.set(O, p);
                  else {
                    var U = k.langs.get(O);
                    k.langs.set(O, Zf()(U, p));
                  }
                });
              }, f.prototype.get = function(c, p) {
                p || (p = this.code);
                var k = this.langs.get(p);
                k || (k = this.langs.get(cu));
                var O = k[c];
                if (!O)
                  throw new Error('There is no text key "' + c + '" in ' + p);
                return O;
              }, f;
            }()
          ), I6 = new R6();
          function P6(f, c) {
            for (var p = f.depth; p; ) {
              var k = f.node(p);
              if (c(k, p))
                return {
                  node: k,
                  depth: p,
                  offset: p > 0 ? f.before(p) : 0
                };
              p -= 1;
            }
            return null;
          }
          var mv = /* @__PURE__ */ new Map(), gv = (
            /** @class */
            function() {
              function f(c, p, k, O) {
                this.table = c, this.tableRows = p, this.tableStartPos = k, this.rowInfo = O;
              }
              return f.create = function(c) {
                var p = P6(c, function(et) {
                  var Lt = et.type;
                  return Lt.name === "table";
                });
                if (p) {
                  var k = p.node, O = p.depth, U = p.offset, j = mv.get(k);
                  if ((j == null ? void 0 : j.tableStartPos) === U + 1)
                    return j;
                  var Q = [], ke = c.start(O), xe = k.child(0), Ue = k.child(1), $e = fu(xe, ke), Be = fu(Ue, ke + xe.nodeSize);
                  xe.forEach(function(et) {
                    return Q.push(et);
                  }), Ue.forEach(function(et) {
                    return Q.push(et);
                  });
                  var tt = new f(k, Q, ke, $e.concat(Be));
                  return mv.set(k, tt), tt;
                }
                return null;
              }, Object.defineProperty(f.prototype, "totalRowCount", {
                get: function() {
                  return this.rowInfo.length;
                },
                enumerable: !1,
                configurable: !0
              }), Object.defineProperty(f.prototype, "totalColumnCount", {
                get: function() {
                  return this.rowInfo[0].length;
                },
                enumerable: !1,
                configurable: !0
              }), Object.defineProperty(f.prototype, "tableStartOffset", {
                get: function() {
                  return this.tableStartPos;
                },
                enumerable: !1,
                configurable: !0
              }), Object.defineProperty(f.prototype, "tableEndOffset", {
                get: function() {
                  return this.tableStartPos + this.table.nodeSize - 1;
                },
                enumerable: !1,
                configurable: !0
              }), f.prototype.getCellInfo = function(c, p) {
                return this.rowInfo[c][p];
              }, f.prototype.posAt = function(c, p) {
                for (var k = 0, O = this.tableStartPos; ; k += 1) {
                  var U = O + this.tableRows[k].nodeSize;
                  if (k === c) {
                    for (var j = p; j < this.totalColumnCount && this.rowInfo[k][j].offset < O; )
                      j += 1;
                    return j === this.totalColumnCount ? U : this.rowInfo[k][j].offset;
                  }
                  O = U;
                }
              }, f.prototype.getNodeAndPos = function(c, p) {
                var k = this.rowInfo[c][p];
                return {
                  node: this.table.nodeAt(k.offset - this.tableStartOffset),
                  pos: k.offset
                };
              }, f.prototype.extendedRowspan = function(c, p) {
                return !1;
              }, f.prototype.extendedColspan = function(c, p) {
                return !1;
              }, f.prototype.getRowspanCount = function(c, p) {
                return 0;
              }, f.prototype.getColspanCount = function(c, p) {
                return 0;
              }, f.prototype.decreaseColspanCount = function(c, p) {
                return 0;
              }, f.prototype.decreaseRowspanCount = function(c, p) {
                return 0;
              }, f.prototype.getColspanStartInfo = function(c, p) {
                return null;
              }, f.prototype.getRowspanStartInfo = function(c, p) {
                return null;
              }, f.prototype.getCellStartOffset = function(c, p) {
                var k = this.rowInfo[c][p].offset;
                return this.extendedRowspan(c, p) ? this.posAt(c, p) : k;
              }, f.prototype.getCellEndOffset = function(c, p) {
                var k = this.rowInfo[c][p], O = k.offset, U = k.nodeSize;
                return this.extendedRowspan(c, p) ? this.posAt(c, p) : O + U;
              }, f.prototype.getCellIndex = function(c) {
                for (var p = 0; p < this.totalRowCount; p += 1)
                  for (var k = this.rowInfo[p], O = 0; O < this.totalColumnCount; O += 1)
                    if (k[O].offset + 1 > c.pos)
                      return [p, O];
                return [0, 0];
              }, f.prototype.getRectOffsets = function(c, p) {
                var k, O, U;
                p === void 0 && (p = c), c.pos > p.pos && (k = [p, c], c = k[0], p = k[1]);
                var j = this.getCellIndex(c), Q = j[0], ke = j[1], xe = this.getCellIndex(p), Ue = xe[0], $e = xe[1];
                return O = ov(Q, Ue), Q = O[0], Ue = O[1], U = ov(ke, $e), ke = U[0], $e = U[1], this.getSpannedOffsets({ startRowIdx: Q, startColIdx: ke, endRowIdx: Ue, endColIdx: $e });
              }, f.prototype.getSpannedOffsets = function(c) {
                return c;
              }, f;
            }()
          ), fu = function(f, c) {
            var p = [];
            return f.forEach(function(k, O) {
              var U = { rowspanMap: {}, colspanMap: {}, length: 0 };
              k.forEach(function(j, Q) {
                for (var ke = j.nodeSize, xe = 0; U[xe]; )
                  xe += 1;
                U[xe] = {
                  // 2 is the sum of the front and back positions of the tag
                  offset: c + O + Q + 2,
                  nodeSize: ke
                }, U.length += 1;
              }), p.push(U);
            }), p;
          };
          function B6(f, c) {
            return iv(gv.prototype, f), fu = c, gv;
          }
          function q6(f) {
            var c = f.plugin, p = f.eventEmitter, k = f.usageStatistics, O = f.instance, U = { Plugin: Wo.Plugin, PluginKey: Wo.PluginKey, Selection: Wo.Selection, TextSelection: Wo.TextSelection }, j = { Decoration: pv.Decoration, DecorationSet: pv.DecorationSet }, Q = { Fragment: L6.Fragment }, ke = { InputRule: uu.InputRule, inputRules: uu.inputRules, undoInputRule: uu.undoInputRule }, xe = { keymap: M6.keymap }, Ue = {
              eventEmitter: p,
              usageStatistics: k,
              instance: O,
              pmState: U,
              pmView: j,
              pmModel: Q,
              pmRules: ke,
              pmKeymap: xe,
              i18n: I6
            };
            if (PK()(c)) {
              var $e = c[0], Be = c[1], tt = Be === void 0 ? {} : Be;
              return $e(Ue, tt);
            }
            return c(Ue);
          }
          function F6(f) {
            var c = f.plugins, p = f.eventEmitter, k = f.usageStatistics, O = f.instance;
            return p.listen("mixinTableOffsetMapPrototype", B6), (c ?? []).reduce(function(U, j) {
              var Q = q6({
                plugin: j,
                eventEmitter: p,
                usageStatistics: k,
                instance: O
              });
              if (!Q)
                throw new Error("The return value of the executed plugin is empty.");
              var ke = Q.markdownParsers, xe = Q.toHTMLRenderers, Ue = Q.toMarkdownRenderers, $e = Q.markdownPlugins, Be = Q.wysiwygPlugins, tt = Q.wysiwygNodeViews, et = Q.markdownCommands, Lt = Q.wysiwygCommands, er = Q.toolbarItems;
              return xe && (U.toHTMLRenderers = au(U.toHTMLRenderers, xe)), Ue && (U.toMarkdownRenderers = au(U.toMarkdownRenderers, Ue)), $e && (U.mdPlugins = U.mdPlugins.concat($e)), Be && (U.wwPlugins = U.wwPlugins.concat(Be)), tt && (U.wwNodeViews = T(T({}, U.wwNodeViews), tt)), et && (U.mdCommands = T(T({}, U.mdCommands), et)), Lt && (U.wwCommands = T(T({}, U.wwCommands), Lt)), er && (U.toolbarItems = U.toolbarItems.concat(er)), ke && (U.markdownParsers = T(T({}, U.markdownParsers), ke)), U;
            }, {
              toHTMLRenderers: {},
              toMarkdownRenderers: {},
              mdPlugins: [],
              wwPlugins: [],
              wwNodeViews: {},
              mdCommands: {},
              wwCommands: {},
              toolbarItems: [],
              markdownParsers: {}
            });
          }
          var _6 = y(404), H6 = /* @__PURE__ */ y.n(_6), yv = [
            "afterPreviewRender",
            "updatePreview",
            "changeMode",
            "needChangeMode",
            "command",
            "changePreviewStyle",
            "changePreviewTabPreview",
            "changePreviewTabWrite",
            "scroll",
            "contextmenu",
            "show",
            "hide",
            "changeLanguage",
            "changeToolbarState",
            "toggleScrollSync",
            "mixinTableOffsetMapPrototype",
            "setFocusedNode",
            "removePopupWidget",
            "query",
            // provide event for user
            "openPopup",
            "closePopup",
            "addImageBlobHook",
            "beforePreviewRender",
            "beforeConvertWysiwygToMarkdown",
            "load",
            "loadUI",
            "change",
            "caretChange",
            "destroy",
            "focus",
            "blur",
            "keydown",
            "keyup"
          ], U6 = (
            /** @class */
            function() {
              function f() {
                var c = this;
                this.events = new hv(), this.eventTypes = yv.reduce(function(p, k) {
                  return T(T({}, p), { type: k });
                }, {}), this.hold = !1, yv.forEach(function(p) {
                  c.addEventType(p);
                });
              }
              return f.prototype.listen = function(c, p) {
                var k = this.getTypeInfo(c), O = this.events.get(k.type) || [];
                if (!this.hasEventType(k.type))
                  throw new Error("There is no event type " + k.type);
                k.namespace && (p.namespace = k.namespace), O.push(p), this.events.set(k.type, O);
              }, f.prototype.emit = function(c) {
                for (var p = [], k = 1; k < arguments.length; k++)
                  p[k - 1] = arguments[k];
                var O = this.getTypeInfo(c), U = this.events.get(O.type), j = [];
                return !this.hold && U && U.forEach(function(Q) {
                  var ke = Q.apply(void 0, p);
                  $o()(ke) || j.push(ke);
                }), j;
              }, f.prototype.emitReduce = function(c, p) {
                for (var k = [], O = 2; O < arguments.length; O++)
                  k[O - 2] = arguments[O];
                var U = this.events.get(c);
                return !this.hold && U && U.forEach(function(j) {
                  var Q = j.apply(void 0, x([p], k));
                  H6()(Q) || (p = Q);
                }), p;
              }, f.prototype.getTypeInfo = function(c) {
                var p = c.split(".");
                return {
                  type: p[0],
                  namespace: p[1]
                };
              }, f.prototype.hasEventType = function(c) {
                return !$o()(this.eventTypes[this.getTypeInfo(c).type]);
              }, f.prototype.addEventType = function(c) {
                if (this.hasEventType(c))
                  throw new Error("There is already have event type " + c);
                this.eventTypes[c] = c;
              }, f.prototype.removeEventHandler = function(c, p) {
                var k = this, O = this.getTypeInfo(c), U = O.type, j = O.namespace;
                U && p ? this.removeEventHandlerWithHandler(U, p) : U && !j ? this.events.delete(U) : !U && j ? this.events.forEach(function(Q, ke) {
                  k.removeEventHandlerWithTypeInfo(ke, j);
                }) : U && j && this.removeEventHandlerWithTypeInfo(U, j);
              }, f.prototype.removeEventHandlerWithHandler = function(c, p) {
                var k = this.events.get(c);
                if (k) {
                  var O = k.indexOf(p);
                  k.indexOf(p) >= 0 && k.splice(O, 1);
                }
              }, f.prototype.removeEventHandlerWithTypeInfo = function(c, p) {
                var k = [], O = this.events.get(c);
                O && (O.map(function(U) {
                  return U.namespace !== p && k.push(U), null;
                }), this.events.set(c, k));
              }, f.prototype.getEvents = function() {
                return this.events;
              }, f.prototype.holdEventInvoke = function(c) {
                this.hold = !0, c(), this.hold = !1;
              }, f;
            }()
          ), z6 = U6, $6 = "data-task", V6 = "data-task-disabled", W6 = "checked";
          function j6(f) {
            ["htmlBlock", "htmlInline"].forEach(function(c) {
              f[c] && Object.keys(f[c]).forEach(function(p) {
                return p6(p);
              });
            });
          }
          var G6 = (
            /** @class */
            function() {
              function f(c) {
                var p = this;
                this.options = Zf()({
                  linkAttributes: null,
                  extendedAutolinks: !1,
                  customHTMLRenderer: null,
                  referenceDefinition: !1,
                  customHTMLSanitizer: null,
                  frontMatter: !1,
                  usageStatistics: !0,
                  theme: "light"
                }, c), this.eventEmitter = new z6();
                var k = ZK(this.options.linkAttributes), O = F6({
                  plugins: this.options.plugins,
                  eventEmitter: this.eventEmitter,
                  usageStatistics: this.options.usageStatistics,
                  instance: this
                }) || {}, U = O.toHTMLRenderers, j = O.markdownParsers, Q = this.options, ke = Q.customHTMLRenderer, xe = Q.extendedAutolinks, Ue = Q.referenceDefinition, $e = Q.frontMatter, Be = Q.customHTMLSanitizer, tt = {
                  linkAttributes: k,
                  customHTMLRenderer: T(T({}, U), ke),
                  extendedAutolinks: xe,
                  referenceDefinition: Ue,
                  frontMatter: $e,
                  sanitizer: Be || h6
                };
                j6(tt.customHTMLRenderer), this.options.events && EK()(this.options.events, function(sn, Xr) {
                  p.on(Xr, sn);
                });
                var et = this.options, Lt = et.el, er = et.initialValue, yr = et.theme, Gn = Lt.innerHTML;
                yr !== "light" && Lt.classList.add(Vo(yr)), Lt.innerHTML = "", this.toastMark = new bK("", {
                  disallowedHtmlBlockTags: ["br", "img"],
                  extendedAutolinks: xe,
                  referenceDefinition: Ue,
                  disallowDeepHeading: !0,
                  frontMatter: $e,
                  customParser: j
                }), this.preview = new A6(this.eventEmitter, T(T({}, tt), { isViewer: !0 })), Qf()(this.preview.previewContent, "mousedown", this.toggleTask.bind(this)), er ? this.setMarkdown(er) : Gn && this.preview.setHTML(Gn), Lt.appendChild(this.preview.previewContent), this.eventEmitter.emit("load", this);
              }
              return f.prototype.toggleTask = function(c) {
                var p = c.target, k = getComputedStyle(p, ":before");
                !p.hasAttribute(V6) && p.hasAttribute($6) && XK(k, c.offsetX, c.offsetY) && (lv(p, W6), this.eventEmitter.emit("change", {
                  source: "viewer",
                  date: c
                }));
              }, f.prototype.setMarkdown = function(c) {
                var p = this.toastMark.getLineTexts(), k = p.length, O = QK(p), U = [k, O.length + 1], j = this.toastMark.editMarkdown([1, 1], U, c || "");
                this.eventEmitter.emit("updatePreview", j);
              }, f.prototype.on = function(c, p) {
                this.eventEmitter.listen(c, p);
              }, f.prototype.off = function(c) {
                this.eventEmitter.removeEventHandler(c);
              }, f.prototype.addHook = function(c, p) {
                this.eventEmitter.removeEventHandler(c), this.eventEmitter.listen(c, p);
              }, f.prototype.destroy = function() {
                Xf()(this.preview.el, "mousedown", this.toggleTask.bind(this)), this.preview.destroy(), this.eventEmitter.emit("destroy");
              }, f.prototype.isViewer = function() {
                return !0;
              }, f.prototype.isMarkdownMode = function() {
                return !1;
              }, f.prototype.isWysiwygMode = function() {
                return !1;
              }, f;
            }()
          ), K6 = G6, J6 = K6;
        }(), C = C.default, C;
      }()
    );
  });
})(ig);
var fVe = ig.exports;
const vVe = /* @__PURE__ */ nJ(fVe), dVe = (t, e) => {
  if (!t.value)
    throw new Error("Reference to the element is set");
  return new vVe({
    el: t.value,
    plugins: e.plugins,
    initialValue: e.initialValue,
    customHTMLSanitizer: (n) => n
  });
}, pVe = /* @__PURE__ */ Wp({
  __name: "Viewer",
  props: {
    value: {},
    plugins: { default: () => [] },
    darkMode: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t, r = ns(null);
    return jp(() => {
      dVe(r, {
        initialValue: e.value,
        plugins: e.plugins
      });
    }), (n, a) => (_u(), Hu("div", {
      class: Uu({ "toastui-editor-dark": n.darkMode }),
      ref_key: "viewer",
      ref: r
    }, null, 2));
  }
}), Vp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Editor: cVe,
  Viewer: pVe
}, Symbol.toStringTag, { value: "Module" }));
function hVe(t) {
  for (const e in Vp)
    t.component(e, Vp[e]);
}
const gVe = { install: hVe };
export {
  cVe as Editor,
  pVe as Viewer,
  gVe as default
};
